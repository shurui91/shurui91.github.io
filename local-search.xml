<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[LeetCode] 79. Word Search</title>
    <link href="/posts/909738304.html"/>
    <url>/posts/909738304.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n grid of characters board and a string word, return true if word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="Example 1"><br>Input: board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>Output: true</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="Example 2"><br>Input: board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”<br>Output: true</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="Example 3"><br>Input: board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”<br>Output: false</p><p>Constraints:<br>m &#x3D;&#x3D; board.length<br>n &#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 6<br>1 &lt;&#x3D; word.length &lt;&#x3D; 15<br>board and word consists of only lowercase and uppercase English letters.</p><p>Follow up: Could you use search pruning to make your solution faster with a larger board?</p><p>单词搜索。</p><blockquote>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-search">https://leetcode-cn.com/problems/word-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是回溯。可以参考<a href="https://leetcode.cn/problems/word-search/solution/zai-er-wei-ping-mian-shang-shi-yong-hui-su-fa-pyth/">这个帖子</a>里的PPT帮助理解回溯的过程。</p><p>需要写一个 helper 函数进行递归，同时也需要一个 visited 二维数组记录是否 visited 过某个点。</p><ul><li>第七行当 word的 第一个字母在 board 中被找到，才进入 helper 函数，回溯是往当前这个坐标的上下左右四个方向接着找下一个字母是否存在</li><li>helper 函数里面几个边界条件是<ul><li>如果扫描的时候已经到达 word 的长度，则 return true</li><li>如果扫描的时候超过了 board 的边界，则 return false</li><li>如果有字母已经被扫描过，则 return false - 这是为了防止走回头路</li><li>如果 word 当前字母不等于 board 当前被扫描的字母，则 return false</li></ul></li></ul><p>接着往四个方向回溯做，如果这四个方向有一个方向能扫描到 word 结尾则整个函数可以返回 true，否则需要回溯回到当前坐标 board[row][col] 并把它标记成 unvisited</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间 - O(m * n * 4^L) - m*n 是矩阵的尺寸，L 是单词的平均长度，除了第一次可以进入 4 个分支以外，其余时间我们最多会进入 3 个分支<br>空间 - O(mn) - visited数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word.charAt(<span class="hljs-number">0</span>) == board[i][j]) &#123;<br>                    <span class="hljs-keyword">if</span> (helper(board, i, j, word, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n])) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, String word, <span class="hljs-type">int</span> index, <span class="hljs-type">boolean</span>[][] visited)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == word.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= board.length || col &gt;= board[<span class="hljs-number">0</span>].length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (visited[row][col]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (board[row][col] != word.charAt(index)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        visited[row][col] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (helper(board, row + <span class="hljs-number">1</span>, col, word, index + <span class="hljs-number">1</span>, visited)<br>                || helper(board, row - <span class="hljs-number">1</span>, col, word, index + <span class="hljs-number">1</span>, visited)<br>                || helper(board, row, col - <span class="hljs-number">1</span>, word, index + <span class="hljs-number">1</span>, visited)<br>                || helper(board, row, col + <span class="hljs-number">1</span>, word, index + <span class="hljs-number">1</span>, visited)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// backtracking</span><br>        visited[row][col] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>string</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1504. Count Submatrices With All Ones</title>
    <link href="/posts/3229320101.html"/>
    <url>/posts/3229320101.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n binary matrix mat, return the number of submatrices that have all ones.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg" alt="Example 1"><br>Input: mat &#x3D; [[1,0,1],[1,1,0],[1,1,0]]<br>Output: 13<br>Explanation:<br>There are 6 rectangles of side 1x1.<br>There are 2 rectangles of side 1x2.<br>There are 3 rectangles of side 2x1.<br>There is 1 rectangle of side 2x2.<br>There is 1 rectangle of side 3x1.<br>Total number of rectangles &#x3D; 6 + 2 + 3 + 1 + 1 &#x3D; 13.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg" alt="Example 2"><br>Input: mat &#x3D; [[0,1,1,0],[0,1,1,1],[1,1,1,0]]<br>Output: 24<br>Explanation:<br>There are 8 rectangles of side 1x1.<br>There are 5 rectangles of side 1x2.<br>There are 2 rectangles of side 1x3.<br>There are 4 rectangles of side 2x1.<br>There are 2 rectangles of side 2x2.<br>There are 2 rectangles of side 3x1.<br>There is 1 rectangle of side 3x2.<br>Total number of rectangles &#x3D; 8 + 5 + 2 + 4 + 2 + 2 + 1 &#x3D; 24.</p><p>Constraints:<br>1 &lt;&#x3D; m, n &lt;&#x3D; 150<br>mat[i][j] is either 0 or 1.</p><p>统计全 1 子矩形。</p><blockquote>给你一个 m x n 的二进制矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是单调栈。做法类似84题和85题。</p><p>首先我们还是需要创建一个 heights 数组来记录矩阵里每个 j 位置上的高度。高度的定义是从当前行往上数，连续的1的个数。</p><p>把矩阵按行向下累计为“高度数组” h[j]：若 mat[i][j]&#x3D;&#x3D;1，则 h[j]++，否则清零。对于每一行的 h，计算<code>以该行作为底边、且右端点在每一列 j</code>的全 1 子矩阵数量之和。这个子问题等价于：在柱状图 h 中，统计以每个位置 j 作为右端点的矩形个数并求和。</p><p>用单调递增栈求解上一步：维护一个 sum[j] 表示“以 j 为右端点”的子矩阵数量。</p><ul><li>若栈空：sum[j] &#x3D; h[j] * (j + 1)</li><li>若有前一个更小柱高 prev：sum[j] &#x3D; sum[prev] + h[j] * (j - prev)<br>最后把本行所有 sum[j] 累加到答案。</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m * n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubmat</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    h[j]++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    h[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            res += helper(h);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> h.length;<br>        <span class="hljs-comment">// 以 j 为右端点的矩形个数</span><br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// sum[j] = 以 j 为右端点的矩形数</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; h[j] &lt;= h[stack.peekLast()]) &#123;<br>                stack.pollLast();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                <span class="hljs-comment">// 左边没有更小的柱子，宽度可延伸到 0..j</span><br>                sum[j] = h[j] * (j + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> stack.peekLast();<br>                <span class="hljs-comment">// 继承到 prev 的贡献 + 以高度 h[j] 向左延伸 (j - prev) 列的新矩形</span><br>                sum[j] = sum[prev] + h[j] * (j - prev);<br>            &#125;<br>            stack.offerLast(j);<br>            res += sum[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">84. Largest Rectangle in Histogram<br>85. Maximal Rectangle<br>221. Maximal Square<br>1277. Count Square Submatrices with All Ones<br>1504. Count Submatrices With All Ones<br>1727. Largest Submatrix With Rearrangements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2044. Count Number of Maximum Bitwise-OR Subsets</title>
    <link href="/posts/93896110.html"/>
    <url>/posts/93896110.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.</p><p>An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.</p><p>The bitwise OR of an array a is equal to a[0] OR a[1] OR … OR a[a.length - 1] (0-indexed).</p><p>Example 1:<br>Input: nums &#x3D; [3,1]<br>Output: 2<br>Explanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:</p><ul><li>[3]</li><li>[3,1]</li></ul><p>Example 2:<br>Input: nums &#x3D; [2,2,2]<br>Output: 7<br>Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 &#x3D; 7 total subsets.</p><p>Example 3:<br>Input: nums &#x3D; [3,2,1,5]<br>Output: 6<br>Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:</p><ul><li>[3,5]</li><li>[3,1,5]</li><li>[3,2,5]</li><li>[3,2,1,5]</li><li>[2,5]</li><li>[2,1,5]</li></ul><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 16<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><p>统计按位或能得到最大值的子集数目。</p><blockquote><p>给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。</p><p>如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。</p><p>对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR … OR a[a.length - 1]（下标从 0 开始）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目让我们求子集，那么思路就往 dfs 上靠。我们可以用一个递归函数来遍历所有可能的子集，并计算它们的按位或值。每次递归时，我们可以选择包含当前元素或不包含当前元素，从而生成所有可能的子集。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度是 O(2^n)，其中 n 是数组 nums 的长度<br>空间复杂度是 O(n)，主要是递归栈的空间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countMaxOrSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dfs(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> cur)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (cur == max) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &gt; max) &#123;<br>                max = cur;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 选择当前元素</span><br>        dfs(nums, index + <span class="hljs-number">1</span>, cur | nums[index]);<br>        <span class="hljs-comment">// 不选择当前元素</span><br>        dfs(nums, index + <span class="hljs-number">1</span>, cur);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>backtracking</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2210. Count Hills and Valleys in an Array</title>
    <link href="/posts/515074821.html"/>
    <url>/posts/515074821.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] &#x3D;&#x3D; nums[j].</p><p>Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.</p><p>Return the number of hills and valleys in nums.</p><p>Example 1:<br>Input: nums &#x3D; [2,4,1,1,6,5]<br>Output: 3<br>Explanation:<br>At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.<br>At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 &gt; 2 and 4 &gt; 1, index 1 is a hill.<br>At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 2 is a valley.<br>At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 3 is a valley, but note that it is part of the same valley as index 2.<br>At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 &gt; 1 and 6 &gt; 5, index 4 is a hill.<br>At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley.<br>There are 3 hills and valleys so we return 3.</p><p>Example 2:<br>Input: nums &#x3D; [6,6,5,5,4,1]<br>Output: 0<br>Explanation:<br>At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.<br>At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.<br>At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 2 is neither a hill nor a valley.<br>At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 3 is neither a hill nor a valley.<br>At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 &lt; 5 and 4 &gt; 1, index 4 is neither a hill nor a valley.<br>At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.<br>There are 0 hills and valleys so we return 0.</p><p>Constraints:<br>3 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><p>统计数组中峰和谷的数量。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] &#x3D;&#x3D; nums[j] ， 则认为这两下标属于 同一个 峰或谷。</p><p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。</p><p>返回 nums 中峰和谷的数量。</p></blockquote><h2 id="思路一-去掉重复元素"><a href="#思路一-去掉重复元素" class="headerlink" title="思路一 - 去掉重复元素"></a>思路一 - 去掉重复元素</h2><p>类似26题那样，先去掉重复元素，然后再统计峰和谷。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHillValley</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[j - <span class="hljs-number">1</span>]) &#123;<br>                nums[j] = nums[i];<br>                j++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; j - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>] &amp;&amp; nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>] &amp;&amp; nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// similar to 26</span><br></code></pre></td></tr></table></figure><h2 id="思路二-状态机"><a href="#思路二-状态机" class="headerlink" title="思路二 - 状态机"></a>思路二 - 状态机</h2><p>还是判断每两个相邻元素的大小关系，并用一个变量记录上一对元素比较的结果。如果当前两个元素的比较结果和上一个比较结果不同，则说明当前元素是峰或谷。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHillValley</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prestate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> nums[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (cur &gt; next) &#123;<br>                <span class="hljs-keyword">if</span> (prestate == <span class="hljs-number">1</span>) &#123;<br>                    res++;<br>                &#125;<br>                prestate = -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &lt; next) &#123;<br>                <span class="hljs-keyword">if</span> (prestate == -<span class="hljs-number">1</span>) &#123;<br>                    res++;<br>                &#125;<br>                prestate = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 815. Bus Routes</title>
    <link href="/posts/311891315.html"/>
    <url>/posts/311891315.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.</p><p>For example, if routes[0] &#x3D; [1, 5, 7], this means that the 0th bus travels in the sequence 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … forever.<br>You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.</p><p>Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.</p><p>Example 1:<br>Input: routes &#x3D; [[1,2,7],[3,6,7]], source &#x3D; 1, target &#x3D; 6<br>Output: 2<br>Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</p><p>Example 2:<br>Input: routes &#x3D; [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source &#x3D; 15, target &#x3D; 12<br>Output: -1</p><p>Constraints:<br>1 &lt;&#x3D; routes.length &lt;&#x3D; 500.<br>1 &lt;&#x3D; routes[i].length &lt;&#x3D; 105<br>All the values of routes[i] are unique.<br>sum(routes[i].length) &lt;&#x3D; 105<br>0 &lt;&#x3D; routes[i][j] &lt; 106<br>0 &lt;&#x3D; source, target &lt; 106</p><p>公交路线。</p><blockquote><p>给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。</p><p>例如，路线 routes[0] &#x3D; [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … 这样的车站路线行驶。<br>现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。</p><p>求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道 graph 的题，思路是用 BFS 做。既然是图论的题，那么首先还是要将数据转换成图的形式。这里的图是一个邻接表，用 hashmap 表示，key 是车站，value 是一个 list，list 里存的是经过这个车站的公交车列表。然后从 source 开始 BFS 遍历，直到找到 target。需要注意的是 BFS 的 queue 中存储的是没有被访问过的车站的 index。当我们从 queue 中弹出一个车站的时候，我们就可以找到经过这个车站的所有公交车，也就能找到所有公交车他们各自的路线了。在这些路线中，我们再把没有路线中没有被访问过的车站加入到 queue 中。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numBusesToDestination</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] routes, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (source == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> routes.length;<br>        <span class="hljs-comment">// 建立站点到公交车编号的映射</span><br>        <span class="hljs-comment">// 每个站点都经过哪些bus</span><br>        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> stop : routes[i]) &#123;<br>                <span class="hljs-keyword">if</span> (!map.containsKey(stop)) &#123;<br>                    map.put(stop, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                map.get(stop).add(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// bfs</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Set&lt;Integer&gt; visitedStops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] visitedBuses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        queue.offer(source);<br>        visitedStops.add(source);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">busCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            busCount++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curStop</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-comment">// 遍历当前站点可以搭乘的公交车</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bus : map.getOrDefault(curStop, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;())) &#123;<br>                    <span class="hljs-keyword">if</span> (visitedBuses[bus]) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    visitedBuses[bus] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nextStop : routes[bus]) &#123;<br>                        <span class="hljs-keyword">if</span> (nextStop == target) &#123;<br>                            <span class="hljs-keyword">return</span> busCount;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (visitedStops.contains(nextStop)) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        visitedStops.add(nextStop);<br>                        queue.offer(nextStop);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points</title>
    <link href="/posts/138440382.html"/>
    <url>/posts/138440382.html</url>
    
    <content type="html"><![CDATA[<p>A critical point in a linked list is defined as either a local maxima or a local minima.</p><p>A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.</p><p>A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.</p><p>Note that a node can only be a local maxima&#x2F;minima if there exists both a previous node and a next node.</p><p>Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/10/13/a1.png" alt="Example 1"><br>Input: head &#x3D; [3,1]<br>Output: [-1,-1]<br>Explanation: There are no critical points in [3,1].</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/10/13/a2.png" alt="Example 2"><br>Input: head &#x3D; [5,3,1,2,5,1,2]<br>Output: [1,3]<br>Explanation: There are three critical points:</p><ul><li>[5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.</li><li>[5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.</li><li>[5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.<br>The minimum distance is between the fifth and the sixth node. minDistance &#x3D; 6 - 5 &#x3D; 1.<br>The maximum distance is between the third and the sixth node. maxDistance &#x3D; 6 - 3 &#x3D; 3.</li></ul><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2021/10/14/a5.png" alt="Example 3"><br>Input: head &#x3D; [1,3,2,2,3,2,2,2,7]<br>Output: [3,3]<br>Explanation: There are two critical points:</p><ul><li>[1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.</li><li>[1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.<br>Both the minimum and maximum distances are between the second and the fifth node.<br>Thus, minDistance and maxDistance is 5 - 2 &#x3D; 3.<br>Note that the last node is not considered a local maxima because it does not have a next node.</li></ul><p>Constraints:<br>The number of nodes in the list is in the range [2, 105].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><p>找出临界点之间的最小和最大距离。</p><blockquote><p>链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。</p><p>如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个 局部极大值点 。</p><p>如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个 局部极小值点 。</p><p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 &#x2F; 极小值点 。</p><p>给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及算法，需要把题目意思读懂。题目给了一个链表，需要我们找出其中所有的临界点。临界点的定义是局部极大值点和局部极小值点。所以思路是遍历链表，找出所有的临界点，并记录他们在原链表中的位置。然后根据临界点的位置计算出最小和最大距离。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nodesBetweenCriticalPoints(ListNode head) &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> head.val;<br>        List&lt;Integer&gt; indexes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; prev &amp;&amp; cur.val &gt; cur.next.val || cur.val &lt; prev &amp;&amp; cur.val &lt; cur.next.val) &#123;<br>                indexes.add(index);<br>            &#125;<br>            prev = cur.val;<br>            cur = cur.next;<br>            index++;<br>        &#125;<br><br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (indexes.size() &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> indexes.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> indexes.get(n - <span class="hljs-number">1</span>) - indexes.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            min = Math.min(min, indexes.get(i) - indexes.get(i - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; min, max &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3201. Find the Maximum Length of Valid Subsequence I</title>
    <link href="/posts/2344491760.html"/>
    <url>/posts/2344491760.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums.<br>A subsequence sub of nums with length x is called valid if it satisfies:</p><p>(sub[0] + sub[1]) % 2 &#x3D;&#x3D; (sub[1] + sub[2]) % 2 &#x3D;&#x3D; … &#x3D;&#x3D; (sub[x - 2] + sub[x - 1]) % 2.<br>Return the length of the longest valid subsequence of nums.</p><p>A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,4]<br>Output: 4</p><p>Explanation:<br>The longest valid subsequence is [1, 2, 3, 4].</p><p>Example 2:<br>Input: nums &#x3D; [1,2,1,1,2,1,2]<br>Output: 6</p><p>Explanation:<br>The longest valid subsequence is [1, 2, 1, 2, 1, 2].</p><p>Example 3:<br>Input: nums &#x3D; [1,3]<br>Output: 2</p><p>Explanation:<br>The longest valid subsequence is [1, 3].</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 107</p><p>找出有效子序列的最大长度 I。</p><blockquote><p>给你一个整数数组 nums。</p><p>nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：</p><p>(sub[0] + sub[1]) % 2 &#x3D;&#x3D; (sub[1] + sub[2]) % 2 &#x3D;&#x3D; … &#x3D;&#x3D; (sub[x - 2] + sub[x - 1]) % 2<br>返回 nums 的 最长的有效子序列 的长度。</p><p>一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。虽然这道题要找的是最长的子序列，意味着可以对 input 数组排序，但是排序对题目起不到作用。</p><p>注意<code>有效子序列</code>的定义，两个数的和的奇偶性是相同的。也就是说，所有的奇数可以组成有效子序列，所有的偶数也可以组成有效子序列，同时所有奇偶相间的子数组也可以组成合法的子序列。那么我们可以找这三种情况的最大值即可。注意代码中最后为什么是 t + 1，因为最后一个元素也要算上。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                even++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                odd++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> != nums[i + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>) &#123;<br>                t++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            even++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            odd++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(t + <span class="hljs-number">1</span>, Math.max(even, odd));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3136. Valid Word</title>
    <link href="/posts/845341717.html"/>
    <url>/posts/845341717.html</url>
    
    <content type="html"><![CDATA[<p>A word is considered valid if:</p><p>It contains a minimum of 3 characters.<br>It contains only digits (0-9), and English letters (uppercase and lowercase).<br>It includes at least one vowel.<br>It includes at least one consonant.<br>You are given a string word.</p><p>Return true if word is valid, otherwise, return false.</p><p>Notes:<br>‘a’, ‘e’, ‘i’, ‘o’, ‘u’, and their uppercases are vowels.<br>A consonant is an English letter that is not a vowel.</p><p>Example 1:<br>Input: word &#x3D; “234Adas”<br>Output: true</p><p>Explanation:<br>This word satisfies the conditions.</p><p>Example 2:<br>Input: word &#x3D; “b3”<br>Output: false</p><p>Explanation:<br>The length of this word is fewer than 3, and does not have a vowel.</p><p>Example 3:<br>Input: word &#x3D; “a3$e”<br>Output: false</p><p>Explanation:<br>This word contains a ‘$’ character and does not have a consonant.</p><p>Constraints:<br>1 &lt;&#x3D; word.length &lt;&#x3D; 20<br>word consists of English uppercase and lowercase letters, digits, ‘@’, ‘#’, and ‘$’.</p><p>有效单词。</p><blockquote><p>有效单词 需要满足以下几个条件：</p><p>至少 包含 3 个字符。<br>由数字 0-9 和英文大小写字母组成。（不必包含所有这类字符。）<br>至少 包含一个 元音字母 。<br>至少 包含一个 辅音字母 。<br>给你一个字符串 word 。如果 word 是一个有效单词，则返回 true ，否则返回 false 。</p><p>注意：<br>‘a’、’e’、’i’、’o’、’u’ 及其大写形式都属于 元音字母 。<br>英文中的 辅音字母 是指那些除元音字母之外的字母。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及算法，按规则判断即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-keyword">if</span> (word.length() &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasVowel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasConsonant</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (Character.isLetterOrDigit(c)) &#123;<br>                <span class="hljs-keyword">if</span> (Character.isLetter(c)) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">lowerC</span> <span class="hljs-operator">=</span> Character.toLowerCase(c);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;aeiou&quot;</span>.indexOf(lowerC) &gt;= <span class="hljs-number">0</span>) &#123;<br>                        hasVowel = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        hasConsonant = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Invalid character (not a digit or letter)</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasVowel &amp;&amp; hasConsonant;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2410. Maximum Matching of Players With Trainers</title>
    <link href="/posts/2058579354.html"/>
    <url>/posts/2058579354.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array players, where players[i] represents the ability of the ith player. You are also given a 0-indexed integer array trainers, where trainers[j] represents the training capacity of the jth trainer.</p><p>The ith player can match with the jth trainer if the player’s ability is less than or equal to the trainer’s training capacity. Additionally, the ith player can be matched with at most one trainer, and the jth trainer can be matched with at most one player.</p><p>Return the maximum number of matchings between players and trainers that satisfy these conditions.</p><p>Example 1:<br>Input: players &#x3D; [4,7,9], trainers &#x3D; [8,2,5,8]<br>Output: 2<br>Explanation:<br>One of the ways we can form two matchings is as follows:</p><ul><li>players[0] can be matched with trainers[0] since 4 &lt;&#x3D; 8.</li><li>players[1] can be matched with trainers[3] since 7 &lt;&#x3D; 8.<br>It can be proven that 2 is the maximum number of matchings that can be formed.</li></ul><p>Example 2:<br>Input: players &#x3D; [1,1,1], trainers &#x3D; [10]<br>Output: 1<br>Explanation:<br>The trainer can be matched with any of the 3 players.<br>Each player can only be matched with one trainer, so the maximum answer is 1.</p><p>Constraints:<br>1 &lt;&#x3D; players.length, trainers.length &lt;&#x3D; 105<br>1 &lt;&#x3D; players[i], trainers[j] &lt;&#x3D; 109</p><p>Note: This question is the same as 445: Assign Cookies.</p><p>运动员和训练师的最大匹配数。</p><blockquote>给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。<p>如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。</p><p>请你返回满足上述要求 players 和 trainers 的 最大 匹配数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是排序 + 双指针。对 players 和 trainers 都进行排序，然后用两个指针分别指向 players 和 trainers 的开头。遍历 players，如果当前 player 能够匹配当前 trainer，就将匹配数加一，并将两个指针都向后移动；如果不能匹配，就只移动 trainer 的指针，直到找到一个可以匹配的 trainer 或者遍历完所有的 trainers。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">matchPlayersAndTrainers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] players, <span class="hljs-type">int</span>[] trainers)</span> &#123;<br>        Arrays.sort(players);<br>        Arrays.sort(trainers);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> players.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> trainers.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (players[i] &lt;= trainers[j]) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3330. Find the Original Typed String I</title>
    <link href="/posts/528034947.html"/>
    <url>/posts/528034947.html</url>
    
    <content type="html"><![CDATA[<p>Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and may press a key for too long, resulting in a character being typed multiple times.</p><p>Although Alice tried to focus on her typing, she is aware that she may still have done this at most once.</p><p>You are given a string word, which represents the final output displayed on Alice’s screen.</p><p>Return the total number of possible original strings that Alice might have intended to type.</p><p>Example 1:<br>Input: word &#x3D; “abbcccc”<br>Output: 5</p><p>Explanation:<br>The possible strings are: “abbcccc”, “abbccc”, “abbcc”, “abbc”, and “abcccc”.</p><p>Example 2:<br>Input: word &#x3D; “abcd”<br>Output: 1</p><p>Explanation:<br>The only possible string is “abcd”.</p><p>Example 3:<br>Input: word &#x3D; “aaaa”<br>Output: 4</p><p>Constraints:<br>1 &lt;&#x3D; word.length &lt;&#x3D; 100<br>word consists only of lowercase English letters.</p><p>找到初始输入字符串 I。</p><blockquote><p>Alice 正在她的电脑上输入一个字符串。但是她打字技术比较笨拙，她 可能 在一个按键上按太久，导致一个字符被输入 多次 。</p><p>尽管 Alice 尽可能集中注意力，她仍然可能会犯错 至多 一次。</p><p>给你一个字符串 word ，它表示 最终 显示在 Alice 显示屏上的结果。</p><p>请你返回 Alice 一开始可能想要输入字符串的总方案数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及算法，注意观察字符串的规律。如果相邻的字符相同，那么第二个字母就有可能是一次重复的输入。所以我们可以遍历 input 字符串，如果当前字母跟前一个字母不一样，则说明没有犯错；如果跟前一个字母一样，那么第二个字母就有可能是因为犯错而输入的，则计数加一。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">possibleStringCount</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (word.charAt(i) == word.charAt(i - <span class="hljs-number">1</span>)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2200. Find All K-Distant Indices in an Array</title>
    <link href="/posts/3512283209.html"/>
    <url>/posts/3512283209.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| &lt;&#x3D; k and nums[j] &#x3D;&#x3D; key.</p><p>Return a list of all k-distant indices sorted in increasing order.</p><p>Example 1:<br>Input: nums &#x3D; [3,4,9,1,3,9,5], key &#x3D; 9, k &#x3D; 1<br>Output: [1,2,3,4,5,6]<br>Explanation: Here, nums[2] &#x3D;&#x3D; key and nums[5] &#x3D;&#x3D; key.</p><ul><li>For index 0, |0 - 2| &gt; k and |0 - 5| &gt; k, so there is no j where |0 - j| &lt;&#x3D; k and nums[j] &#x3D;&#x3D; key. Thus, 0 is not a k-distant index.</li><li>For index 1, |1 - 2| &lt;&#x3D; k and nums[2] &#x3D;&#x3D; key, so 1 is a k-distant index.</li><li>For index 2, |2 - 2| &lt;&#x3D; k and nums[2] &#x3D;&#x3D; key, so 2 is a k-distant index.</li><li>For index 3, |3 - 2| &lt;&#x3D; k and nums[2] &#x3D;&#x3D; key, so 3 is a k-distant index.</li><li>For index 4, |4 - 5| &lt;&#x3D; k and nums[5] &#x3D;&#x3D; key, so 4 is a k-distant index.</li><li>For index 5, |5 - 5| &lt;&#x3D; k and nums[5] &#x3D;&#x3D; key, so 5 is a k-distant index.</li><li>For index 6, |6 - 5| &lt;&#x3D; k and nums[5] &#x3D;&#x3D; key, so 6 is a k-distant index.<br>Thus, we return [1,2,3,4,5,6] which is sorted in increasing order.</li></ul><p>Example 2:<br>Input: nums &#x3D; [2,2,2,2,2], key &#x3D; 2, k &#x3D; 2<br>Output: [0,1,2,3,4]<br>Explanation: For all indices i in nums, there exists some index j such that |i - j| &lt;&#x3D; k and nums[j] &#x3D;&#x3D; key, so every index is a k-distant index.<br>Hence, we return [0,1,2,3,4].</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>key is an integer from the array nums.<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><p>找出数组中的所有 K 近邻下标。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 和两个整数 key 和 k 。K 近邻下标 是 nums 中的一个下标 i ，并满足至少存在一个下标 j 使得 |i - j| &lt;&#x3D; k 且 nums[j] &#x3D;&#x3D; key 。</p><p>以列表形式返回按 递增顺序 排序的所有 K 近邻下标。</p></blockquote><h2 id="思路一-两层循环"><a href="#思路一-两层循环" class="headerlink" title="思路一 - 两层循环"></a>思路一 - 两层循环</h2><p>先用一个 list 把 input 数组里所有等于 key 的下标存起来，然后遍历这个 list，对于 list 里的每一个 index，将在 <code>[index - k, index + k]</code> 这个范围内的所有下标都加入一个 hashset 里。再把 hashset 转换成 list 并排序后返回。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n*k)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findKDistantIndices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] == key) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, j - k);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.min(n - <span class="hljs-number">1</span>, j + k);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>                    set.add(i);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(set);<br>        Collections.sort(res); <span class="hljs-comment">// 题目要求升序排列</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// O(n * k)</span><br></code></pre></td></tr></table></figure><h2 id="思路二-双指针，一层循环"><a href="#思路二-双指针，一层循环" class="headerlink" title="思路二 - 双指针，一层循环"></a>思路二 - 双指针，一层循环</h2><p>和思路一类似，还是需要一个 list 先把所有 key 的下标存储起来。接着我们用双指针的做法，一个指针 i 指向 input 数组，另一个指针 j 指向 list。具体参见代码。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m + n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findKDistantIndices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Integer&gt; indexes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num == key) &#123;<br>                indexes.add(i);<br>            &#125;<br>        &#125;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (p &lt; indexes.size() &amp;&amp; indexes.get(p) &lt; i - k) &#123;<br>                p++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p &lt; indexes.size() &amp;&amp; Math.abs(i - indexes.get(p)) &lt;= k) &#123;<br>                res.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// O(m+n)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2138. Divide a String Into Groups of Size k</title>
    <link href="/posts/3233707564.html"/>
    <url>/posts/3233707564.html</url>
    
    <content type="html"><![CDATA[<p>A string s can be partitioned into groups of size k using the following procedure:</p><p>The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each element can be a part of exactly one group.<br>For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.<br>Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.</p><p>Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.</p><p>Example 1:<br>Input: s &#x3D; “abcdefghi”, k &#x3D; 3, fill &#x3D; “x”<br>Output: [“abc”,”def”,”ghi”]<br>Explanation:<br>The first 3 characters “abc” form the first group.<br>The next 3 characters “def” form the second group.<br>The last 3 characters “ghi” form the third group.<br>Since all groups can be completely filled by characters from the string, we do not need to use fill.<br>Thus, the groups formed are “abc”, “def”, and “ghi”.</p><p>Example 2:<br>Input: s &#x3D; “abcdefghij”, k &#x3D; 3, fill &#x3D; “x”<br>Output: [“abc”,”def”,”ghi”,”jxx”]<br>Explanation:<br>Similar to the previous example, we are forming the first three groups “abc”, “def”, and “ghi”.<br>For the last group, we can only use the character ‘j’ from the string. To complete this group, we add ‘x’ twice.<br>Thus, the 4 groups formed are “abc”, “def”, “ghi”, and “jxx”.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s consists of lowercase English letters only.<br>1 &lt;&#x3D; k &lt;&#x3D; 100<br>fill is a lowercase English letter.</p><p>将字符串拆分为若干长度为 k 的组.</p><blockquote><p>字符串 s 可以按下述步骤划分为若干长度为 k 的组：</p><p>第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。<br>对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。<br>注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</p><p>给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就是模拟。将字符串分成若干个长度为 k 的组，最后一组如果不足 k 个字符，则用 fill 填充。可以使用 StringBuilder 来构建每个组。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="Java实现一"><a href="#Java实现一" class="headerlink" title="Java实现一"></a>Java实现一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] divideString(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">char</span> fill) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">groups</span> <span class="hljs-operator">=</span> (n + k - <span class="hljs-number">1</span>) / k; <span class="hljs-comment">// Calculate the number of groups needed</span><br>        String[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[groups];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; groups; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i * k;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> Math.min(start + k, n);<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s.substring(start, end));<br>            <span class="hljs-comment">// If the group is not full, fill it with the fill character</span><br>            <span class="hljs-keyword">while</span> (sb.length() &lt; k) &#123;<br>                sb.append(fill);<br>            &#125;<br>            res[i] = sb.toString();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java实现二"><a href="#Java实现二" class="headerlink" title="Java实现二"></a>Java实现二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] divideString(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">char</span> fill) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(i, Math.min(i + k, s.length()));<br>            <span class="hljs-keyword">if</span> (str.length() == k) &#123;<br>                list.add(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> k - str.length();<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str.toCharArray()) &#123;<br>                    sb.append(c);<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; diff; j++) &#123;<br>                    sb.append(fill);<br>                &#125;<br>                list.add(sb.toString());<br>            &#125;<br>            i += k;<br>        &#125;<br>        <br>        String[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[list.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; list.size(); j++) &#123;<br>            res[j] = list.get(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2294. Partition Array Such That Maximum Difference Is K</title>
    <link href="/posts/3847178217.html"/>
    <url>/posts/3847178217.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and an integer k. You may partition nums into one or more subsequences such that each element in nums appears in exactly one of the subsequences.</p><p>Return the minimum number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is at most k.</p><p>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p><p>Example 1:<br>Input: nums &#x3D; [3,6,1,2,5], k &#x3D; 2<br>Output: 2<br>Explanation:<br>We can partition nums into the two subsequences [3,1,2] and [6,5].<br>The difference between the maximum and minimum value in the first subsequence is 3 - 1 &#x3D; 2.<br>The difference between the maximum and minimum value in the second subsequence is 6 - 5 &#x3D; 1.<br>Since two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.</p><p>Example 2:<br>Input: nums &#x3D; [1,2,3], k &#x3D; 1<br>Output: 2<br>Explanation:<br>We can partition nums into the two subsequences [1,2] and [3].<br>The difference between the maximum and minimum value in the first subsequence is 2 - 1 &#x3D; 1.<br>The difference between the maximum and minimum value in the second subsequence is 3 - 3 &#x3D; 0.<br>Since two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].</p><p>Example 3:<br>Input: nums &#x3D; [2,2,4,5], k &#x3D; 0<br>Output: 3<br>Explanation:<br>We can partition nums into the three subsequences [2,2], [4], and [5].<br>The difference between the maximum and minimum value in the first subsequences is 2 - 2 &#x3D; 0.<br>The difference between the maximum and minimum value in the second subsequences is 4 - 4 &#x3D; 0.<br>The difference between the maximum and minimum value in the third subsequences is 5 - 5 &#x3D; 0.<br>Since three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; k &lt;&#x3D; 105</p><p>划分数组使最大差为 K。</p><blockquote><p>给你一个整数数组 nums 和一个整数 k 。你可以将 nums 划分成一个或多个 子序列 ，使 nums 中的每个元素都 恰好 出现在一个子序列中。</p><p>在满足每个子序列中最大值和最小值之间的差值最多为 k 的前提下，返回需要划分的 最少 子序列数目。</p><p>子序列 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。题目要求我们把 input 数组划分成多个子序列，而且注意例子，我们发现子序列是无序的。所以这里我们可以选择排序。排序过后，对于每个合法的子序列，我们是哦先可以得到子序列中最小的元素 min，然后遍历后面的数字，如果当前数字 num - min &gt; k，则说明当前数字 num 不能和 min 在同一个子序列中，所以我们需要新开一个子序列。否则就可以和 min 在同一个子序列中。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num - min &gt; k) &#123;<br>                count++;<br>                min = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2566. Maximum Difference by Remapping a Digit</title>
    <link href="/posts/622540580.html"/>
    <url>/posts/622540580.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer num. You know that Bob will sneakily remap one of the 10 possible digits (0 to 9) to another digit.</p><p>Return the difference between the maximum and minimum values Bob can make by remapping exactly one digit in num.</p><p>Notes:<br>When Bob remaps a digit d1 to another digit d2, Bob replaces all occurrences of d1 in num with d2.<br>Bob can remap a digit to itself, in which case num does not change.<br>Bob can remap different digits for obtaining minimum and maximum values respectively.<br>The resulting number after remapping can contain leading zeroes.</p><p>Example 1:<br>Input: num &#x3D; 11891<br>Output: 99009<br>Explanation:<br>To achieve the maximum value, Bob can remap the digit 1 to the digit 9 to yield 99899.<br>To achieve the minimum value, Bob can remap the digit 1 to the digit 0, yielding 890.<br>The difference between these two numbers is 99009.</p><p>Example 2:<br>Input: num &#x3D; 90<br>Output: 99<br>Explanation:<br>The maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).<br>Thus, we return 99.</p><p>Constraints:<br>1 &lt;&#x3D; num &lt;&#x3D; 108</p><p>替换一个数字后的最大差值。</p><blockquote><p>给你一个整数 num 。你知道 Danny Mittal 会偷偷将 0 到 9 中的一个数字 替换 成另一个数字。</p><p>请你返回将 num 中 恰好一个 数字进行替换后，得到的最大值和最小值的差为多少。</p><p>注意：</p><p>当 Danny 将一个数字 d1 替换成另一个数字 d2 时，Danny 需要将 nums 中所有 d1 都替换成 d2 。<br>Danny 可以将一个数字替换成它自己，也就是说 num 可以不变。<br>Danny 可以将数字分别替换成两个不同的数字分别得到最大值和最小值。<br>替换后得到的数字可以包含前导 0 。<br>Danny Mittal 获得周赛 326 前 10 名，让我们恭喜他。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道字符串的实现题。给的 input 是一个字符串，表示一个数字，需要把他变成一个最大的数和一个最小的数，然后求两者的差值。首先我们思考最大的数是什么？是最高位尽量为 9，如果第一位已经为 9，那么就找到第一个不为 9 的digit，假如为 X，把所有的 X 都替换成 9。</p><p>又因为给的数字一定没有前导 0，如果最高位出现的数字为 Y，我们把所有的 Y 都替换为 0 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 遍历字符串一次<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMaxDifference</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                max = Integer.parseInt(str.replace(c, <span class="hljs-string">&#x27;9&#x27;</span>));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.parseInt(str.replace(str.charAt(<span class="hljs-number">0</span>), <span class="hljs-string">&#x27;0&#x27;</span>));<br>        <span class="hljs-keyword">return</span> max - min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 386. Lexicographical Numbers</title>
    <link href="/posts/1026628144.html"/>
    <url>/posts/1026628144.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.</p><p>You must write an algorithm that runs in O(n) time and uses O(1) extra space.</p><p>Example 1:<br>Input: n &#x3D; 13<br>Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]</p><p>Example 2:<br>Input: n &#x3D; 2<br>Output: [1,2]</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104</p><p>字典序排数。</p><blockquote><p>给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。</p><p>你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 DFS。注意题目要求，是要我们按字典序输出 [1, n] 内所有整数。那么思路就是从 1 到 9，把这九个数字作为第一个 digit，往后面加一个digit，如果不超过 n，就加入结果集。如果超过 n 就不能加。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1) - required</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="Java实现，空间O-n"><a href="#Java实现，空间O-n" class="headerlink" title="Java实现，空间O(n)"></a>Java实现，空间O(n)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">lexicalOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            dfs(i, n, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> n, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur &gt; n) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.add(cur);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur * <span class="hljs-number">10</span> + i;<br>            <span class="hljs-keyword">if</span> (next &gt; n) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dfs(next, n, res);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// dfs</span><br></code></pre></td></tr></table></figure><h2 id="Java实现，空间O-1"><a href="#Java实现，空间O-1" class="headerlink" title="Java实现，空间O(1)"></a>Java实现，空间O(1)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">lexicalOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res.add(cur);<br>            <span class="hljs-keyword">if</span> (cur * <span class="hljs-number">10</span> &lt;= n) &#123;<br>                cur *= <span class="hljs-number">10</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (cur % <span class="hljs-number">10</span> == <span class="hljs-number">9</span> || cur + <span class="hljs-number">1</span> &gt; n) &#123;<br>                    cur /= <span class="hljs-number">10</span>;<br>                &#125;<br>                cur++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2434. Using a Robot to Print the Lexicographically Smallest String</title>
    <link href="/posts/1478144800.html"/>
    <url>/posts/1478144800.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s and a robot that currently holds an empty string t. Apply one of the following operations until s and t are both empty:</p><p>Remove the first character of a string s and give it to the robot. The robot will append this character to the string t.</p><p>Remove the last character of a string t and give it to the robot. The robot will write this character on paper.</p><p>Return the lexicographically smallest string that can be written on the paper.</p><p>Example 1:<br>Input: s &#x3D; “zza”<br>Output: “azz”<br>Explanation: Let p denote the written string.<br>Initially p&#x3D;””, s&#x3D;”zza”, t&#x3D;””.<br>Perform first operation three times p&#x3D;””, s&#x3D;””, t&#x3D;”zza”.<br>Perform second operation three times p&#x3D;”azz”, s&#x3D;””, t&#x3D;””.</p><p>Example 2:<br>Input: s &#x3D; “bac”<br>Output: “abc”<br>Explanation: Let p denote the written string.<br>Perform first operation twice p&#x3D;””, s&#x3D;”c”, t&#x3D;”ba”.<br>Perform second operation twice p&#x3D;”ab”, s&#x3D;”c”, t&#x3D;””.<br>Perform first operation p&#x3D;”ab”, s&#x3D;””, t&#x3D;”c”.<br>Perform second operation p&#x3D;”abc”, s&#x3D;””, t&#x3D;””.</p><p>Example 3:<br>Input: s &#x3D; “bdda”<br>Output: “addb”<br>Explanation: Let p denote the written string.<br>Initially p&#x3D;””, s&#x3D;”bdda”, t&#x3D;””.<br>Perform first operation four times p&#x3D;””, s&#x3D;””, t&#x3D;”bdda”.<br>Perform second operation four times p&#x3D;”addb”, s&#x3D;””, t&#x3D;””.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of only English lowercase letters.</p><p>使用机器人打印字典序最小的字符串。</p><blockquote><p>给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t 。执行以下操作之一，直到 s 和 t 都变成空字符串：</p><ul><li>删除字符串 s 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。</li><li>删除字符串 t 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。</li></ul><p>请你返回纸上能写出的字典序最小的字符串。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心，需要用到 <code>stack</code>。</p><p>注意题目的操作规则，从 s 中删除字母只能从左开始，字母加给 t，从 t 中删除字母只能从右开始写到纸上。对于 t 的字母来说，是先进后出。那么比较容易想到用 stack，从 s 中每删除一个字母，就往 stack 里放。</p><p>这里我们需要创建一个和 input 字符串等长的数组，记为 <code>minCharFrom</code>，记录一下每个字母的右边是否存在一个比它小的字母。这样在往 stack 里放字母时，就可以判断当前字母是否可以放入 stack 中。</p><p>开始遍历 input 字符串，对于每一个字母 cur ，如果他的右边没有比他更小的字母了，则把他们从 stack 中弹出，加到结果字符串中。最后如果 stack 中还有剩余字母，也把它们加到结果字符串中。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">robotWithString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 预处理：从后往前记录每个位置起始的最小字符</span><br>        <span class="hljs-type">char</span>[] minCharFrom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>        minCharFrom[n - <span class="hljs-number">1</span>] = s.charAt(n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            minCharFrom[i] = (<span class="hljs-type">char</span>) Math.min(s.charAt(i), minCharFrom[i + <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            stack.push(s.charAt(i));<br>            <span class="hljs-comment">// 把栈中尽可能小的字符都弹出</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= minCharFrom[i == n - <span class="hljs-number">1</span> ? i : i + <span class="hljs-number">1</span>]) &#123;<br>                sb.append(stack.pop());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 栈中剩余的字符也弹出</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            sb.append(stack.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3403. Find the Lexicographically Largest String From the Box I</title>
    <link href="/posts/2250604039.html"/>
    <url>/posts/2250604039.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string word, and an integer numFriends.</p><p>Alice is organizing a game for her numFriends friends. There are multiple rounds in the game, where in each round:</p><p>word is split into numFriends non-empty strings, such that no previous round has had the exact same split.<br>All the split words are put into a box.<br>Find the lexicographically largest string from the box after all the rounds are finished.</p><p>Example 1:<br>Input: word &#x3D; “dbca”, numFriends &#x3D; 2<br>Output: “dbc”</p><p>Explanation:<br>All possible splits are:<br>“d” and “bca”.<br>“db” and “ca”.<br>“dbc” and “a”.</p><p>Example 2:<br>Input: word &#x3D; “gggg”, numFriends &#x3D; 4<br>Output: “g”</p><p>Explanation:<br>The only possible split is: “g”, “g”, “g”, and “g”.</p><p>Constraints:<br>1 &lt;&#x3D; word.length &lt;&#x3D; 5 * 103<br>word consists only of lowercase English letters.<br>1 &lt;&#x3D; numFriends &lt;&#x3D; word.length</p><p>从盒子中找出字典序最大的字符串 I。</p><blockquote>给你一个字符串 word 和一个整数 numFriends。<p>Alice 正在为她的 numFriends 位朋友组织一个游戏。游戏分为多个回合，在每一回合中：</p><p>word 被分割成 numFriends 个 非空 字符串，且该分割方式与之前的任意回合所采用的都 不完全相同 。</p><p>所有分割出的字符串都会被放入一个盒子中。</p><p>在所有回合结束后，找出盒子中 字典序最大的 字符串。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及算法，就是比较字符串的字典序大小。既然是找字典序最大的字符串，那么肯定是越长越好。但是这个字符串的长度也是有一个上限的，因为需要确保剩下的字符串的长度足够再分给 <code>numFriends - 1</code> 个朋友。</p><p>所以具体的做法是，我们从 0 开始遍历 input 字符串，对于每个位置 <code>i</code>，我们尝试找到一个子串 [i, i + k)，这个子串的长度需要满足</p><ul><li>i + k &lt;&#x3D; word.length, 意思是子串不能越界</li><li>word.length - (i + k) &gt;&#x3D; numFriends - 1, 意思是剩下的字符串长度足够分给其他朋友</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">answerString</span><span class="hljs-params">(String word, <span class="hljs-type">int</span> numFriends)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (numFriends == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> word;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.min(n - i, n - numFriends + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> word.substring(i, i + k);<br>            <span class="hljs-keyword">if</span> (cur.compareTo(res) &gt; <span class="hljs-number">0</span>) &#123;<br>                res = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3024. Type of Triangle</title>
    <link href="/posts/4285721359.html"/>
    <url>/posts/4285721359.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle.</p><p>A triangle is called equilateral if it has all sides of equal length.<br>A triangle is called isosceles if it has exactly two sides of equal length.<br>A triangle is called scalene if all its sides are of different lengths.<br>Return a string representing the type of triangle that can be formed or “none” if it cannot form a triangle.</p><p>Example 1:<br>Input: nums &#x3D; [3,3,3]<br>Output: “equilateral”<br>Explanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.</p><p>Example 2:<br>Input: nums &#x3D; [3,4,5]<br>Output: “scalene”<br>Explanation:<br>nums[0] + nums[1] &#x3D; 3 + 4 &#x3D; 7, which is greater than nums[2] &#x3D; 5.<br>nums[0] + nums[2] &#x3D; 3 + 5 &#x3D; 8, which is greater than nums[1] &#x3D; 4.<br>nums[1] + nums[2] &#x3D; 4 + 5 &#x3D; 9, which is greater than nums[0] &#x3D; 3.<br>Since the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.<br>As all the sides are of different lengths, it will form a scalene triangle.</p><p>Constraints:<br>nums.length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><p>三角形类型。</p><blockquote><p>给你一个下标从 0 开始长度为 3 的整数数组 nums ，需要用它们来构造三角形。</p><p>如果一个三角形的所有边长度相等，那么这个三角形称为 equilateral 。<br>如果一个三角形恰好有两条边长度相等，那么这个三角形称为 isosceles 。<br>如果一个三角形三条边的长度互不相同，那么这个三角形称为 scalene 。</p><p>如果这个数组无法构成一个三角形，请你返回字符串 “none” ，否则返回一个字符串表示这个三角形的类型。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先做排序，对 nums 进行升序排序，保证 nums[0] ≤ nums[1] ≤ nums[2]，这样只需检查一次三角不等式。</p><p>关于三角不等式：判断 nums[0] + nums[1] &gt; nums[2]。若不满足，则无效三角，返回 “none”。</p><p>分类：</p><ul><li>全等边：若 nums[0] &#x3D;&#x3D; nums[1] &amp;&amp; nums[1] &#x3D;&#x3D; nums[2]，返回 “equilateral”。</li><li>等腰三角：若 nums[0] &#x3D;&#x3D; nums[1] || nums[1] &#x3D;&#x3D; nums[2]，返回 “isosceles”。</li><li>其他情况，返回 “scalene”</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据三条边的长度分类三角形类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 长度为 3 的边长数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &quot;equilateral&quot;、&quot;isosceles&quot;、&quot;scalene&quot; 或 &quot;none&quot;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">triangleType</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 1. 排序</span><br>        Arrays.sort(nums);<br><br>        <span class="hljs-comment">// 2. 检查三角不等式</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] &lt;= nums[<span class="hljs-number">2</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;none&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 分类</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">2</span>]) &#123;<br>            <span class="hljs-comment">// 三条边相等</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;equilateral&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>] || nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>]) &#123;<br>            <span class="hljs-comment">// 任意两条边相等</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;isosceles&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 三条边皆不相等</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;scalene&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2874. Maximum Value of an Ordered Triplet II</title>
    <link href="/posts/2040191415.html"/>
    <url>/posts/2040191415.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums.</p><p>Return the maximum value over all triplets of indices (i, j, k) such that i &lt; j &lt; k. If all such triplets have a negative value, return 0.</p><p>The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].</p><p>Example 1:<br>Input: nums &#x3D; [12,6,1,2,7]<br>Output: 77<br>Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] &#x3D; 77.<br>It can be shown that there are no ordered triplets of indices with a value greater than 77.</p><p>Example 2:<br>Input: nums &#x3D; [1,10,3,4,19]<br>Output: 133<br>Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] &#x3D; 133.<br>It can be shown that there are no ordered triplets of indices with a value greater than 133.</p><p>Example 3:<br>Input: nums &#x3D; [1,2,3]<br>Output: 0<br>Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] &#x3D; -3. Hence, the answer would be 0.</p><p>Constraints:<br>3 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 106</p><p>有序三元组中的最大值 II。</p><blockquote>给你一个下标从 0 开始的整数数组 nums 。<p>请你从所有满足 i &lt; j &lt; k 的下标三元组 (i, j, k) 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 0 。</p><p>下标三元组 (i, j, k) 的值等于 (nums[i] - nums[j]) * nums[k] 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意题目要求我们找的是一个<code>有序</code>的三元组，满足 i &lt; j &lt; k。那就意味着我们不能对 input 数组排序。</p><p>不能排序的话，乍一看这个题是需要三个 for 循环，但是我们可以通过维护两边的最大值，然后枚举中间的值，这样就可以在 <code>O(n)</code> 的时间复杂度内解决这个问题。而且因为计算的公式是<code>(nums[i] - nums[j]) * nums[k]</code>，所以我们可以以 j 为基准，找最大的 nums[i] 和 nums[k]。</p><p>所以具体做法是，创建两个和 input 数组等长的数组，记录对于每个 index 上的元素，它<code>左侧</code>和<code>右侧</code>最大的元素。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTripletValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            preMax[i] = max;<br>            max = Math.max(max, nums[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] sufMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            sufMax[i] = max;<br>            max = Math.max(max, nums[i]);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> * (preMax[j] - nums[j]) * sufMax[j];<br>            res = Math.max(res, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">2873. Maximum Value of an Ordered Triplet I<br>2874. Maximum Value of an Ordered Triplet II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2780. Minimum Index of a Valid Split</title>
    <link href="/posts/2582969194.html"/>
    <url>/posts/2582969194.html</url>
    
    <content type="html"><![CDATA[<p>An element x of an integer array arr of length m is dominant if more than half the elements of arr have a value of x.</p><p>You are given a 0-indexed integer array nums of length n with one dominant element.</p><p>You can split nums at an index i into two arrays nums[0, …, i] and nums[i + 1, …, n - 1], but the split is only valid if:<br>0 &lt;&#x3D; i &lt; n - 1</p><p>nums[0, …, i], and nums[i + 1, …, n - 1] have the same dominant element.<br>Here, nums[i, …, j] denotes the subarray of nums starting at index i and ending at index j, both ends being inclusive. Particularly, if j &lt; i then nums[i, …, j] denotes an empty subarray.</p><p>Return the minimum index of a valid split. If no valid split exists, return -1.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,2,2]<br>Output: 2<br>Explanation: We can split the array at index 2 to obtain arrays [1,2,2] and [2].<br>In array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 &gt; 3.<br>In array [2], element 2 is dominant since it occurs once in the array and 1 * 2 &gt; 1.<br>Both [1,2,2] and [2] have the same dominant element as nums, so this is a valid split.<br>It can be shown that index 2 is the minimum index of a valid split.</p><p>Example 2:<br>Input: nums &#x3D; [2,1,3,1,1,1,7,1,2,1]<br>Output: 4<br>Explanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].<br>In array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 &gt; 5.<br>In array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 &gt; 5.<br>Both [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.<br>It can be shown that index 4 is the minimum index of a valid split.</p><p>Example 3:<br>Input: nums &#x3D; [3,3,3,3,7,2,2]<br>Output: -1<br>Explanation: It can be shown that there is no valid split.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums has exactly one dominant element.</p><p>合法分割的最小下标。</p><blockquote><p>如果在长度为 m 的整数数组 arr 中 超过一半 的元素值为 x，那么我们称 x 是 支配元素 。</p><p>给你一个下标从 0 开始长度为 n 的整数数组 nums ，数据保证它含有一个 支配 元素。</p><p>你需要在下标 i 处将 nums 分割成两个数组 nums[0, …, i] 和 nums[i + 1, …, n - 1] ，如果一个分割满足以下条件，我们称它是 合法 的：</p><ul><li>0 &lt;&#x3D; i &lt; n - 1</li><li>nums[0, …, i] 和 nums[i + 1, …, n - 1] 的支配元素相同。<br>这里， nums[i, …, j] 表示 nums 的一个子数组，它开始于下标 i ，结束于下标 j ，两个端点都包含在子数组内。特别地，如果 j &lt; i ，那么 nums[i, …, j] 表示一个空数组。</li></ul><p>请你返回一个 合法分割 的 最小 下标。如果合法分割不存在，返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历两遍数组。第一遍扫描的时候用投票法找到 input 数组里的众数，记为 <code>candidate</code>。第二遍扫描的时候，根据当前的下标 i 分别计算 i 左侧和右侧的众数是不是依然是<code>candidate</code>，如果是，那么这个下标 i 就是一个合法的分割点。找到第一个分割点即可返回了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumIndex</span><span class="hljs-params">(List&lt;Integer&gt; nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> nums.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br><br>        <span class="hljs-comment">// 使用 Boyer-Moore 投票法找到可能的众数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums.get(i) == candidate) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = nums.get(i);<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算 candidate 在整个 nums 数组中出现的真实次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == candidate) &#123;<br>                totalCount++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 再次遍历数组，寻找符合条件的最小索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums.get(i) == candidate) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> totalCount - left; <span class="hljs-comment">// 右侧 candidate 的个数</span><br>            <span class="hljs-keyword">if</span> ((left * <span class="hljs-number">2</span> &gt; i + <span class="hljs-number">1</span>) &amp;&amp; (right * <span class="hljs-number">2</span> &gt; n - i - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">169. Majority Element<br>229. Majority Element II<br>2780. Minimum Index of a Valid Split<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2033. Minimum Operations to Make a Uni-Value Grid</title>
    <link href="/posts/1353802250.html"/>
    <url>/posts/1353802250.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.</p><p>A uni-value grid is a grid where all the elements of it are equal.</p><p>Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.</p><p>Example 1:<br>Input: grid &#x3D; [[2,4],[6,8]], x &#x3D; 2<br>Output: 4<br>Explanation: We can make every element equal to 4 by doing the following:</p><ul><li>Add x to 2 once.</li><li>Subtract x from 6 once.</li><li>Subtract x from 8 twice.<br>A total of 4 operations were used.</li></ul><p>Example 2:<br>Input: grid &#x3D; [[1,5],[2,3]], x &#x3D; 1<br>Output: 5<br>Explanation: We can make every element equal to 3.</p><p>Example 3:<br>Input: grid &#x3D; [[1,2],[3,4]], x &#x3D; 2<br>Output: -1<br>Explanation: It is impossible to make every element equal.</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>1 &lt;&#x3D; m * n &lt;&#x3D; 105<br>1 &lt;&#x3D; x, grid[i][j] &lt;&#x3D; 104</p><p>获取单值网格的最小操作数。</p><blockquote>给你一个大小为 m x n 的二维整数网格 grid 和一个整数 x 。每一次操作，你可以对 grid 中的任一元素 加 x 或 减 x 。<p>一个 单值网格 是全部元素都相等的网格。</p><p>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是先排序，然后用中位数比较。</p><p>具体实现是，把所有数字从 grid 里拿出来，放在一个一维数组里。然后把这个一维数组排序。然后遍历这个一维数组，把数组中每个数字<code>arr[i]</code>与数组的中位数<code>mid</code>比较。如果两者之间的差不能被 x 整除，那么返回 -1。否则，把两者之间的差除以 x 加到结果上。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m * n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                arr[index++] = grid[i][j];<br>            &#125;<br>        &#125;<br>        Arrays.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> arr[len / <span class="hljs-number">2</span>];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> Math.abs(mid - arr[i]);<br>            <span class="hljs-keyword">if</span> (dis % x != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            count += dis / x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>math</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2712. Minimum Cost to Make All Characters Equal</title>
    <link href="/posts/1386992953.html"/>
    <url>/posts/1386992953.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed binary string s of length n on which you can apply two types of operations:</p><p>Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1<br>Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i<br>Return the minimum cost to make all characters of the string equal.</p><p>Invert a character means if its value is ‘0’ it becomes ‘1’ and vice-versa.</p><p>Example 1:<br>Input: s &#x3D; “0011”<br>Output: 2<br>Explanation: Apply the second operation with i &#x3D; 2 to obtain s &#x3D; “0000” for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal.</p><p>Example 2:<br>Input: s &#x3D; “010101”<br>Output: 9<br>Explanation: Apply the first operation with i &#x3D; 2 to obtain s &#x3D; “101101” for a cost of 3.<br>Apply the first operation with i &#x3D; 1 to obtain s &#x3D; “011101” for a cost of 2.<br>Apply the first operation with i &#x3D; 0 to obtain s &#x3D; “111101” for a cost of 1.<br>Apply the second operation with i &#x3D; 4 to obtain s &#x3D; “111110” for a cost of 2.<br>Apply the second operation with i &#x3D; 5 to obtain s &#x3D; “111111” for a cost of 1.<br>The total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &#x3D;&#x3D; n &lt;&#x3D; 105<br>s[i] is either ‘0’ or ‘1’</p><p>使所有字符相等的最小成本。</p><blockquote><p>给你一个下标从 0 开始、长度为 n 的二进制字符串 s ，你可以对其执行两种操作：</p><p>选中一个下标 i 并且反转从下标 0 到下标 i（包括下标 0 和下标 i ）的所有字符，成本为 i + 1 。<br>选中一个下标 i 并且反转从下标 i 到下标 n - 1（包括下标 i 和下标 n - 1 ）的所有字符，成本为 n - i 。<br>返回使字符串内所有字符 相等 需要的 最小成本 。</p><p>反转 字符意味着：如果原来的值是 ‘0’ ，则反转后值变为 ‘1’ ，反之亦然。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。题目定义了在下标 i 处反转的成本是 i + 1 或 n - i。如果在某个下标 i 处我们发现他与前一个位置 i - 1 处的字符不一样，那么我们一定要做一次翻转操作。翻转的成本是翻转<code>从下标 0 到下标 i</code>与<code>从下标 i 到下标 n - 1</code>的最小值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - char array</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumCost</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] letters = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (letters[i] != letters[i - <span class="hljs-number">1</span>]) &#123;<br>                res += Math.min(i, n - i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3191. Minimum Operations to Make Binary Array Elements Equal to One I</title>
    <link href="/posts/142150626.html"/>
    <url>/posts/142150626.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary array nums.</p><p>You can do the following operation on the array any number of times (possibly zero):</p><p>Choose any 3 consecutive elements from the array and flip all of them.<br>Flipping an element means changing its value from 0 to 1, and from 1 to 0.</p><p>Return the minimum number of operations required to make all elements in nums equal to 1. If it is impossible, return -1.</p><p>Example 1:<br>Input: nums &#x3D; [0,1,1,1,0,0]<br>Output: 3</p><p>Explanation:<br>We can do the following operations:<br>Choose the elements at indices 0, 1 and 2. The resulting array is nums &#x3D; [1,0,0,1,0,0].<br>Choose the elements at indices 1, 2 and 3. The resulting array is nums &#x3D; [1,1,1,0,0,0].<br>Choose the elements at indices 3, 4 and 5. The resulting array is nums &#x3D; [1,1,1,1,1,1].</p><p>Example 2:<br>Input: nums &#x3D; [0,1,1,1]<br>Output: -1</p><p>Explanation:<br>It is impossible to make all elements equal to 1.</p><p>Constraints:<br>3 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1</p><p>使二进制数组全部等于 1 的最少操作次数 I。</p><blockquote><p>给你一个二进制数组 nums 。</p><p>你可以对数组执行以下操作 任意 次（也可以 0 次）：</p><p>选择数组中 任意连续 3 个元素，并将它们 全部反转 。<br>反转 一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。</p><p>请你返回将 nums 中所有元素变为 1 的 最少 操作次数。如果无法全部变成 1 ，返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。题目要求我们要把 input 数组里所有的 0 变成 1，一次只能变 3 个，同时操作的次数要最小。如果某个数字是 0，我们一定要对他操作一次或者操作单数次，因为如果操作偶数次的话只会是把 0 变成 1，然后又变回 0，这样做是没有意义的。</p><p>所以我们可以遍历数组，如果当前位置上的数字是 0，我们就对他操作一次，然后再对后面两个数字操作一次，这样就可以把当前位置上 0 变成 1 了。遍历是从 index &#x3D; 0 到 index &#x3D; n - 2。如果最后两个位置上的数字有 0，则说明无法将所有数字都翻转成 1，返回 -1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>                nums[i + <span class="hljs-number">1</span>] ^= <span class="hljs-number">1</span>;<br>                nums[i + <span class="hljs-number">2</span>] ^= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> || nums[n - <span class="hljs-number">2</span>] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2610. Convert an Array Into a 2D Array With Conditions</title>
    <link href="/posts/566673497.html"/>
    <url>/posts/566673497.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:</p><p>The 2D array should contain only the elements of the array nums.<br>Each row in the 2D array contains distinct integers.<br>The number of rows in the 2D array should be minimal.<br>Return the resulting array. If there are multiple answers, return any of them.</p><p>Note that the 2D array can have a different number of elements on each row.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,4,1,2,3,1]<br>Output: [[1,3,4,2],[1,3],[1]]<br>Explanation: We can create a 2D array that contains the following rows:</p><ul><li>1,3,4,2</li><li>1,3</li><li>1<br>All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.<br>It can be shown that we cannot have less than 3 rows in a valid array.</li></ul><p>Example 2:<br>Input: nums &#x3D; [1,2,3,4]<br>Output: [[4,3,2,1]]<br>Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums.length</p><p>转换二维数组。</p><blockquote><p>给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组：</p><p>二维数组应该 只 包含数组 nums 中的元素。<br>二维数组中的每一行都包含 不同 的整数。<br>二维数组的行数应尽可能 少 。<br>返回结果数组。如果存在多种答案，则返回其中任何一种。</p><p>请注意，二维数组的每一行上可以存在不同数量的元素。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历 input 数组，用一个 hashmap 存每个不同数字的出现次数，同时用一个变量 row 记录最多的出现次数。这个 row 即为最终的二维数组的行数。</p><p>遍历 hashmap 里的每个元素，将出现次数为 i 的数字放到第 i 行，最后返回结果。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            row = Math.max(row, map.get(num));<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : map.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.getOrDefault(num, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; count; j++) &#123;<br>                res.get(j).add(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2401. Longest Nice Subarray</title>
    <link href="/posts/3057488491.html"/>
    <url>/posts/3057488491.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array nums consisting of positive integers.</p><p>We call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.</p><p>Return the length of the longest nice subarray.</p><p>A subarray is a contiguous part of an array.</p><p>Note that subarrays of length 1 are always considered nice.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,8,48,10]<br>Output: 3<br>Explanation: The longest nice subarray is [3,8,48]. This subarray satisfies the conditions:</p><ul><li>3 AND 8 &#x3D; 0.</li><li>3 AND 48 &#x3D; 0.</li><li>8 AND 48 &#x3D; 0.<br>It can be proven that no longer nice subarray can be obtained, so we return 3.</li></ul><p>Example 2:<br>Input: nums &#x3D; [3,1,5,11,13]<br>Output: 1<br>Explanation: The length of the longest nice subarray is 1. Any subarray of length 1 can be chosen.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>最长优雅子数组。</p><blockquote><p>给你一个由 正 整数组成的数组 nums 。</p><p>如果 nums 的子数组中位于 不同 位置的每对元素按位 与（AND）运算的结果等于 0 ，则称该子数组为<code>优雅</code>子数组。</p><p>返回 最长 的优雅子数组的长度。</p><p>子数组 是数组中的一个 连续 部分。</p><p>注意：长度为 1 的子数组始终视作优雅子数组。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口，而且这道题涉及位运算。</p><p>题目让我们找的是一个满足题意的<code>优雅</code>子数组。看到子数组，不是说思路一定是滑动窗口，但是滑动窗口是一个比较好的选择，因为滑动窗口的复杂度一般在<code>O(n)</code>。但是这道题涉及到位运算，而且题目对<code>优雅</code>的定义是子数组之间每两个元素之间都要满足<code>AND</code>的结果为 0。那么如何定义一堆数字互相做AND操作的结果为0呢？这里我们可以用<code>异或XOR</code>来实现。因为<code>异或</code>的特性是，两个数相同为0，不同为1。如果一堆数字XOR的结果为0，说明这一堆数字里面出现的1都在32个bit的不同位置上。</p><ul><li>回到题目，我们可以使用滑动窗口（双指针）来维护一个窗口，使得窗口内的所有数字按位与<code>AND</code>结果为零。</li><li>维护一个变量 or 记录窗口内所有元素的按位或（OR），用于快速检查是否满足条件：<ul><li>若 nums[right] &amp; or &#x3D;&#x3D; 0，则 nums[right] 可以加入窗口，更新 or。</li><li>否则，需要移动 left 指针，直到 nums[right] 能够加入窗口。</li></ul></li></ul><p>在遍历过程中，维护 最大窗口长度 作为答案。</p><p>为什么 nums[right] 被加入窗口的时候是用 or 是因为 or 变量记录的是 32 个 bit 上出现过 1 的位置。如果 nums[right] &amp; or &#x3D;&#x3D; 0，说明 nums[right] 和窗口内的所有元素按位与的结果为 0，即 nums[right] 可以加入窗口。</p><p>为什么 nums[left] 从窗口被移除的时候是做 xor 操作是因为 nums[left] 被移除的时候我们需要去掉 nums[left] 对 or 贡献的所有的 1。如果 or 在某一些 bit 上是 1，那么当 or 跟 nums[left] 做 xor 的时候，这些 bit 上的 1 会被去掉。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestNiceSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">or</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>            <span class="hljs-keyword">while</span> ((or &amp; nums[end]) != <span class="hljs-number">0</span>) &#123;<br>                or ^= nums[start];<br>                start++;<br>            &#125;<br>            or |= nums[end];<br>            end++;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2226. Maximum Candies Allocated to K Children</title>
    <link href="/posts/2826717247.html"/>
    <url>/posts/2826717247.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.</p><p>You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can be allocated candies from only one pile of candies and some piles of candies may go unused.</p><p>Return the maximum number of candies each child can get.</p><p>Example 1:<br>Input: candies &#x3D; [5,8,6], k &#x3D; 3<br>Output: 5<br>Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.</p><p>Example 2:<br>Input: candies &#x3D; [2,5], k &#x3D; 11<br>Output: 0<br>Explanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.</p><p>Constraints:<br>1 &lt;&#x3D; candies.length &lt;&#x3D; 105<br>1 &lt;&#x3D; candies[i] &lt;&#x3D; 107<br>1 &lt;&#x3D; k &lt;&#x3D; 1012</p><p>每个小孩最多能分到多少糖果。</p><blockquote><p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。</p><p>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。</p><p>返回每个小孩可以拿走的 最大糖果数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分，而且是在答案上二分。</p><p>题目只允许我们把一堆糖果分成多个更小的堆，所以最后每个小孩能拿走的糖果数最大是不会超过糖果堆中的最大值的。所以我们可以二分这个最大值，然后判断是否能够分配给k个小孩。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumCandies</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candies, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candy : candies) &#123;<br>            max = Math.max(max, candy);<br>            sum += candy;<br>        &#125;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-comment">// 总糖果数都不够 k 个孩子分配至少 1 颗，直接返回 0</span><br>        <span class="hljs-keyword">if</span> (sum &lt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> max;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (helper(candies, mid, k)) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candies, <span class="hljs-type">long</span> count, <span class="hljs-type">long</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candy : candies) &#123;<br>            res += candy / count;<br>            <span class="hljs-keyword">if</span> (res &gt;= k) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &gt;= k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3101. Count Alternating Subarrays</title>
    <link href="/posts/3020850910.html"/>
    <url>/posts/3020850910.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary array nums.</p><p>We call a subarray alternating if no two adjacent elements in the subarray have the same value.</p><p>Return the number of alternating subarrays in nums.</p><p>Example 1:<br>Input: nums &#x3D; [0,1,1,1]<br>Output: 5</p><p>Explanation:<br>The following subarrays are alternating: [0], [1], [1], [1], and [0,1].</p><p>Example 2:<br>Input: nums &#x3D; [1,0,1,0]<br>Output: 10</p><p>Explanation:<br>Every subarray of the array is alternating. There are 10 possible subarrays that we can choose.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>nums[i] is either 0 or 1.</p><p>交替子数组计数。</p><blockquote><p>给你一个二进制数组nums 。</p><p>如果一个子数组中 不存在 两个 相邻 元素的值 相同 的情况，我们称这样的子数组为 交替子数组 。</p><p>返回数组 nums 中交替子数组的数量。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不难。通过这道题我们可以学到如何计算交替数组的长度。这个思路有助于我们解决一些其他题目，详见<code>相关题目</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countAlternatingSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] != nums[i - <span class="hljs-number">1</span>]) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>            res += count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">3101. Count Alternating Subarrays<br>3206. Alternating Groups I<br>3208. Alternating Groups II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3208. Alternating Groups II</title>
    <link href="/posts/447520792.html"/>
    <url>/posts/447520792.html</url>
    
    <content type="html"><![CDATA[<p>There is a circle of red and blue tiles. You are given an array of integers colors and an integer k. The color of tile i is represented by colors[i]:<br>colors[i] &#x3D;&#x3D; 0 means that tile i is red.<br>colors[i] &#x3D;&#x3D; 1 means that tile i is blue.<br>An alternating group is every k contiguous tiles in the circle with alternating colors (each tile in the group except the first and last one has a different color from its left and right tiles).</p><p>Return the number of alternating groups.</p><p>Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.</p><p>Example 1:<br>Input: colors &#x3D; [0,1,0,1,0], k &#x3D; 3<br>Output: 3</p><p>Example 2:<br>Input: colors &#x3D; [0,1,0,0,1,0,1], k &#x3D; 6<br>Output: 2</p><p>Example 3:<br>Input: colors &#x3D; [1,1,0,1], k &#x3D; 4<br>Output: 0</p><p>Constraints:<br>3 &lt;&#x3D; colors.length &lt;&#x3D; 105<br>0 &lt;&#x3D; colors[i] &lt;&#x3D; 1<br>3 &lt;&#x3D; k &lt;&#x3D; colors.length</p><p>交替组 II。</p><blockquote><p>给你一个整数数组 colors 和一个整数 k ，colors表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：</p><p>colors[i] &#x3D;&#x3D; 0 表示第 i 块瓷砖的颜色是 红色 。<br>colors[i] &#x3D;&#x3D; 1 表示第 i 块瓷砖的颜色是 蓝色 。</p><p>环中连续 k 块瓷砖的颜色如果是 交替 颜色（也就是说除了第一块和最后一块瓷砖以外，中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。</p><p>请你返回 交替 组的数目。</p><p>注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路同版本一 3206，只是这次是 k 个元素的窗口。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfAlternatingGroups</span><span class="hljs-params">(<span class="hljs-type">int</span>[] colors, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> colors.length;<br>        <span class="hljs-comment">// 目前子数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + k - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> colors[i % n];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> colors[(i - <span class="hljs-number">1</span>) % n];<br>            <span class="hljs-keyword">if</span> (cur != prev) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果子数组长度大于等于k，那么就是一个满足题意的alternating group</span><br>            <span class="hljs-keyword">if</span> (count &gt;= k) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">3101. Count Alternating Subarrays<br>3206. Alternating Groups I<br>3208. Alternating Groups II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2269. Find the K-Beauty of a Number</title>
    <link href="/posts/573205847.html"/>
    <url>/posts/573205847.html</url>
    
    <content type="html"><![CDATA[<p>The k-beauty of an integer num is defined as the number of substrings of num when it is read as a string that meet the following conditions:</p><p>It has a length of k.<br>It is a divisor of num.<br>Given integers num and k, return the k-beauty of num.</p><p>Note:<br>Leading zeros are allowed.<br>0 is not a divisor of any value.<br>A substring is a contiguous sequence of characters in a string.</p><p>Example 1:<br>Input: num &#x3D; 240, k &#x3D; 2<br>Output: 2<br>Explanation: The following are the substrings of num of length k:</p><ul><li>“24” from “240”: 24 is a divisor of 240.</li><li>“40” from “240”: 40 is a divisor of 240.<br>Therefore, the k-beauty is 2.</li></ul><p>Example 2:<br>Input: num &#x3D; 430043, k &#x3D; 2<br>Output: 2<br>Explanation: The following are the substrings of num of length k:</p><ul><li>“43” from “430043”: 43 is a divisor of 430043.</li><li>“30” from “430043”: 30 is not a divisor of 430043.</li><li>“00” from “430043”: 0 is not a divisor of 430043.</li><li>“04” from “430043”: 4 is not a divisor of 430043.</li><li>“43” from “430043”: 43 is a divisor of 430043.<br>Therefore, the k-beauty is 2.</li></ul><p>Constraints:<br>1 &lt;&#x3D; num &lt;&#x3D; 109<br>1 &lt;&#x3D; k &lt;&#x3D; num.length (taking num as a string)</p><p>找到一个数字的 K 美丽值。</p><blockquote><p>一个整数 num 的 k 美丽值定义为 num 中符合以下条件的 子字符串 数目：</p><p>子字符串长度为 k 。<br>子字符串能整除 num 。<br>给你整数 num 和 k ，请你返回 num 的 k 美丽值。</p><p>注意：<br>允许有 前缀 0 。<br>0 不能整除任何值。<br>一个 子字符串 是一个字符串里的连续一段字符序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将 num 转换为字符串，方便提取长度为 k 的子串。<br>遍历所有可能的 k 长度子串，将其转换为整数。<br>判断该整数是否能整除 num（需要排除除数为 0 的情况）。<br>计数满足条件的子串数量。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divisorSubstrings</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">numStr</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= numStr.length() - k; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curNum</span> <span class="hljs-operator">=</span> Integer.parseInt(numStr.substring(i, i + k));<br>            <span class="hljs-comment">// System.out.println(curNum);</span><br>            <span class="hljs-keyword">if</span> (curNum != <span class="hljs-number">0</span> &amp;&amp; num % curNum == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2588. Count the Number of Beautiful Subarrays</title>
    <link href="/posts/804582017.html"/>
    <url>/posts/804582017.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums. In one operation, you can:<br>Choose two different indices i and j such that 0 &lt;&#x3D; i, j &lt; nums.length.<br>Choose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.<br>Subtract 2k from nums[i] and nums[j].</p><p>A subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.</p><p>Return the number of beautiful subarrays in the array nums.</p><p>A subarray is a contiguous non-empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [4,3,1,2,4]<br>Output: 2<br>Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].</p><ul><li>We can make all elements in the subarray [3,1,2] equal to 0 in the following way:<ul><li>Choose [3, 1, 2] and k &#x3D; 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].</li><li>Choose [1, 1, 0] and k &#x3D; 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].</li></ul></li><li>We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:<ul><li>Choose [4, 3, 1, 2, 4] and k &#x3D; 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].</li><li>Choose [0, 3, 1, 2, 0] and k &#x3D; 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].</li><li>Choose [0, 2, 0, 2, 0] and k &#x3D; 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].</li></ul></li></ul><p>Example 2:<br>Input: nums &#x3D; [1,10,4]<br>Output: 0<br>Explanation: There are no beautiful subarrays in nums.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 106</p><p>统计美丽子数组数目。</p><blockquote>给你一个下标从 0 开始的整数数组nums 。每次操作中，你可以：<p>选择两个满足 0 &lt;&#x3D; i, j &lt; nums.length 的不同下标 i 和 j 。<br>选择一个非负整数 k ，满足 nums[i] 和 nums[j] 在二进制下的第 k 位（下标编号从 0 开始）是 1 。<br>将 nums[i] 和 nums[j] 都减去 2k 。</p><p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 0 的数组，那么我们称它是一个 美丽 的子数组。</p><p>请你返回数组 nums 中 美丽子数组 的数目。</p><p>子数组是一个数组中一段连续 非空 的元素序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。注意题目要我们找的是<code>子数组</code>，子数组的特点是连续的。但是这种题一般不会允许你用<code>O(n^2)</code>的复杂度去解决，同时这道题还牵涉到如何把数字变成0，所以应该不是暴力解做。</p><p>我们可以把数字转换成二进制，看看是否能找到规律。比如对于数组<code>[4,3,1,2,4]</code>而言，他的二进制是</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">100<br>011<br>001<br>010<br>100<br></code></pre></td></tr></table></figure><p>因为题目要求我们每次只能选择两个不同数字来把他们某一位上的 1 变成 0，那么我们可以看每一位上 1 的个数是否为偶数个。如果某一位上有奇数个 1 的话就不行，因为题目要求我们找的是连续的子数组。那么既然是找连续的子数组他们在某一位上 1 的个数为偶数个的话，我们就可以用前缀和的思路解决。如果某一些数字他们的前缀和为0的话，就说明他们的二进制表达在每一位上 1 的个数为偶数个。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">beautifulSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] ^ nums[i];<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            count += map.getOrDefault(presum[i], <span class="hljs-number">0</span>);<br>            map.put(presum[i], map.getOrDefault(presum[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>prefix sum</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2506. Count Pairs Of Similar Strings</title>
    <link href="/posts/736386976.html"/>
    <url>/posts/736386976.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed string array words.</p><p>Two strings are similar if they consist of the same characters.</p><p>For example, “abca” and “cba” are similar since both consist of characters ‘a’, ‘b’, and ‘c’.<br>However, “abacba” and “bcfd” are not similar since they do not consist of the same characters.<br>Return the number of pairs (i, j) such that 0 &lt;&#x3D; i &lt; j &lt;&#x3D; word.length - 1 and the two strings words[i] and words[j] are similar.</p><p>Example 1:<br>Input: words &#x3D; [“aba”,”aabb”,”abcd”,”bac”,”aabc”]<br>Output: 2<br>Explanation: There are 2 pairs that satisfy the conditions:</p><ul><li>i &#x3D; 0 and j &#x3D; 1 : both words[0] and words[1] only consist of characters ‘a’ and ‘b’.</li><li>i &#x3D; 3 and j &#x3D; 4 : both words[3] and words[4] only consist of characters ‘a’, ‘b’, and ‘c’.</li></ul><p>Example 2:<br>Input: words &#x3D; [“aabb”,”ab”,”ba”]<br>Output: 3<br>Explanation: There are 3 pairs that satisfy the conditions:</p><ul><li>i &#x3D; 0 and j &#x3D; 1 : both words[0] and words[1] only consist of characters ‘a’ and ‘b’.</li><li>i &#x3D; 0 and j &#x3D; 2 : both words[0] and words[2] only consist of characters ‘a’ and ‘b’.</li><li>i &#x3D; 1 and j &#x3D; 2 : both words[1] and words[2] only consist of characters ‘a’ and ‘b’.</li></ul><p>Example 3:<br>Input: words &#x3D; [“nba”,”cba”,”dba”]<br>Output: 0<br>Explanation: Since there does not exist any pair that satisfies the conditions, we return 0.</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 100<br>words[i] consist of only lowercase English letters.</p><p>统计相似字符串对的数目。</p><blockquote><p>给你一个下标从 0 开始的字符串数组 words 。</p><p>如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。</p><p>例如，”abca” 和 “cba” 相似，因为它们都由字符 ‘a’、’b’、’c’ 组成。<br>然而，”abacba” 和 “bcfd” 不相似，因为它们不是相同字符组成的。<br>请你找出满足字符串 words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 &lt;&#x3D; i &lt; j &lt;&#x3D; words.length - 1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是类似 two sum 的做法。</p><p>暴力解的做法是把每两个不同的字符串拿出来作比较，如果他们构成题目定义的<code>相似</code>，则结果加一。这个做法肯定是<code>O(n^2)</code>的复杂度。</p><p>优化的思路需要考虑能否用空间换时间。这里我们用 hashmap 把每个字符串里的字符统计出来，然后用一个字符串的字符统计结果作为 key，然后遍历所有字符串，如果有相同的 key，则结果加一。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">similarPairs</span><span class="hljs-params">(String[] words)</span> &#123;<br>        HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> helper(word);<br>            res += map.getOrDefault(key, <span class="hljs-number">0</span>);<br>            map.put(key, map.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">helper</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">char</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (map[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
      <tag>counting sort</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2658. Maximum Number of Fish in a Grid</title>
    <link href="/posts/2867469525.html"/>
    <url>/posts/2867469525.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:<br>A land cell if grid[r][c] &#x3D; 0, or<br>A water cell containing grid[r][c] fish, if grid[r][c] &gt; 0.<br>A fisher can start at any water cell (r, c) and can do the following operations any number of times:</p><p>Catch all the fish at cell (r, c), or<br>Move to any adjacent water cell.<br>Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.</p><p>An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2023/03/29/example.png" alt="Example 1"><br>Input: grid &#x3D; [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]<br>Output: 7<br>Explanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2023/03/29/example2.png" alt="Example 2"><br>Input: grid &#x3D; [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]<br>Output: 1<br>Explanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish.</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 10</p><p>网格图中鱼的最大数目。</p><blockquote><p>给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，其中下标在 (r, c) 处的整数表示：</p><p>如果 grid[r][c] &#x3D; 0 ，那么它是一块 陆地 。<br>如果 grid[r][c] &gt; 0 ，那么它是一块 水域 ，且包含 grid[r][c] 条鱼。<br>一位渔夫可以从任意 水域 格子 (r, c) 出发，然后执行以下操作任意次：</p><p>捕捞格子 (r, c) 处所有的鱼，或者<br>移动到相邻的 水域 格子。<br>请你返回渔夫最优策略下， 最多 可以捕捞多少条鱼。如果没有水域格子，请你返回 0 。</p><p>格子 (r, c) 相邻 的格子为 (r, c + 1) ，(r, c - 1) ，(r + 1, c) 和 (r - 1, c) ，前提是相邻格子在网格图内。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是 flood fill 类型的题目。这道题是让我们在矩阵内找一个面积最大的岛屿。<br>695题几乎是一模一样的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>BFS实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dirs = &#123; &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125; &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxFish</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    res = Math.max(res, bfs(grid, i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> grid[i][j];<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] &gt; <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; x, y &#125;);<br>                    count += grid[x][y];<br>                    grid[x][y] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxFish</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    res = Math.max(res, dfs(grid, i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> grid[i][j];<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        count += dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        count += dfs(grid, i + <span class="hljs-number">1</span>, j);<br>        count += dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        count += dfs(grid, i, j + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">695. Max Area of Island<br>2658. Maximum Number of Fish in a Grid<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2342. Max Sum of a Pair With Equal Sum of Digits</title>
    <link href="/posts/4089744146.html"/>
    <url>/posts/4089744146.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i !&#x3D; j, and the sum of digits of the number nums[i] is equal to that of nums[j].</p><p>Return the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.</p><p>Example 1:<br>Input: nums &#x3D; [18,43,36,13,7]<br>Output: 54<br>Explanation: The pairs (i, j) that satisfy the conditions are:</p><ul><li>(0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 &#x3D; 54.</li><li>(1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 &#x3D; 50.<br>So the maximum sum that we can obtain is 54.</li></ul><p>Example 2:<br>Input: nums &#x3D; [10,12,19,14]<br>Output: -1<br>Explanation: There are no two numbers that satisfy the conditions, so we return -1.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>数位和相等数对的最大和。</p><blockquote><p>给你一个下标从 0 开始的数组 nums ，数组中的元素都是 正 整数。请你选出两个下标 i 和 j（i !&#x3D; j），且 nums[i] 的数位和 与 nums[j] 的数位和相等。</p><p>请你找出所有满足条件的下标 i 和 j ，找出并返回 nums[i] + nums[j] 可以得到的 最大值 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是类似 two sum 那一类的题目。题目需要我们找到两个下标不同的，但是他们的<code>数位和</code>是一样的数字。注意题目给的数据范围，最大是10^9，所以两层 for 循环肯定是不能过的。那么这道题我们可以用类似 two sum 的思路，用 hashmap 来存储&lt;不同的数位和，此数位和下最大的数字&gt;。开始遍历 input 数组，把每个数字的数位和算出来，然后和 hashmap 中的比较，如果有相同的数位和，那么就更新最大值。如果最后没发现有两个数字有相同的数位和则返回 -1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">digitSum</span> <span class="hljs-operator">=</span> helper(cur);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(digitSum)) &#123;<br>                map.put(digitSum, cur);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> map.get(digitSum);<br>                res = Math.max(res, last + cur);<br>                map.put(digitSum, Math.max(last, cur));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            res += num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2364. Count Number of Bad Pairs</title>
    <link href="/posts/446304299.html"/>
    <url>/posts/446304299.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i &lt; j and j - i !&#x3D; nums[j] - nums[i].</p><p>Return the total number of bad pairs in nums.</p><p>Example 1:<br>Input: nums &#x3D; [4,1,3,3]<br>Output: 5<br>Explanation: The pair (0, 1) is a bad pair since 1 - 0 !&#x3D; 1 - 4.<br>The pair (0, 2) is a bad pair since 2 - 0 !&#x3D; 3 - 4, 2 !&#x3D; -1.<br>The pair (0, 3) is a bad pair since 3 - 0 !&#x3D; 3 - 4, 3 !&#x3D; -1.<br>The pair (1, 2) is a bad pair since 2 - 1 !&#x3D; 3 - 1, 1 !&#x3D; 2.<br>The pair (2, 3) is a bad pair since 3 - 2 !&#x3D; 3 - 3, 1 !&#x3D; 0.<br>There are a total of 5 bad pairs, so we return 5.</p><p>Example 2:<br>Input: nums &#x3D; [1,2,3,4,5]<br>Output: 0<br>Explanation: There are no bad pairs.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>统计坏数对的数目。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 。如果 i &lt; j 且 j - i !&#x3D; nums[j] - nums[i] ，那么我们称 (i, j) 是一个 坏数对 。</p><p>请你返回 nums 中 坏数对 的总数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道乍一看是O(n^2)复杂度但其实是 two sum 变种的题。题目要我们找的数对需要满足<code>i &lt; j 且 j - i != nums[j] - nums[i]</code>，那么我们是不是可以反过来看。首先对于一个长度为 n 的数组，所有不同下标的数对的和 &#x3D; n * (n - 1) &#x2F; 2，那么我们可以先统计所有的数对的和，然后再统计满足条件<code>j - i == nums[j] - nums[i]</code>的数对的和，两者相减就是我们要找的结果。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countBadPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * j - i != nums[j] - nums[i]</span><br><span class="hljs-comment">         * j - nums[j] != i - nums[i]</span><br><span class="hljs-comment">         */</span><br>        HashMap&lt;Integer, Long&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> * n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            count += map.getOrDefault(i - num, <span class="hljs-number">0L</span>);<br>            map.put(i - num, map.getOrDefault(i - num, <span class="hljs-number">0L</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res - count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2349. Design a Number Container System</title>
    <link href="/posts/1240229660.html"/>
    <url>/posts/1240229660.html</url>
    
    <content type="html"><![CDATA[<p>Design a number container system that can do the following:<br>Insert or Replace a number at the given index in the system.<br>Return the smallest index for the given number in the system.</p><p>Implement the NumberContainers class:<br>NumberContainers() Initializes the number container system.<br>void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.<br>int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.</p><p>Example 1:<br>Input<br>[“NumberContainers”, “find”, “change”, “change”, “change”, “change”, “find”, “change”, “find”]<br>[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]<br>Output<br>[null, -1, null, null, null, null, 1, null, 2]</p><p>Explanation<br>NumberContainers nc &#x3D; new NumberContainers();<br>nc.find(10); &#x2F;&#x2F; There is no index that is filled with number 10. Therefore, we return -1.<br>nc.change(2, 10); &#x2F;&#x2F; Your container at index 2 will be filled with number 10.<br>nc.change(1, 10); &#x2F;&#x2F; Your container at index 1 will be filled with number 10.<br>nc.change(3, 10); &#x2F;&#x2F; Your container at index 3 will be filled with number 10.<br>nc.change(5, 10); &#x2F;&#x2F; Your container at index 5 will be filled with number 10.<br>nc.find(10); &#x2F;&#x2F; Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1.<br>nc.change(1, 20); &#x2F;&#x2F; Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20.<br>nc.find(10); &#x2F;&#x2F; Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2.</p><p>Constraints:<br>1 &lt;&#x3D; index, number &lt;&#x3D; 109<br>At most 105 calls will be made in total to change and find.</p><p>设计数字容器系统。</p><blockquote><p>设计一个数字容器系统，可以实现以下功能：</p><p>在系统中给定下标处 插入 或者 替换 一个数字。<br>返回 系统中给定数字的最小下标。<br>请你实现一个 NumberContainers 类：</p><p>NumberContainers() 初始化数字容器系统。<br>void change(int index, int number) 在下标 index 处填入 number 。如果该下标 index 处已经有数字了，那么用 number 替换该数字。<br>int find(int number) 返回给定数字 number 在系统中的最小下标。如果系统中没有 number ，那么返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>创建两个hashmap，第一个存储index和number的映射，第二个存储number和index的映射。其中第二个hashmap里是&lt;number, TreeSet&gt;，因为存的是当前这个数字所有出现过的下标。为什么要用TreeSet存是因为需要很快找到最小的index和删除index，TreeSet里，删除这个动作的时间复杂度是O(logn)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>change函数  <ul><li>时间O(nlogn)</li><li>空间O(n)</li></ul></li><li>find函数  <ul><li>时间O(1)</li><li>空间O(1)</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberContainers</span> &#123;<br>    <span class="hljs-comment">// &lt;index, number&gt;</span><br>    HashMap&lt;Integer, Integer&gt; indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// &lt;number, set of indexes&gt;</span><br>    HashMap&lt;Integer, TreeSet&lt;Integer&gt;&gt; numberMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumberContainers</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-keyword">if</span> (indexMap.containsKey(index)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldNumber</span> <span class="hljs-operator">=</span> indexMap.get(index);<br>            numberMap.get(oldNumber).remove(index);<br>        &#125;<br>        indexMap.put(index, number);<br>        <span class="hljs-keyword">if</span> (!numberMap.containsKey(number)) &#123;<br>            numberMap.put(number, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;());<br>        &#125;<br>        numberMap.get(number).add(index);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (numberMap.containsKey(number)) &#123;<br>            TreeSet&lt;Integer&gt; indexes = numberMap.get(number);<br>            <span class="hljs-keyword">if</span> (indexes.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> indexes.first();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : min;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumberContainers object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumberContainers obj = new NumberContainers();</span><br><span class="hljs-comment"> * obj.change(index,number);</span><br><span class="hljs-comment"> * int param_2 = obj.find(number);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>treemap</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2683. Neighboring Bitwise XOR</title>
    <link href="/posts/2365694581.html"/>
    <url>/posts/2365694581.html</url>
    
    <content type="html"><![CDATA[<p>A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n.</p><p>Specifically, for each index i in the range [0, n - 1]:<br>If i &#x3D; n - 1, then derived[i] &#x3D; original[i] ⊕ original[0].<br>Otherwise, derived[i] &#x3D; original[i] ⊕ original[i + 1].<br>Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.</p><p>Return true if such an array exists or false otherwise.</p><p>A binary array is an array containing only 0’s and 1’s</p><p>Example 1:<br>Input: derived &#x3D; [1,1,0]<br>Output: true<br>Explanation: A valid original array that gives derived is [0,1,0].<br>derived[0] &#x3D; original[0] ⊕ original[1] &#x3D; 0 ⊕ 1 &#x3D; 1<br>derived[1] &#x3D; original[1] ⊕ original[2] &#x3D; 1 ⊕ 0 &#x3D; 1<br>derived[2] &#x3D; original[2] ⊕ original[0] &#x3D; 0 ⊕ 0 &#x3D; 0</p><p>Example 2:<br>Input: derived &#x3D; [1,1]<br>Output: true<br>Explanation: A valid original array that gives derived is [0,1].<br>derived[0] &#x3D; original[0] ⊕ original[1] &#x3D; 1<br>derived[1] &#x3D; original[1] ⊕ original[0] &#x3D; 1</p><p>Example 3:<br>Input: derived &#x3D; [1,0]<br>Output: false<br>Explanation: There is no valid original array that gives derived.</p><p>Constraints:<br>n &#x3D;&#x3D; derived.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>The values in derived are either 0’s or 1’s</p><p>相邻值的按位异或。</p><blockquote>下标从 0 开始、长度为 n 的数组 derived 是由同样长度为 n 的原始 二进制数组 original 通过计算相邻值的 按位异或（⊕）派生而来。<p>特别地，对于范围 [0, n - 1] 内的每个下标 i ：<br>如果 i &#x3D; n - 1 ，那么 derived[i] &#x3D; original[i] ⊕ original[0]<br>否则 derived[i] &#x3D; original[i] ⊕ original[i + 1]<br>给你一个数组 derived ，请判断是否存在一个能够派生得到 derived 的 有效原始二进制数组 original 。</p><p>如果存在满足要求的原始二进制数组，返回 true ；否则，返回 false 。</p><p>二进制数组是仅由 0 和 1 组成的数组。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是位运算的前缀和。题目说了 derived 数组是由一个长度相同的二进制数组 original 通过计算相邻值的 按位异或（XOR）派生而来，其中对于任意的 derived[i] 而言，derived[i] &#x3D; original[i] ⊕ original[i + 1]。那么，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">derived[0] = original[0] XOR original[1]<br>derived[1] = original[1] XOR original[2]<br>derived[2] = original[2] XOR original[3]<br>...<br>derived[n-2] = original[n-2] XOR original[n-1]<br>derived[n-1] = original[n-1] XOR original[0]<br></code></pre></td></tr></table></figure><p>如果我们截取一段更短的做运算，比如如下这一段，假设只有三个元素，那么<br><code>derived[0] XOR derived[1] XOR derived[2]</code> 就等于<br><code>original[0] XOR original[1] XOR original[1] XOR original[2] XOR original[2] XOR original[0]</code></p><p>其中因为 XOR 是异或操作，两个相同的数字异或等于 0，那么这一段我们把它变一下<br><code>original[0] XOR original[0] XOR original[1] XOR original[1] XOR original[2] XOR original[2]</code>，其中两两XOR的结果 &#x3D; 0，所以如果他们整体 XOR 的结果等于 0 的话，那么就证明 derived 数组是合法的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doesValidArrayExist</span><span class="hljs-params">(<span class="hljs-type">int</span>[] derived)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : derived) &#123;<br>            res ^= d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>prefix sum</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1310. XOR Queries of a Subarray</title>
    <link href="/posts/2713414642.html"/>
    <url>/posts/2713414642.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array arr of positive integers. You are also given the array queries where queries[i] &#x3D; [left, right].</p><p>For each query i compute the XOR of elements from left to right (that is, arr[left] XOR arr[left + 1] XOR … XOR arr[right] ).</p><p>Return an array answer where answer[i] is the answer to the ith query.</p><p>Example 1:<br>Input: arr &#x3D; [1,3,4,8], queries &#x3D; [[0,1],[1,2],[0,3],[3,3]]<br>Output: [2,7,14,8]<br>Explanation:<br>The binary representation of the elements in the array are:<br>1 &#x3D; 0001<br>3 &#x3D; 0011<br>4 &#x3D; 0100<br>8 &#x3D; 1000<br>The XOR values for queries are:<br>[0,1] &#x3D; 1 xor 3 &#x3D; 2<br>[1,2] &#x3D; 3 xor 4 &#x3D; 7<br>[0,3] &#x3D; 1 xor 3 xor 4 xor 8 &#x3D; 14<br>[3,3] &#x3D; 8</p><p>Example 2:<br>Input: arr &#x3D; [4,8,2,10], queries &#x3D; [[2,3],[1,3],[0,0],[0,3]]<br>Output: [8,0,4,4]</p><p>Constraints:<br>1 &lt;&#x3D; arr.length, queries.length &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 109<br>queries[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; lefti &lt;&#x3D; righti &lt; arr.length</p><p>子数组异或查询。</p><blockquote>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p><p>并返回一个包含给定查询 queries 所有结果的数组。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和，而且是一道位运算的前缀和题目。因为题目要我们返回一些 queries 的结果，queries 都是一些区间，所以大概率是前缀和做。同时异或运算（XOR）是怎么处理前缀和的呢？假如 input 数组的前 i 项的 XOR 前缀和为 a, 前 j 项的 XOR 前缀和为 b, 那么 <code>a xor b</code> 就是 input 数组的 [i + 1, j) 项的 XOR 结果。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] xorQueries(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        presum[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] ^ arr[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>            <span class="hljs-type">int</span>[] query = queries[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> query[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> query[<span class="hljs-number">1</span>];<br>            res[i] = presum[left] ^ presum[right + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2909. Minimum Sum of Mountain Triplets II</title>
    <link href="/posts/1599691927.html"/>
    <url>/posts/1599691927.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array nums of integers.</p><p>A triplet of indices (i, j, k) is a mountain if:<br>i &lt; j &lt; k<br>nums[i] &lt; nums[j] and nums[k] &lt; nums[j]<br>Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.</p><p>Example 1:<br>Input: nums &#x3D; [8,6,1,5,3]<br>Output: 9<br>Explanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since:</p><ul><li>2 &lt; 3 &lt; 4</li><li>nums[2] &lt; nums[3] and nums[4] &lt; nums[3]<br>And the sum of this triplet is nums[2] + nums[3] + nums[4] &#x3D; 9. It can be shown that there are no mountain triplets with a sum of less than 9.</li></ul><p>Example 2:<br>Input: nums &#x3D; [5,4,8,7,10,2]<br>Output: 13<br>Explanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since:</p><ul><li>1 &lt; 3 &lt; 5</li><li>nums[1] &lt; nums[3] and nums[5] &lt; nums[3]<br>And the sum of this triplet is nums[1] + nums[3] + nums[5] &#x3D; 13. It can be shown that there are no mountain triplets with a sum of less than 13.</li></ul><p>Example 3:<br>Input: nums &#x3D; [6,5,4,3,4,5]<br>Output: -1<br>Explanation: It can be shown that there are no mountain triplets in nums.</p><p>Constraints:<br>3 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 108</p><p>元素和最小的山形三元组 II。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 。</p><p>如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：</p><ul><li>i &lt; j &lt; k</li><li>nums[i] &lt; nums[j] 且 nums[k] &lt; nums[j]<br>请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。</li></ul></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我参考了<a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/solutions/2493548/mei-ju-numsj-qian-hou-zhui-fen-jie-pytho-tskf">这个帖子</a>。这是一道类似 two sum 的题。题目要求我们找到一个三元组满足如下条件</p><ul><li>i &lt; j &lt; k</li><li>nums[i] &lt; nums[j] 且 nums[k] &lt; nums[j]</li></ul><p>那么我们可以枚举 j，需要遍历两遍数组。<br>第一次遍历 input 数组，先用两个数组分别记录 j 左侧最小的 i 和 j 右侧最大的 k，记为<code>premin</code>和<code>suffmin</code>。<br>第二次遍历 input 数组，对于每个下标 j，我们看一看他左侧的最小值，右侧的最小值和他自己是否满足<code>nums[i] &lt; nums[j] 且 nums[k] &lt; nums[j]</code>这个式子。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] premin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            premin[i] = min;<br>            min = Math.min(min, nums[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] suffmin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        min = nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            suffmin[i] = min;<br>            min = Math.min(min, nums[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (premin[i] &lt; cur &amp;&amp; suffmin[i] &lt; cur) &#123;<br>                res = Math.min(res, premin[i] + cur + suffmin[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3258. Count Substrings That Satisfy K-Constraint I</title>
    <link href="/posts/1590389426.html"/>
    <url>/posts/1590389426.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary string s and an integer k.</p><p>A binary string satisfies the k-constraint if either of the following conditions holds:<br>The number of 0’s in the string is at most k.<br>The number of 1’s in the string is at most k.</p><p>Return an integer denoting the number of substrings of s that satisfy the k-constraint.</p><p>Example 1:<br>Input: s &#x3D; “10101”, k &#x3D; 1<br>Output: 12</p><p>Explanation:<br>Every substring of s except the substrings “1010”, “10101”, and “0101” satisfies the k-constraint.</p><p>Example 2:<br>Input: s &#x3D; “1010101”, k &#x3D; 2<br>Output: 25</p><p>Explanation:<br>Every substring of s except the substrings with a length greater than 5 satisfies the k-constraint.</p><p>Example 3:<br>Input: s &#x3D; “11111”, k &#x3D; 1<br>Output: 15</p><p>Explanation:<br>All substrings of s satisfy the k-constraint.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 50<br>1 &lt;&#x3D; k &lt;&#x3D; s.length<br>s[i] is either ‘0’ or ‘1’.</p><p>统计满足 K 约束的子字符串数量 I。</p><blockquote><p>给你一个 二进制 字符串 s 和一个整数 k。</p><p>如果一个 二进制字符串 满足以下任一条件，则认为该字符串满足 k 约束：</p><p>字符串中 0 的数量最多为 k。<br>字符串中 1 的数量最多为 k。</p><p>返回一个整数，表示 s 的所有满足 k 约束 的子字符串的数量。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口。注意这道题要我们找的是满足如下这两个条件<code>之一</code>就行的子串。所以代码中只要跳出 while 循环，就可以累加结果。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">字符串中 0 的数量最多为 k。<br>字符串中 1 的数量最多为 k。<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countKConstraintSubstrings</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                one++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                zero++;<br>            &#125;<br>            end++;<br>            <span class="hljs-keyword">while</span> (zero &gt; k &amp;&amp; one &gt; k) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                <span class="hljs-keyword">if</span> (c2 == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    one--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    zero--;<br>                &#125;<br>                start++;<br>            &#125;<br>            res += end - start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3325. Count Substrings With K-Frequency Characters I</title>
    <link href="/posts/1420677911.html"/>
    <url>/posts/1420677911.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s and an integer k, return the total number of substrings of s where at least one character appears at least k times.</p><p>Example 1:<br>Input: s &#x3D; “abacb”, k &#x3D; 2<br>Output: 4</p><p>Explanation:<br>The valid substrings are:<br>“aba” (character ‘a’ appears 2 times).<br>“abac” (character ‘a’ appears 2 times).<br>“abacb” (character ‘a’ appears 2 times).<br>“bacb” (character ‘b’ appears 2 times).</p><p>Example 2:<br>Input: s &#x3D; “abcde”, k &#x3D; 1<br>Output: 15</p><p>Explanation:<br>All substrings are valid because every character appears at least once.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 3000<br>1 &lt;&#x3D; k &lt;&#x3D; s.length<br>s consists only of lowercase English letters.</p><p>字符至少出现 K 次的子字符串 I。</p><blockquote><p>给你一个字符串 s 和一个整数 k，在 s 的所有子字符串中，请你统计并返回 至少有一个 字符 至少出现 k 次的子字符串总数。</p><p>子字符串 是字符串中的一个连续、 非空 的字符序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题类似 1358 题，也是滑动窗口里找一个越长越合法的子串。建议先做 1358 题，几乎是一样的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubstrings</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            map[c1 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            end++;<br>            <span class="hljs-comment">// 至少有一个字符出现 k 次吗？是，移动左指针</span><br>            <span class="hljs-keyword">while</span> (helper(map, k) == <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2 - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                start++;<br>            &#125;<br>            <span class="hljs-comment">// 跳出while循环前的所有[start, end]都是合法的子串</span><br>            res += start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] map, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map[i] &gt;= k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1358. Number of Substrings Containing All Three Characters<br>3325. Count Substrings With K-Frequency Characters I<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2779. Maximum Beauty of an Array After Applying Operation</title>
    <link href="/posts/3808757599.html"/>
    <url>/posts/3808757599.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array nums and a non-negative integer k.</p><p>In one operation, you can do the following:<br>Choose an index i that hasn’t been chosen before from the range [0, nums.length - 1].<br>Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].<br>The beauty of the array is the length of the longest subsequence consisting of equal elements.</p><p>Return the maximum possible beauty of the array nums after applying the operation any number of times.</p><p>Note that you can apply the operation to each index only once.</p><p>A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</p><p>Example 1:<br>Input: nums &#x3D; [4,6,1,2], k &#x3D; 2<br>Output: 3<br>Explanation: In this example, we apply the following operations:</p><ul><li>Choose index 1, replace it with 4 (from range [4,8]), nums &#x3D; [4,4,1,2].</li><li>Choose index 3, replace it with 4 (from range [0,4]), nums &#x3D; [4,4,1,4].<br>After the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).<br>It can be proven that 3 is the maximum possible length we can achieve.</li></ul><p>Example 2:<br>Input: nums &#x3D; [1,1,1,1], k &#x3D; 10<br>Output: 4<br>Explanation: In this example we don’t have to apply any operations.<br>The beauty of the array nums is 4 (whole array).</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i], k &lt;&#x3D; 105</p><p>数组的最大美丽值。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 和一个 非负 整数 k 。</p><p>在一步操作中，你可以执行下述指令：</p><p>在范围 [0, nums.length - 1] 中选择一个 此前没有选过 的下标 i 。<br>将 nums[i] 替换为范围 [nums[i] - k, nums[i] + k] 内的任一整数。<br>数组的 美丽值 定义为数组中由相等元素组成的最长子序列的长度。</p><p>对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。</p><p>注意：你只能对每个下标执行 一次 此操作。</p><p>数组的 子序列 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题有多种思路，这里我提供一个滑动窗口的思路。我参考了<a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/solutions/2345805/pai-xu-shuang-zhi-zhen-by-endlesscheng-hbqx">这个帖子</a>。</p><p>题目允许我们把数组中的每一个数字 nums[i] 替换成 [nums[i] - k, nums[i] + k] 范围内的任意整数，且让我们找的是一个最长的子序列。因为找的是子序列，而且数字是可以改的，所以这里我们可以对 input 数组<code>排序</code>。</p><p>排序过后，假如我们最终找到的最长子序列是 [left, left + 1, left + 2,…, right]，那么这段子序列需要满足<code>最小值 left + k &gt;= 最大值 right - k</code>。把这个式子变一下，就是<code>right - left &lt;= 2k</code>。这样一来，当我们把 input 数组排过序之后，我们就可以用滑动窗口了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumBeauty</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (nums[end] - nums[start] &gt; k * <span class="hljs-number">2</span>) &#123;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start + <span class="hljs-number">1</span>);<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// sliding window</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2958. Length of Longest Subarray With at Most K Frequency</title>
    <link href="/posts/3219240172.html"/>
    <url>/posts/3219240172.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and an integer k.</p><p>The frequency of an element x is the number of times it occurs in an array.</p><p>An array is called good if the frequency of each element in this array is less than or equal to k.</p><p>Return the length of the longest good subarray of nums.</p><p>A subarray is a contiguous non-empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,1,2,3,1,2], k &#x3D; 2<br>Output: 6<br>Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.<br>It can be shown that there are no good subarrays with length more than 6.</p><p>Example 2:<br>Input: nums &#x3D; [1,2,1,2,1,2,1,2], k &#x3D; 1<br>Output: 2<br>Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.<br>It can be shown that there are no good subarrays with length more than 2.</p><p>Example 3:<br>Input: nums &#x3D; [5,5,5,5,5,5,5], k &#x3D; 4<br>Output: 4<br>Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.<br>It can be shown that there are no good subarrays with length more than 4.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><p>最多 K 个重复元素的最长子数组。</p><blockquote><p>给你一个整数数组 nums 和一个整数 k 。</p><p>一个元素 x 在数组中的 频率 指的是它在数组中的出现次数。</p><p>如果一个数组中所有元素的频率都 小于等于 k ，那么我们称这个数组是 好 数组。</p><p>请你返回 nums 中 最长好 子数组的长度。</p><p>子数组 指的是一个数组中一段连续非空的元素序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路不难想到是滑动窗口，还是用类似 76 题的模板解决这道题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarrayLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> nums[end];<br>            map.put(num1, map.getOrDefault(num1, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            end++;<br>            <span class="hljs-keyword">while</span> (map.get(num1) &gt; k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> nums[start];<br>                map.put(num2, map.get(num2) - <span class="hljs-number">1</span>);<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2730. Find the Longest Semi-Repetitive Substring</title>
    <link href="/posts/4004168145.html"/>
    <url>/posts/4004168145.html</url>
    
    <content type="html"><![CDATA[<p>You are given a digit string s that consists of digits from 0 to 9.</p><p>A string is called semi-repetitive if there is at most one adjacent pair of the same digit. For example, “0010”, “002020”, “0123”, “2002”, and “54944” are semi-repetitive while the following are not: “00101022” (adjacent same digit pairs are 00 and 22), and “1101234883” (adjacent same digit pairs are 11 and 88).</p><p>Return the length of the longest semi-repetitive substring of s.</p><p>Example 1:<br>Input: s &#x3D; “52233”<br>Output: 4</p><p>Explanation:<br>The longest semi-repetitive substring is “5223”. Picking the whole string “52233” has two adjacent same digit pairs 22 and 33, but at most one is allowed.</p><p>Example 2:<br>Input: s &#x3D; “5494”<br>Output: 4</p><p>Explanation:<br>s is a semi-repetitive string.</p><p>Example 3:<br>Input: s &#x3D; “1111111”<br>Output: 2</p><p>Explanation:<br>The longest semi-repetitive substring is “11”. Picking the substring “111” has two adjacent same digit pairs, but at most one is allowed.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 50<br>‘0’ &lt;&#x3D; s[i] &lt;&#x3D; ‘9’</p><p>找到最长的半重复子字符串。</p><blockquote>给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。<p>如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串 t 是 半重复的 。例如，”0010” 、”002020” 、”0123” 、”2002” 和 “54944” 是半重复字符串，而 “00101022” （相邻的相同数字对是 00 和 22）和 “1101234883” （相邻的相同数字对是 11 和 88）不是半重复字符串。</p><p>请你返回 s 中最长 半重复子字符串的长度。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道可以用 76 题模板解决的滑动窗口题。思路没什么需要特别结实的，可直接参见代码。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSemiRepetitiveSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            nums[i] = c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">same</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[end] == nums[end - <span class="hljs-number">1</span>]) &#123;<br>                same++;<br>            &#125;<br>            end++;<br>            <span class="hljs-keyword">while</span> (same == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (nums[start] == nums[start - <span class="hljs-number">1</span>]) &#123;<br>                    same--;<br>                &#125;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2593. Find Score of an Array After Marking All Elements</title>
    <link href="/posts/433946550.html"/>
    <url>/posts/433946550.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array nums consisting of positive integers.</p><p>Starting with score &#x3D; 0, apply the following algorithm:</p><p>Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.</p><p>Add the value of the chosen integer to score.</p><p>Mark the chosen element and its two adjacent elements if they exist.</p><p>Repeat until all the array elements are marked.</p><p>Return the score you get after applying the above algorithm.</p><p>Example 1:<br>Input: nums &#x3D; [2,1,3,4,5,2]<br>Output: 7<br>Explanation: We mark the elements as follows:</p><ul><li>1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].</li><li>2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].</li><li>4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].<br>Our score is 1 + 2 + 4 &#x3D; 7.</li></ul><p>Example 2:<br>Input: nums &#x3D; [2,3,5,1,3,2]<br>Output: 5<br>Explanation: We mark the elements as follows:</p><ul><li>1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].</li><li>2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].</li><li>2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].<br>Our score is 1 + 2 + 2 &#x3D; 5.</li></ul><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 106</p><p>标记所有元素后数组的分数。</p><blockquote>给你一个数组 nums ，它包含若干正整数。<p>一开始分数 score &#x3D; 0 ，请你按照下面算法求出最后分数：</p><ul><li>从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。<br>将选中的整数加到 score 中。</li><li>标记 被选中元素，如果有相邻元素，则同时标记 与它相邻的两个元素 。</li><li>重复此过程直到数组中所有元素都被标记。</li></ul><p>请你返回执行上述算法后最后的分数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路就是模拟。这里我创建了一个二维数组，记录了原数组里的每个元素及其下标。然后我对这个二位数组排序，元素小的在前，元素相同的时候，下标小的在前。这样当我开始扫描这个二维数组的时候，首先遇到的是最小的元素而且他的下标也是最小的。同时我还需要一个和 input 数组等长的 Boolean 数组，记录每个下标是否被访问过。</p><p>开始遍历二维数组，如果当前位置没有被访问过，则把当前位置这个数字累加到 res 上，然后把他的左右邻居也标记成访问过。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(2n) ~ O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">findScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[][] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            numbers[i][<span class="hljs-number">0</span>] = nums[i];<br>            numbers[i][<span class="hljs-number">1</span>] = i;<br>        &#125;<br>        Arrays.sort(numbers, (a, b) -&gt; a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>] : a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] number : numbers) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> number[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> number[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (visited[index] == <span class="hljs-literal">false</span>) &#123;<br>                visited[index] = <span class="hljs-literal">true</span>;<br>                res += num;<br>                <span class="hljs-comment">// left</span><br>                <span class="hljs-keyword">if</span> (index - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                    visited[index - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// right</span><br>                <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; n) &#123;<br>                    visited[index + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>sort</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1297. Maximum Number of Occurrences of a Substring</title>
    <link href="/posts/2149090673.html"/>
    <url>/posts/2149090673.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s, return the maximum number of occurrences of any substring under the following rules:<br>The number of unique characters in the substring must be less than or equal to maxLetters.<br>The substring size must be between minSize and maxSize inclusive.</p><p>Example 1:<br>Input: s &#x3D; “aababcaab”, maxLetters &#x3D; 2, minSize &#x3D; 3, maxSize &#x3D; 4<br>Output: 2<br>Explanation: Substring “aab” has 2 occurrences in the original string.<br>It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).</p><p>Example 2:<br>Input: s &#x3D; “aaaa”, maxLetters &#x3D; 1, minSize &#x3D; 3, maxSize &#x3D; 3<br>Output: 2<br>Explanation: Substring “aaa” occur 2 times in the string. It can overlap.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>1 &lt;&#x3D; maxLetters &lt;&#x3D; 26<br>1 &lt;&#x3D; minSize &lt;&#x3D; maxSize &lt;&#x3D; min(26, s.length)<br>s consists of only lowercase English letters.</p><p>子串的最大出现次数。</p><blockquote>给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：<p>子串中不同字母的数目必须小于等于 maxLetters 。<br>子串的长度必须大于等于 minSize 且小于等于 maxSize 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是固定长度的滑动窗口。</p><p>这道题的难点在于需要明白题目的意思，如果完全明白题意，则题目会很简单。题目要我们找一个子串，满足两个条件：</p><ol><li>子串中不同字母的数目必须小于等于 maxLetters</li><li>子串的长度必须大于等于 minSize 且小于等于 maxSize</li></ol><p>第一个条件很好理解，如果我们能确定一个子串，那我们用 hashset 去看这个子串里有几个不同字母即可。</p><p>第二个条件很好理解但是不好判断，因为他需要子串长度介于 [minSize, maxSize] 之间。但是如果 minSize 和 maxSize 差距过大，找子串的工作的时间复杂度就会很高。但是这里仔细想想，因为找的是子串，那么如果你能找到一个出现次数为 X 的子串 A，那么 A 中的任意一个子串的出现次数也是 X。所以这里其实我们找的是一个长度为 minSize 的子串。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxFreq</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> maxLetters, <span class="hljs-type">int</span> minSize, <span class="hljs-type">int</span> maxSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> minSize;<br>        HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">0</span>, k);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (helper(first, maxLetters)) &#123;<br>            map.put(first, <span class="hljs-number">1</span>);<br>            res = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i + k &lt;= n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(i, i + k);<br>            <span class="hljs-keyword">if</span> (helper(str, maxLetters)) &#123;<br>                map.put(str, map.getOrDefault(str, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                res = Math.max(res, map.get(str));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> maxLetters)</span> &#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            set.add(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size() &lt;= maxLetters;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3111. Minimum Rectangles to Cover Points</title>
    <link href="/posts/972602496.html"/>
    <url>/posts/972602496.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D integer array points, where points[i] &#x3D; [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles.</p><p>Each rectangle has its lower end at some point (x1, 0) and its upper end at some point (x2, y2), where x1 &lt;&#x3D; x2, y2 &gt;&#x3D; 0, and the condition x2 - x1 &lt;&#x3D; w must be satisfied for each rectangle.</p><p>A point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.</p><p>Return an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle.</p><p>Note: A point may be covered by more than one rectangle.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-20-33-05.png" alt="Example 1"><br>Input: points &#x3D; [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w &#x3D; 1<br>Output: 2</p><p>Explanation:<br>The image above shows one possible placement of rectangles to cover the points:<br>A rectangle with a lower end at (1, 0) and its upper end at (2, 8)<br>A rectangle with a lower end at (3, 0) and its upper end at (4, 8)</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-18-59-12.png" alt="Example 2"><br>Input: points &#x3D; [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w &#x3D; 2<br>Output: 3</p><p>Explanation:<br>The image above shows one possible placement of rectangles to cover the points:<br>A rectangle with a lower end at (0, 0) and its upper end at (2, 2)<br>A rectangle with a lower end at (3, 0) and its upper end at (5, 5)<br>A rectangle with a lower end at (6, 0) and its upper end at (6, 6)</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-20-24-03.png" alt="Example 3"><br>Input: points &#x3D; [[2,3],[1,2]], w &#x3D; 0<br>Output: 2</p><p>Explanation:<br>The image above shows one possible placement of rectangles to cover the points:<br>A rectangle with a lower end at (1, 0) and its upper end at (1, 2)<br>A rectangle with a lower end at (2, 0) and its upper end at (2, 3)</p><p>Constraints:<br>1 &lt;&#x3D; points.length &lt;&#x3D; 105<br>points[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; xi &#x3D;&#x3D; points[i][0] &lt;&#x3D; 109<br>0 &lt;&#x3D; yi &#x3D;&#x3D; points[i][1] &lt;&#x3D; 109<br>0 &lt;&#x3D; w &lt;&#x3D; 109<br>All pairs (xi, yi) are distinct.</p><p>覆盖所有点的最少矩形数目。</p><blockquote>给你一个二维整数数组 point ，其中 points[i] = [xi, yi] 表示二维平面内的一个点。同时给你一个整数 w 。你需要用矩形 覆盖所有 点。<p>每个矩形的左下角在某个点 (x1, 0) 处，且右上角在某个点 (x2, y2) 处，其中 x1 &lt;&#x3D; x2 且 y2 &gt;&#x3D; 0 ，同时对于每个矩形都 必须 满足 x2 - x1 &lt;&#x3D; w 。</p><p>如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。</p><p>请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。</p><p>注意：一个点可以被多个矩形覆盖。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是对所有的点的<code>横坐标</code>排序。用矩形覆盖所有的点，因为不用考虑矩形的高度，所以只要考虑所有的点的横坐标即可。</p><p>排序过后我们来遍历所有的点的横坐标。如果挡板的<code>左端点 + 宽度 w</code> 够不到当前这个点的横坐标，则需要下一块板了；否则就遍历到下一个点，看挡板能否够得到下一个点。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minRectanglesToCoverPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points, <span class="hljs-type">int</span> w)</span> &#123;<br>        Arrays.sort(points, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length;<br><span class="hljs-comment">// 挡板的左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br><span class="hljs-comment">// 如果挡板的宽度够不到当前这个点的横坐标，则一定需要另一块板</span><br>            <span class="hljs-keyword">if</span> (bound + w &lt; points[i][<span class="hljs-number">0</span>]) &#123;<br>                count++;<br>                bound = points[i][<span class="hljs-number">0</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1524. Number of Sub-arrays With Odd Sum</title>
    <link href="/posts/3778862743.html"/>
    <url>/posts/3778862743.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers arr, return the number of subarrays with an odd sum.</p><p>Since the answer can be very large, return it modulo 109 + 7.</p><p>Example 1:<br>Input: arr &#x3D; [1,3,5]<br>Output: 4<br>Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]<br>All sub-arrays sum are [1,4,9,3,8,5].<br>Odd sums are [1,9,3,5] so the answer is 4.</p><p>Example 2:<br>Input: arr &#x3D; [2,4,6]<br>Output: 0<br>Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]<br>All sub-arrays sum are [2,6,12,4,10,6].<br>All sub-arrays have even sum and the answer is 0.</p><p>Example 3:<br>Input: arr &#x3D; [1,2,3,4,5,6,7]<br>Output: 16</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 100</p><p>和为奇数的子数组数目。</p><blockquote>给你一个整数数组 arr 。请你返回和为 奇数 的子数组数目。<p>由于答案可能会很大，请你将结果对 10^9 + 7 取余后返回。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。我们还是像一般的前缀和题目一样，创建一个 n + 1 的数组，记录数组的前缀和，记为 presum。</p><p>再创建两个变量，分别叫做 odd 和 even，代表 presum 中<code>前缀和是奇数</code>的个数和<code>前缀和是偶数</code>的个数。</p><p>遍历 presum 数组，对于每个位置 i，如果这个位置上的前缀和 presum[i] 是偶数，那么 even++；如果这个位置上的前缀和 presum[i] 是奇数，那么 odd++。</p><p>在对 presum[i] 判断奇偶的时候，如果 presum[i] 是偶数，那么我们看看在这个位置之前出现过几次奇数，把此时的 odd 累加到 res 上；如果 presum[i] 是奇数，那么我们看看在这个位置之前出现过几次偶数，把此时的 even 累加到 res 上。举个例子，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">0</span>, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>, j, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>, <span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><p>对于任意一段子数组 [j, i] 我们如何判断他的奇偶性呢？如果 [0, i] 这一段是偶数，如果想让 [j, i] 这一段为奇数，那么 [0, j] 这一段就必须要是奇数。因为奇数 + 奇数 &#x3D; 偶数。</p><p>同理，如果 [0, i] 这一段是奇数，如果想让 [j, i] 这一段为奇数，那么 [0, j] 这一段就必须要是偶数。因为偶数 + 奇数 &#x3D; 奇数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br><span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>presum[i + <span class="hljs-number">1</span>] = presum[i] + arr[i];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; presum.length; i++) &#123;<br><span class="hljs-keyword">if</span> (presum[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>res = (res + odd) % MOD;<br>even++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res = (res + even) % MOD;<br>odd++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3152. Special Array II</title>
    <link href="/posts/44766217.html"/>
    <url>/posts/44766217.html</url>
    
    <content type="html"><![CDATA[<p>An array is considered special if every pair of its adjacent elements contains two numbers with different parity.</p><p>You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] &#x3D; [fromi, toi] your task is to check that subarray nums[fromi..toi] is special or not.</p><p>Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.</p><p>Example 1:<br>Input: nums &#x3D; [3,4,1,2,6], queries &#x3D; [[0,4]]<br>Output: [false]</p><p>Explanation:<br>The subarray is [3,4,1,2,6]. 2 and 6 are both even.</p><p>Example 2:<br>Input: nums &#x3D; [4,3,1,6], queries &#x3D; [[0,2],[2,3]]<br>Output: [false,true]</p><p>Explanation:<br>The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false.<br>The subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; queries.length &lt;&#x3D; 105<br>queries[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; queries[i][0] &lt;&#x3D; queries[i][1] &lt;&#x3D; nums.length - 1</p><p>特殊数组 II。</p><blockquote>如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 特殊数组 。<p>你有一个整数数组 nums 和一个二维整数矩阵 queries，对于 queries[i] &#x3D; [fromi, toi]，请你帮助你检查子数组 nums[fromi..toi] 是不是一个 特殊数组 。</p><p>返回布尔数组 answer，如果 nums[fromi..toi] 是特殊数组，则 answer[i] 为 true ，否则，answer[i] 为 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。题目要我们判断的不是子数组的值，而是子数组内是否存在特殊数组。特殊数组的定义是如果子数组内<code>每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个特殊数组</code>。这道题利用前缀和的方式很巧妙，我们创建一个与 input 数组等长的前缀和数组，从 index &#x3D; 1 那个数字开始，如果当前数字 nums[i - 1] 和 nums[i] 奇偶性不同，则 presum[i] &#x3D; presum[i - 1] + 1，否则 presum[i] &#x3D; presum[i - 1]。这里 <code>+ 1</code> 的用意是当我们用前缀和去看某一段子数组的值的时候，如果这一段子数组的值大于 0，则说明这一段里肯定有奇偶性不同的数字出现；如果这一段子数组的值 &#x3D;&#x3D; 0，则说明这一段里没有奇偶性不同的数字出现。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span>[] isArraySpecial(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            presum[i] = presum[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (helper(nums[i], nums[i - <span class="hljs-number">1</span>])) &#123;<br>                presum[i]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[queries.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">1</span>];<br>            res[i] = presum[left] == presum[right];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a % <span class="hljs-number">2</span> == b % <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2684. Maximum Number of Moves in a Grid</title>
    <link href="/posts/88784918.html"/>
    <url>/posts/88784918.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed m x n matrix grid consisting of positive integers.</p><p>You can start at any cell in the first column of the matrix, and traverse the grid in the following way:</p><p>From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.<br>Return the maximum number of moves that you can perform.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png" alt="Example 1"><br>Input: grid &#x3D; [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]<br>Output: 3<br>Explanation: We can start at the cell (0, 0) and make the following moves:</p><ul><li>(0, 0) -&gt; (0, 1).</li><li>(0, 1) -&gt; (1, 2).</li><li>(1, 2) -&gt; (2, 3).<br>It can be shown that it is the maximum number of moves that can be made.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png" alt="Example 2"><br>Input: grid &#x3D; [[3,2,4],[2,1,9],[1,1,7]]<br>Output: 0<br>Explanation: Starting from any cell in the first column we cannot perform any moves.</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>2 &lt;&#x3D; m, n &lt;&#x3D; 1000<br>4 &lt;&#x3D; m * n &lt;&#x3D; 105<br>1 &lt;&#x3D; grid[i][j] &lt;&#x3D; 106</p><p>矩阵中移动的最大次数。</p><blockquote>给你一个下标从 0 开始、大小为 m x n 的矩阵 grid ，矩阵由若干 正 整数组成。<p>你可以从矩阵第一列中的 任一 单元格出发，按以下方式遍历 grid ：<br>从单元格 (row, col) 可以移动到 (row - 1, col + 1)、(row, col + 1) 和 (row + 1, col + 1) 三个单元格中任一满足值 严格 大于当前单元格的单元格。</p><p>返回你在矩阵中能够 移动 的 最大 次数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，从第一列的任意一个格子出发，看看从左往右最远能走<code>几步</code>。对于某个格子<code>(i, j)</code>来说，他只需要去看这三个格子<code>(i-1, j+1)</code>、<code>(i, j+1)</code>、<code>(i+1, j+1)</code>中的的值是否比自己大，从而决定到底要不要往那个格子走，所以这道题并不是暴力尝试所有的路径。</p><p>这里我仍然用 DFS 来做这道题。做的时候，对于<code>(i, j)</code>，如果这三个格子<code>(i-1, j+1)</code>、<code>(i, j+1)</code>、<code>(i+1, j+1)</code>中的的值比<code>(i, j)</code>大，我们才走过去，否则就不要走过去。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxMoves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>m = grid.length;<br>n = grid[<span class="hljs-number">0</span>].length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>dfs(grid, i, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>count = Math.max(count, j);<br><span class="hljs-keyword">if</span> (count == n - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.max(i - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); k &lt;= Math.min(i + <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>); k++) &#123;<br><span class="hljs-keyword">if</span> (grid[k][j + <span class="hljs-number">1</span>] &gt; grid[i][j]) &#123;<br>dfs(grid, k, j + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>grid[i][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">// backtrack</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2825. Make String a Subsequence Using Cyclic Increments</title>
    <link href="/posts/1899303866.html"/>
    <url>/posts/1899303866.html</url>
    
    <content type="html"><![CDATA[<p>You are given two 0-indexed strings str1 and str2.</p><p>In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is ‘a’ becomes ‘b’, ‘b’ becomes ‘c’, and so on, and ‘z’ becomes ‘a’.</p><p>Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise.</p><p>Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.</p><p>Example 1:<br>Input: str1 &#x3D; “abc”, str2 &#x3D; “ad”<br>Output: true<br>Explanation: Select index 2 in str1.<br>Increment str1[2] to become ‘d’.<br>Hence, str1 becomes “abd” and str2 is now a subsequence. Therefore, true is returned.</p><p>Example 2:<br>Input: str1 &#x3D; “zc”, str2 &#x3D; “ad”<br>Output: true<br>Explanation: Select indices 0 and 1 in str1.<br>Increment str1[0] to become ‘a’.<br>Increment str1[1] to become ‘d’.<br>Hence, str1 becomes “ad” and str2 is now a subsequence. Therefore, true is returned.</p><p>Example 3:<br>Input: str1 &#x3D; “ab”, str2 &#x3D; “d”<br>Output: false<br>Explanation: In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once.<br>Therefore, false is returned.</p><p>Constraints:<br>1 &lt;&#x3D; str1.length &lt;&#x3D; 105<br>1 &lt;&#x3D; str2.length &lt;&#x3D; 105<br>str1 and str2 consist of only lowercase English letters.</p><p>循环增长使字符串子序列等于另一个字符串。</p><blockquote>给你一个下标从 0 开始的字符串 str1 和 str2 。<p>一次操作中，你选择 str1 中的若干下标。对于选中的每一个下标 i ，你将 str1[i] 循环 递增，变成下一个字符。也就是说 ‘a’ 变成 ‘b’ ，’b’ 变成 ‘c’ ，以此类推，’z’ 变成 ‘a’ 。</p><p>如果执行以上操作 至多一次 ，可以让 str2 成为 str1 的子序列，请你返回 true ，否则返回 false 。</p><p>注意：一个字符串的子序列指的是从原字符串中删除一些（可以一个字符也不删）字符后，剩下字符按照原本先后顺序组成的新字符串。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是同向双指针，一个指针指向 str1，一个指针指向 str2。如果str1[i] &#x3D;&#x3D; str2[j]，则 i 和 j 同时向后移动，直到 str1[i]!&#x3D; str2[j]。当 str1[i]!&#x3D; str2[j] 的时候，因为题目只允许我们修改 str1 中的字符，所以我们只能移动 i 指针，判断他是否能和 str2[j] 相等。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canMakeSubsequence</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> str1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str2.length();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> str1.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> str2.charAt(j);<br>            <span class="hljs-keyword">if</span> (a == b || (a + <span class="hljs-number">1</span> - <span class="hljs-string">&#x27;a&#x27;</span>) % <span class="hljs-number">26</span> == b - <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3206. Alternating Groups I</title>
    <link href="/posts/2490180647.html"/>
    <url>/posts/2490180647.html</url>
    
    <content type="html"><![CDATA[<p>There is a circle of red and blue tiles. You are given an array of integers colors. The color of tile i is represented by colors[i]:<br>colors[i] &#x3D;&#x3D; 0 means that tile i is red.<br>colors[i] &#x3D;&#x3D; 1 means that tile i is blue.<br>Every 3 contiguous tiles in the circle with alternating colors (the middle tile has a different color from its left and right tiles) is called an alternating group.</p><p>Return the number of alternating groups.</p><p>Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.</p><p>Example 1:<br>Input: colors &#x3D; [1,1,1]<br>Output: 0<br>Explanation:<br><img src="https://assets.leetcode.com/uploads/2024/05/16/image_2024-05-16_23-53-171.png" alt="Example 1"></p><p>Example 2:<br>Input: colors &#x3D; [0,1,0,0,1]<br>Output: 3<br>Explanation:<br><img src="https://assets.leetcode.com/uploads/2024/05/16/image_2024-05-16_23-47-491.png" alt="Example 2"></p><p>Alternating groups:<br><img src="https://assets.leetcode.com/uploads/2024/05/16/image_2024-05-16_23-50-441.png" alt="Example 2"><br><img src="https://assets.leetcode.com/uploads/2024/05/16/image_2024-05-16_23-48-211.png" alt="Example 2"><br><img src="https://assets.leetcode.com/uploads/2024/05/16/image_2024-05-16_23-49-351.png" alt="Example 2"></p><p>Constraints:<br>3 &lt;&#x3D; colors.length &lt;&#x3D; 100<br>0 &lt;&#x3D; colors[i] &lt;&#x3D; 1</p><p>交替组 I。</p><blockquote>给你一个整数数组 colors ，它表示一个由红色和蓝色瓷砖组成的环，第 i 块瓷砖的颜色为 colors[i] ：<p>colors[i] &#x3D;&#x3D; 0 表示第 i 块瓷砖的颜色是 红色 。<br>colors[i] &#x3D;&#x3D; 1 表示第 i 块瓷砖的颜色是 蓝色 。</p><p>环中连续 3 块瓷砖的颜色如果是 交替 颜色（也就是说中间瓷砖的颜色与它 左边 和 右边 的颜色都不同），那么它被称为一个 交替 组。</p><p>请你返回 交替 组的数目。</p><p>注意 ，由于 colors 表示一个 环 ，第一块 瓷砖和 最后一块 瓷砖是相邻的。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题目其实是让你看一个长度为 3 的窗口里面元素的情况。不过这道题我们只需要考虑窗口内的 3 个元素是否是交替的即可。记得遍历到最后的时候下标要取模。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfAlternatingGroups</span><span class="hljs-params">(<span class="hljs-type">int</span>[] colors)</span> &#123;<br>        n = colors.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (helper(colors, i)) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] colors, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> colors[index % n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> colors[(index + <span class="hljs-number">1</span>) % n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">third</span> <span class="hljs-operator">=</span> colors[(index + <span class="hljs-number">2</span>) % n];<br>        <span class="hljs-keyword">if</span> (first != second &amp;&amp; second != third) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1861. Rotating the Box</title>
    <link href="/posts/1849115886.html"/>
    <url>/posts/1849115886.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:<br>A stone ‘#’<br>A stationary obstacle ‘*’<br>Empty ‘.’</p><p>The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles’ positions, and the inertia from the box’s rotation does not affect the stones’ horizontal positions.</p><p>It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.</p><p>Return an n x m matrix representing the box after the rotation described above.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png" alt="Example 1"><br>Input: box &#x3D; [[“#”,”.”,”#”]]<br>Output: [[“.”],<br>         [“#”],<br>         [“#”]]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png" alt="Example 2"><br>Input: box &#x3D; [[“#”,”.”,”<em>“,”.”],<br>              [“#”,”#”,”</em>“,”.”]]<br>Output: [[“#”,”.”],<br>         [“#”,”#”],<br>         [“<em>“,”</em>“],<br>         [“.”,”.”]]</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png" alt="Example 3"><br>Input: box &#x3D; [[“#”,”#”,”<em>“,”.”,”</em>“,”.”],<br>              [“#”,”#”,”#”,”<em>“,”.”,”.”],<br>              [“#”,”#”,”#”,”.”,”#”,”.”]]<br>Output: [[“.”,”#”,”#”],<br>         [“.”,”#”,”#”],<br>         [“#”,”#”,”</em>“],<br>         [“#”,”<em>“,”.”],<br>         [“#”,”.”,”</em>“],<br>         [“#”,”.”,”.”]]</p><p>Constraints:<br>m &#x3D;&#x3D; box.length<br>n &#x3D;&#x3D; box[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 500<br>box[i][j] is either ‘#’, ‘*’, or ‘.’.</p><p>旋转盒子。</p><blockquote>给你一个 m x n 的字符矩阵 box ，它表示一个箱子的侧视图。箱子的每一个格子可能为：<p>‘#’ 表示石头<br>‘*’ 表示固定的障碍物<br>‘.’ 表示空位置</p><p>这个箱子被 顺时针旋转 90 度 ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 不会 影响障碍物的位置，同时箱子旋转不会产生惯性 ，也就是说石头的水平位置不会发生改变。</p><p>题目保证初始时 box 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。</p><p>请你返回一个 n x m的矩阵，表示按照上述旋转后，箱子内的结果。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考察的是双指针和对矩阵的转换。<br>对于 input 矩阵的每一行，我们需要从右往左看，，在跳过障碍物的前提下，尽量把石头往右边摆放。<br>对于<code>顺时针旋转 90 度</code>这个环节，考察的是我们对矩阵坐标转换的熟悉程度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1) - 除output外不需要额外空间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[][] rotateTheBox(<span class="hljs-type">char</span>[][] box) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> box.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> box[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (box[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    box[i][pos] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>                    <span class="hljs-keyword">if</span> (j != pos) &#123;<br>                        box[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                    pos--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (box[i][j] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    pos = j - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[j][m - <span class="hljs-number">1</span> - i] = box[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3238. Find the Number of Winning Players</title>
    <link href="/posts/364551423.html"/>
    <url>/posts/364551423.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer n representing the number of players in a game and a 2D array pick where pick[i] &#x3D; [xi, yi] represents that the player x picked a ball of color y.</p><p>Player i wins the game if they pick strictly more than i balls of the same color. In other words,</p><p>Player 0 wins if they pick any ball.<br>Player 1 wins if they pick at least two balls of the same color.<br>…<br>Player i wins if they pick at least i + 1 balls of the same color.<br>Return the number of players who win the game.</p><p>Note that multiple players can win the game.</p><p>Example 1:<br>Input: n &#x3D; 4, pick &#x3D; [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]]<br>Output: 2</p><p>Explanation:<br>Player 0 and player 1 win the game, while players 2 and 3 do not win.</p><p>Example 2:<br>Input: n &#x3D; 5, pick &#x3D; [[1,1],[1,2],[1,3],[1,4]]<br>Output: 0</p><p>Explanation:<br>No player wins the game.</p><p>Example 3:<br>Input: n &#x3D; 5, pick &#x3D; [[1,1],[2,4],[2,4],[2,4]]<br>Output: 1</p><p>Explanation:<br>Player 2 wins the game by picking 3 balls with color 4.</p><p>Constraints:<br>2 &lt;&#x3D; n &lt;&#x3D; 10<br>1 &lt;&#x3D; pick.length &lt;&#x3D; 100<br>pick[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; xi &lt;&#x3D; n - 1<br>0 &lt;&#x3D; yi &lt;&#x3D; 10</p><p>求出胜利玩家的数目。</p><blockquote>给你一个整数 n ，表示在一个游戏中的玩家数目。同时给你一个二维整数数组 pick ，其中 pick[i] = [xi, yi] 表示玩家 xi 获得了一个颜色为 yi 的球。<p>如果玩家 i 获得的球中任何一种颜色球的数目 严格大于 i 个，那么我们说玩家 i 是胜利玩家。换句话说：</p><p>如果玩家 0 获得了任何的球，那么玩家 0 是胜利玩家。<br>如果玩家 1 获得了至少 2 个相同颜色的球，那么玩家 1 是胜利玩家。<br>…<br>如果玩家 i 获得了至少 i + 1 个相同颜色的球，那么玩家 i 是胜利玩家。<br>请你返回游戏中 胜利玩家 的数目。</p><p>注意，可能有多个玩家是胜利玩家。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路是统计&#x2F;counting sort。因为玩家有 n 个，球的颜色至多有 10 种，所以这里我创建一个二维数组记录过程中每个玩家拿到的不同颜色的球的数量。这里我同时创建了一个 boolean 数组记录每个玩家是否胜利，如果某个玩家已经胜利了，他之后拿再多的球都不要再重复计算了。当然这里也可以扫描两次，第一次先把二维数组里球的数量统计完毕，再次扫描二维数组，看玩家是否满足胜利条件。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(nm) - n个玩家，m种颜色的球</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">winningPlayerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] pick)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">11</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : pick) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> p[<span class="hljs-number">1</span>];<br>            map[player][color]++;<br>            <span class="hljs-keyword">if</span> (map[player][color] &gt; player &amp;&amp; !win[player]) &#123;<br>                res++;<br>                win[player] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>counting sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2257. Count Unguarded Cells in the Grid</title>
    <link href="/posts/342961845.html"/>
    <url>/posts/342961845.html</url>
    
    <content type="html"><![CDATA[<p>You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] &#x3D; [rowi, coli] and walls[j] &#x3D; [rowj, colj] represent the positions of the ith guard and jth wall respectively.</p><p>A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.</p><p>Return the number of unoccupied cells that are not guarded.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png" alt="Example 1"><br>Input: m &#x3D; 4, n &#x3D; 6, guards &#x3D; [[0,0],[1,1],[2,3]], walls &#x3D; [[0,1],[2,2],[1,4]]<br>Output: 7<br>Explanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.<br>There are a total of 7 unguarded cells, so we return 7.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png" alt="Example 2"><br>Input: m &#x3D; 3, n &#x3D; 3, guards &#x3D; [[1,1]], walls &#x3D; [[0,1],[1,0],[2,1],[1,2]]<br>Output: 4<br>Explanation: The unguarded cells are shown in green in the above diagram.<br>There are a total of 4 unguarded cells, so we return 4.</p><p>Constraints:<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>2 &lt;&#x3D; m * n &lt;&#x3D; 105<br>1 &lt;&#x3D; guards.length, walls.length &lt;&#x3D; 5 * 104<br>2 &lt;&#x3D; guards.length + walls.length &lt;&#x3D; m * n<br>guards[i].length &#x3D;&#x3D; walls[j].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; rowi, rowj &lt; m<br>0 &lt;&#x3D; coli, colj &lt; n<br>All the positions in guards and walls are unique.</p><p>统计网格图中没有被保卫的格子数。</p><blockquote>给你两个整数 m 和 n 表示一个下标从 0 开始的 m x n 网格图。同时给你两个二维整数数组 guards 和 walls ，其中 guards[i] = [rowi, coli] 且 walls[j] = [rowj, colj] ，分别表示第 i 个警卫和第 j 座墙所在的位置。<p>一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 所有 格子，除非他们被一座墙或者另外一个警卫 挡住 了视线。如果一个格子能被 至少 一个警卫看到，那么我们说这个格子被 保卫 了。</p><p>请你返回空格子中，有多少个格子是 没被保卫 的。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要创建一个额外的 m x n 二维数组，用来记录每个格子上是否有守卫，是否有墙和是否有被警卫看到，如果都不是，则说明这个格子是<code>没被保卫的</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countUnguarded</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] guards, <span class="hljs-type">int</span>[][] walls)</span> &#123;<br>        <span class="hljs-type">char</span>[][] grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m][n];<br><span class="hljs-comment">// 标注guard和wall的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] g : guards) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> g[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> g[<span class="hljs-number">1</span>];<br>            grid[x][y] = <span class="hljs-string">&#x27;G&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] w : walls) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> w[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> w[<span class="hljs-number">1</span>];<br>            grid[x][y] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-comment">// 往guard的四个方向看</span><br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;G&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j + dir[<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] != <span class="hljs-string">&#x27;G&#x27;</span> &amp;&amp; grid[x][y] != <span class="hljs-string">&#x27;W&#x27;</span>) &#123;<br>                            grid[x][y] = <span class="hljs-string">&#x27;I&#x27;</span>;<br>                            x += dir[<span class="hljs-number">0</span>];<br>                            y += dir[<span class="hljs-number">1</span>];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-string">&#x27;I&#x27;</span> &amp;&amp; grid[i][j] != <span class="hljs-string">&#x27;G&#x27;</span> &amp;&amp; grid[i][j] != <span class="hljs-string">&#x27;W&#x27;</span>) &#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>flood fill</tag>
      
      <tag>matrix</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2516. Take K of Each Character From Left and Right</title>
    <link href="/posts/976364709.html"/>
    <url>/posts/976364709.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s consisting of the characters ‘a’, ‘b’, and ‘c’ and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.</p><p>Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.</p><p>Example 1:<br>Input: s &#x3D; “aabaaaacaabc”, k &#x3D; 2<br>Output: 8<br>Explanation:<br>Take three characters from the left of s. You now have two ‘a’ characters, and one ‘b’ character.<br>Take five characters from the right of s. You now have four ‘a’ characters, two ‘b’ characters, and two ‘c’ characters.<br>A total of 3 + 5 &#x3D; 8 minutes is needed.<br>It can be proven that 8 is the minimum number of minutes needed.</p><p>Example 2:<br>Input: s &#x3D; “a”, k &#x3D; 1<br>Output: -1<br>Explanation: It is not possible to take one ‘b’ or ‘c’ so return -1.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of only the letters ‘a’, ‘b’, and ‘c’.<br>0 &lt;&#x3D; k &lt;&#x3D; s.length</p><p>每种字符至少取 K 个。</p><blockquote>给你一个由字符 'a'、'b'、'c' 组成的字符串 s 和一个非负整数 k 。每分钟，你可以选择取走 s 最左侧 还是 最右侧 的那个字符。<p>你必须取走每种字符 至少 k 个，返回需要的 最少 分钟数；如果无法取到，则返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口。这道题要求我们只能从 input 两侧拿字母，那么 s 的中间部分就是连续的，所以这里我们可以用滑动窗口。</p><p>首先我们统计一下 s 中原来有的 a, b, c 三种字符的个数分别有多少。一个需要排除的 corner case 是如果这三个字母有任何一个字母的出现次数已经不足 k 了，则直接返回 -1。</p><p>接着我们可以开始用滑动窗口的模板遍历 input 数组了。end 指针往右边走的时候，start 和 end 中间包含的字母数量是越多的，那么此时我们可以把 start 和 end 组成的这个窗口理解为留下的字母个数。那么不包含在这个窗口内的字母就是从 input 字符串两侧被移除的字母。此时如果有任何一个字母被移除的次数大于等于 k（反之就是在窗口内的个数小于 k）的时候，我们就要移动 start 指针。</p><p>注意这道题我们要找一个尽可能大的窗口，以为题目求的是一个尽可能小的分钟数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">takeCharacters</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map[i] &lt; k) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            map[c1 - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            end++;<br><span class="hljs-comment">// 窗口外的字母不足k个，就要移动左指针了</span><br>            <span class="hljs-keyword">while</span> (map[c1 - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; k) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1652. Defuse the Bomb</title>
    <link href="/posts/1189791235.html"/>
    <url>/posts/1189791235.html</url>
    
    <content type="html"><![CDATA[<p>You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.</p><p>To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.</p><p>If k &gt; 0, replace the ith number with the sum of the next k numbers.<br>If k &lt; 0, replace the ith number with the sum of the previous k numbers.<br>If k &#x3D;&#x3D; 0, replace the ith number with 0.<br>As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].</p><p>Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!</p><p>Example 1:<br>Input: code &#x3D; [5,7,1,4], k &#x3D; 3<br>Output: [12,10,16,13]<br>Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.</p><p>Example 2:<br>Input: code &#x3D; [1,2,3,4], k &#x3D; 0<br>Output: [0,0,0,0]<br>Explanation: When k is zero, the numbers are replaced by 0. </p><p>Example 3:<br>Input: code &#x3D; [2,4,9,3], k &#x3D; -2<br>Output: [12,5,6,13]<br>Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.</p><p>Constraints:<br>n &#x3D;&#x3D; code.length<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; code[i] &lt;&#x3D; 100<br>-(n - 1) &lt;&#x3D; k &lt;&#x3D; n - 1</p><p>拆炸弹。</p><blockquote>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。<br>如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。<br>如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。<br>如果 k &#x3D;&#x3D; 0 ，将第 i 个数字用 0 替换。<br>由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。</p><p>给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，暴力解就是当遍历到每个 index <code>i</code> 的时候，往他的左边或者右边（取决于 k 是正的还是负的）看 k 个数字然后把这 k 个数字的和计算出来。这个做法的复杂度是O(n * k)。</p><p>这里我提供一个更优的解法，思路是滑动窗口，而且是长度固定的滑动窗口。注意这里的一个 corner case 是如果 k &#x3D; 0，直接返回一个和 input 数组长度相等的数组，里面全填 0 即可。对于一般的 case，如果 k &gt; 0，那么从第一个下标 i &#x3D; 0 开始，就看 [left, right] 这一段子数组的和是多少，其中 left &#x3D; i + 1, right &#x3D; i + k - 1。注意如果 right 超过数组本身长度 n 的话，要取模。</p><p>如果 k &lt; 0，也是从第一个下标 i &#x3D; 0 开始，看他左侧 k 个数字的和是多少，注意 left 和 right 是怎么取到的。</p><p>但是因为 left 和 right 之间的距离就是 k，所以这道题的大致思路是定长的滑动窗口。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] decrypt(<span class="hljs-type">int</span>[] code, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> code.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + k - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// initial</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                sum += code[i];<br>            &#125;<br>            res[<span class="hljs-number">0</span>] = sum;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; res.length; i++) &#123;<br>                right = (right + <span class="hljs-number">1</span>) % n;<br>                sum += code[right];<br>                sum -= code[left];<br>                left = (left + <span class="hljs-number">1</span>) % n;<br>                res[i] = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> n + k;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// initial</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                sum += code[i];<br>            &#125;<br>            res[<span class="hljs-number">0</span>] = sum;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; res.length; i++) &#123;<br>                sum -= code[left];<br>                left = (left + <span class="hljs-number">1</span>) % n;<br>                right = (right + <span class="hljs-number">1</span>) % n;<br>                sum += code[right];<br>                res[i] = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 661. Image Smoother</title>
    <link href="/posts/1902463511.html"/>
    <url>/posts/1902463511.html</url>
    
    <content type="html"><![CDATA[<p>An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).<br><img src="https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg" alt="Image"></p><p>Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg" alt="Example 1"><br>Input: img &#x3D; [[1,1,1],[1,0,1],[1,1,1]]<br>Output: [[0,0,0],[0,0,0],[0,0,0]]<br>Explanation:<br>For the points (0,0), (0,2), (2,0), (2,2): floor(3&#x2F;4) &#x3D; floor(0.75) &#x3D; 0<br>For the points (0,1), (1,0), (1,2), (2,1): floor(5&#x2F;6) &#x3D; floor(0.83333333) &#x3D; 0<br>For the point (1,1): floor(8&#x2F;9) &#x3D; floor(0.88888889) &#x3D; 0</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg" alt="Example 2"><br>Input: img &#x3D; [[100,200,100],[200,50,200],[100,200,100]]<br>Output: [[137,141,137],[141,138,141],[137,141,137]]<br>Explanation:<br>For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)&#x2F;4) &#x3D; floor(137.5) &#x3D; 137<br>For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)&#x2F;6) &#x3D; floor(141.666667) &#x3D; 141<br>For the point (1,1): floor((50+200+200+200+200+100+100+100+100)&#x2F;9) &#x3D; floor(138.888889) &#x3D; 138</p><p>Constraints:<br>m &#x3D;&#x3D; img.length<br>n &#x3D;&#x3D; img[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; img[i][j] &lt;&#x3D; 255</p><p>图片平滑器。</p><blockquote>图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。<p>每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。</p><p>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及算法，就是二维矩阵的遍历。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] imageSmoother(<span class="hljs-type">int</span>[][] img) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> img.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> img[<span class="hljs-number">0</span>].length;<br><span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> helper(img, i, j);<br>res[i][j] = cur;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] img, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; x &lt;= i + <span class="hljs-number">1</span>; x++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j - <span class="hljs-number">1</span>; y &lt;= j + <span class="hljs-number">1</span>; y++) &#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; img.length &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; img[<span class="hljs-number">0</span>].length) &#123;<br>sum += img[x][y];<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum / count;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 911. Online Election</title>
    <link href="/posts/730347545.html"/>
    <url>/posts/730347545.html</url>
    
    <content type="html"><![CDATA[<p>You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].</p><p>For each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.</p><p>Implement the TopVotedCandidate class:</p><p>TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.<br>int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.</p><p>Example 1:<br>Input<br>[“TopVotedCandidate”, “q”, “q”, “q”, “q”, “q”, “q”]<br>[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]<br>Output<br>[null, 0, 1, 1, 0, 0, 1]</p><p>Explanation<br>TopVotedCandidate topVotedCandidate &#x3D; new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);<br>topVotedCandidate.q(3); &#x2F;&#x2F; return 0, At time 3, the votes are [0], and 0 is leading.<br>topVotedCandidate.q(12); &#x2F;&#x2F; return 1, At time 12, the votes are [0,1,1], and 1 is leading.<br>topVotedCandidate.q(25); &#x2F;&#x2F; return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)<br>topVotedCandidate.q(15); &#x2F;&#x2F; return 0<br>topVotedCandidate.q(24); &#x2F;&#x2F; return 0<br>topVotedCandidate.q(8); &#x2F;&#x2F; return 1</p><p>Constraints:<br>1 &lt;&#x3D; persons.length &lt;&#x3D; 5000<br>times.length &#x3D;&#x3D; persons.length<br>0 &lt;&#x3D; persons[i] &lt; persons.length<br>0 &lt;&#x3D; times[i] &lt;&#x3D; 109<br>times is sorted in a strictly increasing order.<br>times[0] &lt;&#x3D; t &lt;&#x3D; 109<br>At most 104 calls will be made to q.</p><p>在线选举。</p><blockquote>给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。<p>对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。</p><p>在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p><p>实现 TopVotedCandidate 类：<br>TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。<br>int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道设计题。这里我重新解释一下题意。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的，这个部分应该没有歧义。但是接下来，对于发生在时刻 t 的每个查询，请注意这个时刻 t 未必跟投票的时刻是能对的上的。比如题目给的例子，如下是分别在时间点 0, 5, 10, 15, 20, 25, 30 时给不同的 candidate 投票的情况。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0, 1, 1, 0, 0, 1, 0]</span><br><span class="hljs-string">[0, 5, 10, 15, 20, 25, 30]</span><br></code></pre></td></tr></table></figure><p>但是查询的时刻 t 则分别发生在 3, 12, 25, 15, 24, 8 这几个时刻。</p><p>存投票的结果这部分不难，这道题难在如何高效地查询。思路是二分法。存投票这个动作，我们需要一个 hashmap 和一个 list。其中 hashmap 存的是每个 candidate 和他们各自对应的票数。list 里存的是int[] { time, leadingPerson }，意思是在每当有一个人投票之后，我们就看一下当前这次投票结束之后领先的候选人是谁，把这个信息存到 list 里。</p><p>因为投票的时刻 time 是有序的，所以 list 里的元素也是按 time 有序的。所以当我们查询的时候就可以用二分法了，这里相当于是在一个有序的数组里找一个<code>最大的小于等于 t 的元素</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopVotedCandidate</span> &#123;<br>List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TopVotedCandidate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] persons, <span class="hljs-type">int</span>[] times)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> persons.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> persons[i];<br><span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> times[i];<br>map.put(person, map.getOrDefault(person, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (map.get(person) &gt;= max) &#123;<br>max = map.get(person);<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;time, person&#125;);<br>&#125;<br>&#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">q</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (list.get(mid)[<span class="hljs-number">0</span>] == t) &#123;<br>                <span class="hljs-keyword">return</span> list.get(mid)[<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.get(mid)[<span class="hljs-number">0</span>] &gt; t) &#123;<br>right = mid;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;<br>            &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (list.get(right)[<span class="hljs-number">0</span>] &lt;= t) &#123;<br><span class="hljs-keyword">return</span> list.get(right)[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> list.get(left)[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TopVotedCandidate object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TopVotedCandidate obj = new TopVotedCandidate(persons, times);</span><br><span class="hljs-comment"> * int param_1 = obj.q(t);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>binary search</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1146. Snapshot Array</title>
    <link href="/posts/2894172629.html"/>
    <url>/posts/2894172629.html</url>
    
    <content type="html"><![CDATA[<p>Implement a SnapshotArray that supports the following interface:<br>SnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0.<br>void set(index, val) sets the element at the given index to be equal to val.<br>int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.<br>int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id</p><p>Example 1:<br>Input: [“SnapshotArray”,”set”,”snap”,”set”,”get”]<br>[[3],[0,5],[],[0,6],[0,0]]<br>Output: [null,null,0,null,5]<br>Explanation:<br>SnapshotArray snapshotArr &#x3D; new SnapshotArray(3); &#x2F;&#x2F; set the length to be 3<br>snapshotArr.set(0,5);  &#x2F;&#x2F; Set array[0] &#x3D; 5<br>snapshotArr.snap();  &#x2F;&#x2F; Take a snapshot, return snap_id &#x3D; 0<br>snapshotArr.set(0,6);<br>snapshotArr.get(0,0);  &#x2F;&#x2F; Get the value of array[0] with snap_id &#x3D; 0, return 5</p><p>Constraints:<br>1 &lt;&#x3D; length &lt;&#x3D; 5 * 104<br>0 &lt;&#x3D; index &lt; length<br>0 &lt;&#x3D; val &lt;&#x3D; 109<br>0 &lt;&#x3D; snap_id &lt; (the total number of times we call snap())<br>At most 5 * 104 calls will be made to set, snap, and get.</p><p>快照数组。</p><blockquote>实现支持下列接口的「快照数组」- SnapshotArray：<p>SnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。</p><p>void set(index, val) - 会将指定索引 index 处的元素设置为 val。</p><p>int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。</p><p>int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>创建一个 hashmap <code>&lt;Integer, TreeMap&lt;Integer, Integer&gt;&gt; map</code>，其中 hashmap 的 key 是数组的下标 index，treemap 里存的是<code>&lt;timestamp, value&gt;</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：初始化O(n), set() - O(logn), get() - O(1), 整体O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotArray</span> &#123;<br>    <span class="hljs-type">int</span> snapId;<br>    <span class="hljs-comment">// &lt;index, &lt;snapId, value&gt;&gt;</span><br>    HashMap&lt;Integer, TreeMap&lt;Integer, Integer&gt;&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SnapshotArray</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            map.put(i, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;());<br>            map.get(i).put(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        snapId = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        TreeMap&lt;Integer, Integer&gt; tmap = map.get(index);<br>        <span class="hljs-keyword">if</span> (tmap == <span class="hljs-literal">null</span>) &#123;<br>            tmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>            tmap.put(snapId, val);<br>            map.put(index, tmap);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.get(index).put(snapId, val);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">snap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> snapId++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> snap_id)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.get(index).floorEntry(snap_id).getValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your SnapshotArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * SnapshotArray obj = new SnapshotArray(length);</span><br><span class="hljs-comment"> * obj.set(index,val);</span><br><span class="hljs-comment"> * int param_2 = obj.snap();</span><br><span class="hljs-comment"> * int param_3 = obj.get(index,snap_id);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>treemap</tag>
      
      <tag>binary search</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2080. Range Frequency Queries</title>
    <link href="/posts/2674324247.html"/>
    <url>/posts/2674324247.html</url>
    
    <content type="html"><![CDATA[<p>Design a data structure to find the frequency of a given value in a given subarray.</p><p>The frequency of a value in a subarray is the number of occurrences of that value in the subarray.</p><p>Implement the RangeFreqQuery class:<br>RangeFreqQuery(int[] arr) Constructs an instance of the class with the given 0-indexed integer array arr.<br>int query(int left, int right, int value) Returns the frequency of value in the subarray arr[left…right].<br>A subarray is a contiguous sequence of elements within an array. arr[left…right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).</p><p>Example 1:<br>Input<br>[“RangeFreqQuery”, “query”, “query”]<br>[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]<br>Output<br>[null, 1, 2]</p><p>Explanation<br>RangeFreqQuery rangeFreqQuery &#x3D; new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);<br>rangeFreqQuery.query(1, 2, 4); &#x2F;&#x2F; return 1. The value 4 occurs 1 time in the subarray [33, 4]<br>rangeFreqQuery.query(0, 11, 33); &#x2F;&#x2F; return 2. The value 33 occurs 2 times in the whole array.</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>1 &lt;&#x3D; arr[i], value &lt;&#x3D; 104<br>0 &lt;&#x3D; left &lt;&#x3D; right &lt; arr.length<br>At most 105 calls will be made to query</p><p>区间内查询数字的频率。</p><blockquote>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。请你实现 RangeFreqQuery 类：- RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。- int query(int left, int right, int value) 返回子数组 arr[left...right] 中 value 的 频率 。一个 子数组 指的是数组中一段连续的元素。arr[left...right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我解释一下题意，尤其是 query 的部分。题目给的是一个数组，比如这样的<br><code>[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]</code><br>然后题目让我们求的是在某一个区间<code>[left, right]</code>内，一个目标值的出现次数。比如<code>query(1, 2, 4)</code>，就是求<code>[33, 4]</code>这个区间内<code>4</code>的出现次数；<code>query(0, 11, 33)</code>，就是求<code>[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]</code>这个区间内<code>33</code>的出现次数。</p><p>对于一个数字在 input 数组内出现的下标，我们可以用一个 hashmap 存起来。至于如何高效地找到在某个区间 <code>[left, right]</code> 内到底有几个数字，则需要用到二分法。</p><p>注意代码内二分的 helper 函数 helper(left, right, target) 的含义是找在区间 <code>[left, right]</code> 内（实际是在某个数字对应的所有下标）第一个 &gt;&#x3D; target 的数字的下标。因为我们找的是在一段区间<code>[left, right]</code>内的目标值，所以我们可以找</p><ul><li>目标值 target 出现且大于 left 的位置</li><li>目标值 target 出现且大于 right 的位置</li></ul><p>如果目标值 target 出现的位置直接小于 left 或者 直接就大于 right 了，则说明 target 不在区间 <code>[left, right]</code> 内。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) + O(logn) &#x3D; O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RangeFreqQuery</span> &#123;<br>HashMap&lt;Integer, List&lt;Integer&gt;&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RangeFreqQuery</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> arr[i];<br><span class="hljs-keyword">if</span> (!map.containsKey(num)) &#123;<br>map.put(num, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>&#125;<br>map.get(num).add(i);<br>&#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> value)</span> &#123;<br>        List&lt;Integer&gt; list = map.get(value);<br><span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 找list中第一个 &gt;= left 的下标</span><br><span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> helper(list, <span class="hljs-number">0</span>, list.size() - <span class="hljs-number">1</span>, left);<br><span class="hljs-keyword">if</span> (list.get(first) &gt; right || list.get(first) &lt; left) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 找list中第一个 &gt;= right 的下标</span><br><span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> helper(list, <span class="hljs-number">0</span>, list.size() - <span class="hljs-number">1</span>, right);<br><span class="hljs-keyword">if</span> (list.get(second) &gt; right) &#123;<br>second--;<br>&#125;<br><span class="hljs-keyword">return</span> second - first + <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Integer&gt; list, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (list.get(mid) &lt; target) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RangeFreqQuery object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RangeFreqQuery obj = new RangeFreqQuery(arr);</span><br><span class="hljs-comment"> * int param_1 = obj.query(left,right,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>binary search</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3239. Minimum Number of Flips to Make Binary Grid Palindromic I</title>
    <link href="/posts/33361896.html"/>
    <url>/posts/33361896.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n binary matrix grid.</p><p>A row or column is considered palindromic if its values read the same forward and backward.</p><p>You can flip any number of cells in grid from 0 to 1, or from 1 to 0.</p><p>Return the minimum number of cells that need to be flipped to make either all rows palindromic or all columns palindromic.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-20-10.png" alt="Example 1"><br>Input: grid &#x3D; [[1,0,0],[0,0,0],[0,0,1]]<br>Output: 2</p><p>Explanation:<br>Flipping the highlighted cells makes all the rows palindromic.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2024/07/07/screenshot-from-2024-07-08-00-31-23.png" alt="Example 2"><br>Input: grid &#x3D; [[0,1],[0,1],[0,0]]<br>Output: 1</p><p>Explanation:<br>Flipping the highlighted cell makes all the columns palindromic.</p><p>Example 3:<br>Input: grid &#x3D; [[1],[0]]<br>Output: 0</p><p>Explanation:<br>All rows are already palindromic.</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m * n &lt;&#x3D; 2 * 105<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 1</p><p>最少翻转次数使二进制矩阵回文 I。</p><blockquote>给你一个 m x n 的二进制矩阵 grid 。<p>如果矩阵中一行或者一列从前往后与从后往前读是一样的，那么我们称这一行或者这一列是 回文 的。</p><p>你可以将 grid 中任意格子的值 翻转 ，也就是将格子里的值从 0 变成 1 ，或者从 1 变成 0 。</p><p>请你返回 最少 翻转次数，使得矩阵 要么 所有行是 回文的 ，要么所有列是 回文的 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是双指针，看看每一行和每一列是否都是回文。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// every row</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][left] != grid[i][right]) &#123;<br>                    count1++;<br>                &#125;<br>                left++;<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// every col</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (up &lt; down) &#123;<br>                <span class="hljs-keyword">if</span> (grid[up][i] != grid[down][i]) &#123;<br>                    count2++;<br>                &#125;<br>                up++;<br>                down--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(count1, count2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2064. Minimized Maximum of Products Distributed to Any Store</title>
    <link href="/posts/3461085503.html"/>
    <url>/posts/3461085503.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.</p><p>You need to distribute all products to the retail stores following these rules:<br>A store can only be given at most one product type but can be given any amount of it.<br>After distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store.<br>Return the minimum possible x.</p><p>Example 1:<br>Input: n &#x3D; 6, quantities &#x3D; [11,6]<br>Output: 3<br>Explanation: One optimal way is:</p><ul><li>The 11 products of type 0 are distributed to the first four stores in these amounts: 2, 3, 3, 3</li><li>The 6 products of type 1 are distributed to the other two stores in these amounts: 3, 3<br>The maximum number of products given to any store is max(2, 3, 3, 3, 3, 3) &#x3D; 3.</li></ul><p>Example 2:<br>Input: n &#x3D; 7, quantities &#x3D; [15,10,10]<br>Output: 5<br>Explanation: One optimal way is:</p><ul><li>The 15 products of type 0 are distributed to the first three stores in these amounts: 5, 5, 5</li><li>The 10 products of type 1 are distributed to the next two stores in these amounts: 5, 5</li><li>The 10 products of type 2 are distributed to the last two stores in these amounts: 5, 5<br>The maximum number of products given to any store is max(5, 5, 5, 5, 5, 5, 5) &#x3D; 5.</li></ul><p>Example 3:<br>Input: n &#x3D; 1, quantities &#x3D; [100000]<br>Output: 100000<br>Explanation: The only optimal way is:</p><ul><li>The 100000 products of type 0 are distributed to the only store.<br>The maximum number of products given to any store is max(100000) &#x3D; 100000.</li></ul><p>Constraints:<br>m &#x3D;&#x3D; quantities.length<br>1 &lt;&#x3D; m &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; quantities[i] &lt;&#x3D; 105</p><p>分配给商店的最多商品的最小值。</p><blockquote>给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。<p>你需要将 所有商品 分配到零售商店，并遵守这些规则：</p><ul><li>一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。</li><li>分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。</li></ul><p>请你返回最小的可能的 x 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分法，而且是有点类似875题那种在答案上二分的题目。题目是请我们把 m 种商品分配到 n 个商店里且需要尽量让每个商店分配商品数目的最大值越小越好。所以我们在做二分找 mid 的时候，mid 的意思是每个商店需要放多少件商品。如果按照 mid 的个数分配商品需要的商店个数 &gt; n，则把 mid 改小；反之则把 mid 改大。</p><p>注意代码中 count 的计算方式，因为是计算需要的商店个数所以需要向上取整。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimizedMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] quantities)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : quantities) &#123;<br>                <span class="hljs-comment">// count += (q + mid - 1) / mid;</span><br>                count += q / mid;<br>                <span class="hljs-keyword">if</span> (q % mid != <span class="hljs-number">0</span>) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &gt; n) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">410. Split Array Largest Sum<br>774. Minimize Max Distance to Gas Station<br>875. Koko Eating Bananas<br>1011. Capacity To Ship Packages In N Days<br>1060. Missing Element in Sorted Array<br>1231. Divide Chocolate<br>1283. Find the Smallest Divisor Given a Threshold<br>1482. Minimum Number of Days to Make m Bouquets<br>1539. Kth Missing Positive Number<br>1870. Minimum Speed to Arrive on Time<br>2064. Minimized Maximum of Products Distributed to Any Store<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1385. Find the Distance Value Between Two Arrays</title>
    <link href="/posts/3106797658.html"/>
    <url>/posts/3106797658.html</url>
    
    <content type="html"><![CDATA[<p>Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.</p><p>The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| &lt;&#x3D; d.</p><p>Example 1:<br>Input: arr1 &#x3D; [4,5,8], arr2 &#x3D; [10,9,1,8], d &#x3D; 2<br>Output: 2<br>Explanation:<br>For arr1[0]&#x3D;4 we have:<br>|4-10|&#x3D;6 &gt; d&#x3D;2<br>|4-9|&#x3D;5 &gt; d&#x3D;2<br>|4-1|&#x3D;3 &gt; d&#x3D;2<br>|4-8|&#x3D;4 &gt; d&#x3D;2<br>For arr1[1]&#x3D;5 we have:<br>|5-10|&#x3D;5 &gt; d&#x3D;2<br>|5-9|&#x3D;4 &gt; d&#x3D;2<br>|5-1|&#x3D;4 &gt; d&#x3D;2<br>|5-8|&#x3D;3 &gt; d&#x3D;2<br>For arr1[2]&#x3D;8 we have:<br>|8-10|&#x3D;2 &lt;&#x3D; d&#x3D;2<br>|8-9|&#x3D;1 &lt;&#x3D; d&#x3D;2<br>|8-1|&#x3D;7 &gt; d&#x3D;2<br>|8-8|&#x3D;0 &lt;&#x3D; d&#x3D;2</p><p>Example 2:<br>Input: arr1 &#x3D; [1,4,2,3], arr2 &#x3D; [-4,-3,6,10,20,30], d &#x3D; 3<br>Output: 2</p><p>Example 3:<br>Input: arr1 &#x3D; [2,1,100,3], arr2 &#x3D; [-5,-2,10,-3,7], d &#x3D; 6<br>Output: 1</p><p>Constraints:<br>1 &lt;&#x3D; arr1.length, arr2.length &lt;&#x3D; 500<br>-1000 &lt;&#x3D; arr1[i], arr2[j] &lt;&#x3D; 1000<br>0 &lt;&#x3D; d &lt;&#x3D; 100</p><p>两个数组间的距离值。</p><blockquote>给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。<p>「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;&#x3D; d 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的最优解是二分法。注意题设，对于元素 <code>arr1[i]</code>，我们要去 <code>arr2</code> 里面看是否存在一个 <code>arr2[j]</code> 满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。暴力的做法就是线性扫描，但是这会使得整体的复杂度达到 O(n^2) 。</p><p>优化的思路是我们需要对 arr2 进行排序，这样我们可以用二分法来查找 arr2[j] 。但是排序过后，我们需要会拆解这个绝对值的式子。满足 <code>|arr1[i] - arr2[j]| &lt;= d</code>，即是<br><code>-d &lt;= arr1[i] - arr2[j] &lt;= d</code><br>那么就是<code>arr2[j] - d &lt;= arr1[i] &lt;= arr2[j] + d</code></p><p>也就是说<code>arr1[i]</code>需要介于 [arr2[j] - d, arr2[j] + d] 之间。此时我们就可以用二分法了。如果发觉元素 <code>arr1[i]</code> 不在这个区间内，则说明距离值不满足。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheDistanceValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2, <span class="hljs-type">int</span> d)</span> &#123;<br>        Arrays.sort(arr2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr1) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> num - d;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> num + d;<br>            <span class="hljs-keyword">if</span> (!helper(low, high, arr2)) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= low &amp;&amp; nums[mid] &lt;= high) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; low) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; high) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>sort</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2070. Most Beautiful Item for Each Query</title>
    <link href="/posts/3117798264.html"/>
    <url>/posts/3117798264.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D integer array items where items[i] &#x3D; [pricei, beautyi] denotes the price and beauty of an item respectively.</p><p>You are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.</p><p>Return an array answer of the same length as queries where answer[j] is the answer to the jth query.</p><p>Example 1:<br>Input: items &#x3D; [[1,2],[3,2],[2,4],[5,6],[3,5]], queries &#x3D; [1,2,3,4,5,6]<br>Output: [2,4,5,5,6,6]<br>Explanation:</p><ul><li>For queries[0]&#x3D;1, [1,2] is the only item which has price &lt;&#x3D; 1. Hence, the answer for this query is 2.</li><li>For queries[1]&#x3D;2, the items which can be considered are [1,2] and [2,4].<br>The maximum beauty among them is 4.</li><li>For queries[2]&#x3D;3 and queries[3]&#x3D;4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].<br>The maximum beauty among them is 5.</li><li>For queries[4]&#x3D;5 and queries[5]&#x3D;6, all items can be considered.<br>Hence, the answer for them is the maximum beauty of all items, i.e., 6.</li></ul><p>Example 2:<br>Input: items &#x3D; [[1,2],[1,2],[1,3],[1,4]], queries &#x3D; [1]<br>Output: [4]<br>Explanation:<br>The price of every item is equal to 1, so we choose the item with the maximum beauty 4.<br>Note that multiple items can have the same price and&#x2F;or beauty.  </p><p>Example 3:<br>Input: items &#x3D; [[10,1000]], queries &#x3D; [5]<br>Output: [0]<br>Explanation:<br>No item has a price less than or equal to 5, so no item can be chosen.<br>Hence, the answer to the query is 0.</p><p>Constraints:<br>1 &lt;&#x3D; items.length, queries.length &lt;&#x3D; 105<br>items[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; pricei, beautyi, queries[j] &lt;&#x3D; 109</p><p>每一个查询的最大美丽值。</p><blockquote>给你一个二维整数数组 items ，其中 items[i] = [pricei, beautyi] 分别表示每一个物品的 价格 和 美丽值 。<p>同时给你一个下标从 0 开始的整数数组 queries 。对于每个查询 queries[j] ，你想求出价格小于等于 queries[j] 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为 0 。</p><p>请你返回一个长度与 queries 相同的数组 answer，其中 answer[j]是第 j 个查询的答案。</p></blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>这道题整体的思路是排序 + 双指针。以下是细节。</p><p>input 二维整数数组 items ，其中 items[i] &#x3D; [price, beauty]，且我们最后要返回的是对于每个查询 queries[j]，找到价格<code>小于等于 queries[j]</code> 的物品中，<code>最大的美丽值</code> 是多少。如果不对 input 数组排序，我们只能一个个看每个 item 的 price 是多少，然后再看每个 item 的价格是否满足要求以决定美丽值是多少。为了降低复杂度，我们可以根据 price 将 input 数组升序排列。根据 price 排列好的 items，我们可以用双指针来找满足<code>价格 &lt;= queries[j]</code>的物品中最大的美丽值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) + O(mn) &#x3D; O(mn)<br>空间O(n) - output array</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maximumBeauty(<span class="hljs-type">int</span>[][] items, <span class="hljs-type">int</span>[] queries) &#123;<br><span class="hljs-comment">// sort by price</span><br>        Arrays.sort(items, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br><span class="hljs-type">int</span>[][] indexedQueries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>indexedQueries[i][<span class="hljs-number">0</span>] = queries[i];<br>indexedQueries[i][<span class="hljs-number">1</span>] = i;<br>&#125;<br><span class="hljs-comment">// sort by query value</span><br>Arrays.sort(indexedQueries, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br><br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] q : indexedQueries) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">qValue</span> <span class="hljs-operator">=</span> q[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">qIndex</span> <span class="hljs-operator">=</span> q[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (i &lt; items.length &amp;&amp; items[i][<span class="hljs-number">0</span>] &lt;= qValue) &#123;<br>max = Math.max(max, items[i][<span class="hljs-number">1</span>]);<br>i++;<br>&#125;<br>res[qIndex] = max;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// sort + two pointer</span><br><span class="hljs-comment">// O(mn)</span><br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>还是需要对 price 排序。排序过后我们需要遍历一遍 input 数组，对于相同 price 的物品，我们只需要保留最大的 beauty 值。这个保留最大的 beauty 值的过程，我们可以用一个变量 max 来记录。不过对于相同 price 的物品，最后他们的 beauty 并不是一样的，而只是非递减的。最后对于相同 price 的物品，他们的美丽值类似这样排列，<code>[1,1,2,3,3,4,5,5,5,5]</code>。</p><p>接着我们用二分法。因为我们已经排过序，所以我们可以判断，如果 mid 的价格大于要找的价格，那么我们只需要看左半边，这样就去掉一半的物品了。这里就有点像 34 题，在有序数组里找元素的二分法。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m * logn) - m 个 query, 每个 query 都需要二分法查找<br>空间O(n) - output array</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maximumBeauty(<span class="hljs-type">int</span>[][] items, <span class="hljs-type">int</span>[] queries) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br><span class="hljs-comment">// sort by price</span><br>Arrays.sort(items, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> items[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;<br>max = Math.max(max, items[i][<span class="hljs-number">1</span>]);<br>items[i][<span class="hljs-number">1</span>] = max;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>res[i] = helper(items, queries[i]);<br>&#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] items, <span class="hljs-type">int</span> targetPrice)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> items.length - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxBeauty</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (items[mid][<span class="hljs-number">0</span>] &gt; targetPrice) &#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>maxBeauty = Math.max(maxBeauty, items[mid][<span class="hljs-number">1</span>]);<br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> maxBeauty;<br>&#125;<br>&#125;<br><span class="hljs-comment">// sort + binary search</span><br><span class="hljs-comment">// O(nlogn)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3090. Maximum Length Substring With Two Occurrences</title>
    <link href="/posts/2037543899.html"/>
    <url>/posts/2037543899.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s, return the maximum length of a substring such that it contains at most two occurrences of each character.</p><p>Example 1:<br>Input: s &#x3D; “bcbbbcba”<br>Output: 4</p><p>Explanation:<br>The following substring has a length of 4 and contains at most two occurrences of each character: “bcbbbcba”.</p><p>Example 2:<br>Input: s &#x3D; “aaaa”<br>Output: 2</p><p>Explanation:<br>The following substring has a length of 2 and contains at most two occurrences of each character: “aaaa”.</p><p>Constraints:<br>2 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s consists only of lowercase English letters.</p><p>每个字符最多出现两次的最长子字符串。</p><blockquote>给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该子字符串的 最大 长度。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不难看出是用滑动窗口的思路，而且这道题很像159题。这道题左指针的移动条件是只要某个字母的出现次数大于2，就移动左指针。其余思路同一般滑动窗口题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumLengthSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            end++;<br>            map[c1]++;<br>            <span class="hljs-comment">// 如果某个字母的出现次数大于2，就移动左指针</span><br>            <span class="hljs-keyword">while</span> (map[c1] &gt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                start++;<br>                map[c2]--;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2841. Maximum Sum of Almost Unique Subarray</title>
    <link href="/posts/104383570.html"/>
    <url>/posts/104383570.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and two positive integers m and k.</p><p>Return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.</p><p>A subarray of nums is almost unique if it contains at least m distinct elements.</p><p>A subarray is a contiguous non-empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [2,6,7,3,1,7], m &#x3D; 3, k &#x3D; 4<br>Output: 18<br>Explanation: There are 3 almost unique subarrays of size k &#x3D; 4. These subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7]. Among these subarrays, the one with the maximum sum is [2, 6, 7, 3] which has a sum of 18.</p><p>Example 2:<br>Input: nums &#x3D; [5,9,9,2,4,5,4], m &#x3D; 1, k &#x3D; 3<br>Output: 23<br>Explanation: There are 5 almost unique subarrays of size k. These subarrays are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4]. Among these subarrays, the one with the maximum sum is [5, 9, 9] which has a sum of 23.</p><p>Example 3:<br>Input: nums &#x3D; [1,2,1,2,1,2,1], m &#x3D; 3, k &#x3D; 3<br>Output: 0<br>Explanation: There are no subarrays of size k &#x3D; 3 that contain at least m &#x3D; 3 distinct elements in the given array [1,2,1,2,1,2,1]. Therefore, no almost unique subarrays exist, and the maximum sum is 0.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>1 &lt;&#x3D; m &lt;&#x3D; k &lt;&#x3D; nums.length<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>几乎唯一子数组的最大和。</p><blockquote>给你一个整数数组 nums 和两个正整数 m 和 k 。<p>请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。</p><p>如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。</p><p>子数组指的是一个数组中一段连续 非空 的元素序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求我们找的是一个长度为 k 的子数组。这道题的思路就是偏找一个<code>固定长度的滑动窗口</code>，然后窗口内元素满足一定条件。具体到这个题，我们找的就是一个长度为 k 的子数组，在这个长度为 k 的窗口内，不同元素个数需要至少为 m 个。</p><p>那么我们可以用一个 hashmap 来统计窗口内的元素情况，如果 map.size() &gt;&#x3D; m，则窗口内的元素才满足条件，才能把窗口内元素的计算和。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxSum</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums.get(i);<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            sum += nums.get(i);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.size() &gt;= m) &#123;<br>            res = sum;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums.get(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> nums.get(i - k);<br>            map.put(cur, map.getOrDefault(cur, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> map.getOrDefault(pre, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>) &#123;<br>                map.put(pre, c - <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.remove(pre);<br>            &#125;<br>            sum += cur;<br>            sum -= pre;<br>            <span class="hljs-keyword">if</span> (map.size() &gt;= m) &#123;<br>                res = Math.max(res, sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold</title>
    <link href="/posts/2495846327.html"/>
    <url>/posts/2495846327.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.</p><p>Example 1:<br>Input: arr &#x3D; [2,2,2,2,5,5,5,8], k &#x3D; 3, threshold &#x3D; 4<br>Output: 3<br>Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).</p><p>Example 2:<br>Input: arr &#x3D; [11,13,17,23,29,31,7,5,2,3], k &#x3D; 3, threshold &#x3D; 5<br>Output: 6<br>Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; arr.length<br>0 &lt;&#x3D; threshold &lt;&#x3D; 104</p><p>大小为 K 且平均值大于等于阈值的子数组数目。</p><blockquote>给你一个整数数组 arr 和两个整数 k 和 threshold 。<p>请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是一道窗口尺寸固定的滑动窗口题。注意尽量不要在中间过程求平均值因为会涉及到精度问题。在过程中我们可以只求数字的 sum，不求平均值，到最后再计算平均值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            sum += arr[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (sum &gt;= threshold * k) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++) &#123;<br>            sum += arr[i];<br>            sum -= arr[i - k];<br>            <span class="hljs-keyword">if</span> (sum &gt;= threshold * k) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2275. Largest Combination With Bitwise AND Greater Than Zero</title>
    <link href="/posts/250684932.html"/>
    <url>/posts/250684932.html</url>
    
    <content type="html"><![CDATA[<p>The bitwise AND of an array nums is the bitwise AND of all integers in nums.</p><p>For example, for nums &#x3D; [1, 5, 3], the bitwise AND is equal to 1 &amp; 5 &amp; 3 &#x3D; 1.<br>Also, for nums &#x3D; [7], the bitwise AND is 7.<br>You are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination.</p><p>Return the size of the largest combination of candidates with a bitwise AND greater than 0.</p><p>Example 1:<br>Input: candidates &#x3D; [16,17,71,62,12,24,14]<br>Output: 4<br>Explanation: The combination [16,17,62,24] has a bitwise AND of 16 &amp; 17 &amp; 62 &amp; 24 &#x3D; 16 &gt; 0.<br>The size of the combination is 4.<br>It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.<br>Note that more than one combination may have the largest size.<br>For example, the combination [62,12,24,14] has a bitwise AND of 62 &amp; 12 &amp; 24 &amp; 14 &#x3D; 8 &gt; 0.</p><p>Example 2:<br>Input: candidates &#x3D; [8,8]<br>Output: 2<br>Explanation: The largest combination [8,8] has a bitwise AND of 8 &amp; 8 &#x3D; 8 &gt; 0.<br>The size of the combination is 2, so we return 2.</p><p>Constraints:<br>1 &lt;&#x3D; candidates.length &lt;&#x3D; 105<br>1 &lt;&#x3D; candidates[i] &lt;&#x3D; 107</p><p>按位与结果大于零的最长组合。</p><blockquote>对数组 nums 执行 按位与 相当于对数组 nums 中的所有整数执行 按位与 。<p>例如，对 nums &#x3D; [1, 5, 3] 来说，按位与等于 1 &amp; 5 &amp; 3 &#x3D; 1 。<br>同样，对 nums &#x3D; [7] 而言，按位与等于 7 。<br>给你一个正整数数组 candidates 。计算 candidates 中的数字每种组合下 按位与 的结果。 candidates 中的每个数字在每种组合中只能使用 一次 。</p><p>返回按位与结果大于 0 的 最长 组合的长度。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道位运算的题。因为题目要求我们找到是一个数字组合，这个组合需要满足的条件是他们的 AND 操作要最大。但是因为这个组合里的数字个数不定，所以没法用类似 backtracking 那样的方法去枚举；且问的是 AND 操作的最大值，所以思路只能往 bit manipulation 上靠。</p><p>假如所有数字可以用 8 个 digit 表达完 (0000 0000)，那么使 AND 的结果最大的方式就是最高位最好都是 1。那么我们可以从二进制的低位遍历到高位（从右往左看），统计一下每个数字的二进制表达里每个位置上的 1 的情况，用一个 map 记录一下。在遍历过程中记录出现 1 的<code>最大次数</code>。因为是从右往左扫描的所以最大次数越往左，结果越大。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - candidates 数组遍历一次<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestCombination</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">24</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candidate : candidates) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++) &#123;<br><span class="hljs-keyword">if</span> ((candidate &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &gt; <span class="hljs-number">0</span>) &#123;<br>map[i]++;<br>max = Math.max(max, map[i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1356. Sort Integers by The Number of 1 Bits</title>
    <link href="/posts/2027031335.html"/>
    <url>/posts/2027031335.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array arr. You have to sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order.</p><p>Return the sorted array.</p><p>Example 1:<br>Input: arr &#x3D; [0,1,2,3,4,5,6,7,8]<br>Output: [0,1,2,4,8,3,5,6,7]<br>Explantion: [0] is the only integer with 0 bits.<br>[1,2,4,8] all have 1 bit.<br>[3,5,6] have 2 bits.<br>[7] has 3 bits.<br>The sorted array by bits is [0,1,2,4,8,3,5,6,7]</p><p>Example 2:<br>Input: arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]<br>Output: [1,2,4,8,16,32,64,128,256,512,1024]<br>Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.</p><p>Example 3:<br>Input: arr &#x3D; [10000,10000]<br>Output: [10000,10000]</p><p>Example 4:<br>Input: arr &#x3D; [2,3,5,7,11,13,17,19]<br>Output: [2,3,5,17,7,11,13,19]</p><p>Example 5:<br>Input: arr &#x3D; [10,100,1000,10000]<br>Output: [10,100,10000,1000]</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 500<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 10^4</p><p>根据数字二进制下 1 的数目排序。</p><blockquote>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。<p>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意很简单，对于每个数字，我们计算其二进制表达中的 1 的个数，根据 1 出现的数量多少对数组进行排序。对于两个二进制表达中 1 的数量相同的数字，我们再按照其十进制的表达由大到小排序。</p><p>这道题不涉及算法，就是按这个规则实现排序即可。我认为这道题的重点就是让你记住语言里是有自带的 api 帮你快速计算一个二进制数字里面有几个 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortByBits(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        Integer[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = arr[i];<br>        &#125;<br><br>        Arrays.sort(nums, (a, b) -&gt; Integer.bitCount(a) == Integer.bitCount(b) ? a - b : Integer.bitCount(a) - Integer.bitCount(b));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[i] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>sort</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3011. Find if Array Can Be Sorted</title>
    <link href="/posts/2353492200.html"/>
    <url>/posts/2353492200.html</url>
    
    <content type="html"><![CDATA[<p>In one operation, you can swap any two adjacent elements if they have the same number of set bits. You are allowed to do this operation any number of times (including zero).</p><p>Return true if you can sort the array, else return false.</p><p>Example 1:<br>Input: nums &#x3D; [8,4,2,30,15]<br>Output: true<br>Explanation: Let’s look at the binary representation of every element. The numbers 2, 4, and 8 have one set bit each with binary representation “10”, “100”, and “1000” respectively. The numbers 15 and 30 have four set bits each with binary representation “1111” and “11110”.<br>We can sort the array using 4 operations:</p><ul><li>Swap nums[0] with nums[1]. This operation is valid because 8 and 4 have one set bit each. The array becomes [4,8,2,30,15].</li><li>Swap nums[1] with nums[2]. This operation is valid because 8 and 2 have one set bit each. The array becomes [4,2,8,30,15].</li><li>Swap nums[0] with nums[1]. This operation is valid because 4 and 2 have one set bit each. The array becomes [2,4,8,30,15].</li><li>Swap nums[3] with nums[4]. This operation is valid because 30 and 15 have four set bits each. The array becomes [2,4,8,15,30].<br>The array has become sorted, hence we return true.<br>Note that there may be other sequences of operations which also sort the array.</li></ul><p>Example 2:<br>Input: nums &#x3D; [1,2,3,4,5]<br>Output: true<br>Explanation: The array is already sorted, hence we return true.</p><p>Example 3:<br>Input: nums &#x3D; [3,16,8,4,2]<br>Output: false<br>Explanation: It can be shown that it is not possible to sort the input array using any number of operations.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 28</p><p>判断一个数组是否可以变为有序。</p><blockquote>给你一个下标从 0 开始且全是 正 整数的数组 nums 。<p>一次 操作 中，如果两个 相邻 元素在二进制下设置位的数目 相同 ，那么你可以将这两个元素交换。你可以执行这个操作 任意次 （也可以 0 次）。</p><p>如果你可以使数组变为非降序，请你返回 true ，否则返回 false 。</p><p>示例 1：<br>输入：nums &#x3D; [8,4,2,30,15]<br>输出：true<br>解释：我们先观察每个元素的二进制表示。 2 ，4 和 8 分别都只有一个数位为 1 ，分别为 “10” ，”100” 和 “1000” 。15 和 30 分别有 4 个数位为 1 ：”1111” 和 “11110” 。<br>我们可以通过 4 个操作使数组非降序：</p><ul><li>交换 nums[0] 和 nums[1] 。8 和 4 分别只有 1 个数位为 1 。数组变为 [4,8,2,30,15] 。</li><li>交换 nums[1] 和 nums[2] 。8 和 2 分别只有 1 个数位为 1 。数组变为 [4,2,8,30,15] 。</li><li>交换 nums[0] 和 nums[1] 。4 和 2 分别只有 1 个数位为 1 。数组变为 [2,4,8,30,15] 。</li><li>交换 nums[3] 和 nums[4] 。30 和 15 分别有 4 个数位为 1 ，数组变为 [2,4,8,15,30] 。<br>数组变成有序的，所以我们返回 true 。<br>注意我们还可以通过其他的操作序列使数组变得有序。</li></ul><p>示例 2：<br>输入：nums &#x3D; [1,2,3,4,5]<br>输出：true<br>解释：数组已经是非降序的，所以我们返回 true 。</p><p>示例 3：<br>输入：nums &#x3D; [3,16,8,4,2]<br>输出：false<br>解释：无法通过操作使数组变为非降序。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道关于二进制的题目。注意<code>元素在二进制下设置位的数目相同</code>这个定义的意思其实就是两个数字的二进制表示中的 1 的个数要相同。如果两个数字的 1 的个数相同，且他们在原数组里是相邻元素，才能互相交换位置。</p><p>所以我们需要遍历 input 数组，看一看每个数字的 <code>Integer.bitCount(num)</code>，如果某一串连续的数字他们的 1 的个数都相同的话，这一段数字就可以互相交换以确保他们有序。所以数组会因为 1 的个数的不同而变得分段有序。</p><p>再次遍历排过序的数组，如果分段排序不能导致最后的整体有序，则返回 false，否则返回 true。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canSortArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-comment">// 二进制表达里 1 的个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> Integer.bitCount(nums[i]);<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; Integer.bitCount(nums[i]) == ones) &#123;<br>                i++;<br>            &#125;<br><span class="hljs-comment">// 分段排序</span><br>            Arrays.sort(nums, start, i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[j - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3163. String Compression III</title>
    <link href="/posts/4073470908.html"/>
    <url>/posts/4073470908.html</url>
    
    <content type="html"><![CDATA[<p>Given a string word, compress it using the following algorithm:<br>Begin with an empty string comp. While word is not empty, use the following operation:<br>Remove a maximum length prefix of word made of a single character c repeating at most 9 times.<br>Append the length of the prefix followed by c to comp.<br>Return the string comp.</p><p>Example 1:<br>Input: word &#x3D; “abcde”<br>Output: “1a1b1c1d1e”</p><p>Explanation:<br>Initially, comp &#x3D; “”. Apply the operation 5 times, choosing “a”, “b”, “c”, “d”, and “e” as the prefix in each operation.</p><p>For each prefix, append “1” followed by the character to comp.</p><p>Example 2:<br>Input: word &#x3D; “aaaaaaaaaaaaaabb”<br>Output: “9a5a2b”</p><p>Explanation:<br>Initially, comp &#x3D; “”. Apply the operation 3 times, choosing “aaaaaaaaa”, “aaaaa”, and “bb” as the prefix in each operation.</p><p>For prefix “aaaaaaaaa”, append “9” followed by “a” to comp.<br>For prefix “aaaaa”, append “5” followed by “a” to comp.<br>For prefix “bb”, append “2” followed by “b” to comp.</p><p>Constraints:<br>1 &lt;&#x3D; word.length &lt;&#x3D; 2 * 105<br>word consists only of lowercase English letters.</p><p>压缩字符串 III。</p><blockquote>给你一个字符串 word，请你使用以下算法进行压缩：- 从空字符串 comp 开始。当 word 不为空 时，执行以下操作：- 移除 word 的最长单字符前缀，该前缀由单一字符 c 重复多次组成，且该前缀长度 最多 为 9 。- 将前缀的长度和字符 c 追加到 comp 。返回字符串 comp 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道模拟题。按照题意卡住条件即可，可直接参见代码。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - output 也是个字符串</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">compressedString</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> word.charAt(i);<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; word.charAt(i) == cur &amp;&amp; count &lt; <span class="hljs-number">9</span>) &#123;<br>                count++;<br>                i++;<br>            &#125;<br>            sb.append(count);<br>            sb.append(cur);<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给网站添加免费的SSL证书</title>
    <link href="/posts/345603125.html"/>
    <url>/posts/345603125.html</url>
    
    <content type="html"><![CDATA[<p>自己曾经做了一个网站部署在一台 <code>ubuntu</code> 服务器上，但是由于一开始不会配置 SSL，所以花钱买了付费的 SSL。最近发现了 Let’s Encrypt，可以免费申请 SSL 证书，下面是详细的教程。</p><p>我的网站是一个 React 的项目，所以我的服务器上只是一个简单的 <code>Node.js 环境 + Nginx</code>。我主要参考了<a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-22-04">这个帖子</a>。如果你是用其他的环境比如<code>LAMP</code>那一套的，请自行搜索其他的教程。</p><h2 id="0-安装-node-js"><a href="#0-安装-node-js" class="headerlink" title="0. 安装 node.js"></a>0. 安装 node.js</h2><p>先看一下服务器上是否安装了 node.js</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">node --version<br></code></pre></td></tr></table></figure><p>如果这行命令没有返回 node 版本号，那么就需要安装 node.js。这里不展示了。</p><h2 id="1-安装-certbot"><a href="#1-安装-certbot" class="headerlink" title="1. 安装 certbot"></a>1. 安装 certbot</h2><p>敲这两个命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo snap install core<br>sudo snap refresh core<br></code></pre></td></tr></table></figure><p>如果你曾经安装过 certbot，这里建议你先卸载原先的版本然后重新安装，这样你就有最新的版本了。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt remove certbot<br></code></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo snap install --classic certbot<br></code></pre></td></tr></table></figure><h3 id="创建一个-symbolic-link"><a href="#创建一个-symbolic-link" class="headerlink" title="创建一个 symbolic link"></a>创建一个 symbolic link</h3><p>因为 certbot 安装完毕之后是不能直接跑他的命令的，所以这里我们多一步，创建一个 symbolic link。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo ln -s /snap/bin/certbot /usr/bin/certbot<br></code></pre></td></tr></table></figure><h2 id="2-检查一下-Nginx-的相关配置"><a href="#2-检查一下-Nginx-的相关配置" class="headerlink" title="2. 检查一下 Nginx 的相关配置"></a>2. 检查一下 Nginx 的相关配置</h2><p>如果你没有安装 Nginx，请参考<a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-22-04#step-5-%E2%80%93-setting-up-server-blocks-(recommended)">这个帖子</a>。</p><p>如果你安装了 Nginx，请打开以下这个文件。<code>example.com</code>是你自己的域名。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo nano /etc/nginx/sites-available/example.com<br></code></pre></td></tr></table></figure><p>确保你有带有<code>server_name</code>的那一行，应该长这样。确保他没有被注释掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs /etc/nginx/sites-available/example.com">server_name example.com www.example.com;<br></code></pre></td></tr></table></figure><p>保存配置，从编辑器中退出来，然后敲这个命令确保没有语法错误。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo nginx -t<br></code></pre></td></tr></table></figure><p>用这个命令把 Nginx reload 一下使配置生效。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo systemctl reload nginx<br></code></pre></td></tr></table></figure><h2 id="3-防火墙设置"><a href="#3-防火墙设置" class="headerlink" title="3. 防火墙设置"></a>3. 防火墙设置</h2><p>ubuntu 服务器上一般都是用一个叫做<code>ufw</code>的东西来做防火墙的。我们可以用这个命令看一下目前的状态。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo ufw status<br></code></pre></td></tr></table></figure><p>一般返回的东西应该是这样的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Output<br>Status: active<br><br>To                         Action      From<br>--                         ------      ----<br>OpenSSH                    ALLOW       Anywhere                  <br>Nginx HTTP                 ALLOW       Anywhere                  <br>OpenSSH (v6)               ALLOW       Anywhere (v6)             <br>Nginx HTTP (v6)            ALLOW       Anywhere (v6)<br></code></pre></td></tr></table></figure><p>敲如下命令使防火墙能允许 HTTPS 流量。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo ufw allow &#x27;Nginx Full&#x27;<br>sudo ufw delete allow &#x27;Nginx HTTP&#x27;<br></code></pre></td></tr></table></figure><p>之后你的防火墙配置应该是这样的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo ufw status<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Output<br>Status: active<br><br>To                         Action      From<br>--                         ------      ----<br>OpenSSH                    ALLOW       Anywhere<br>Nginx Full                 ALLOW       Anywhere<br>OpenSSH (v6)               ALLOW       Anywhere (v6)<br>Nginx Full (v6)            ALLOW       Anywhere (v6)<br></code></pre></td></tr></table></figure><h2 id="4-获得-SSL-证书"><a href="#4-获得-SSL-证书" class="headerlink" title="4. 获得 SSL 证书"></a>4. 获得 SSL 证书</h2><p>敲如下命令来申请 SSL 证书。记得改成自己的域名。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo certbot --nginx -d example.com -d www.example.com<br></code></pre></td></tr></table></figure><p>如果一切正常，terminal 最后会显示 SSL 证书被存到什么路径了之类的信息，类似这样。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">Output<br>IMPORTANT NOTES:<br>Successfully received certificate.<br>Certificate is saved at: /etc/letsencrypt/live/your_domain/fullchain.pem<br>Key is saved at: /etc/letsencrypt/live/your_domain/privkey.pem<br>This certificate expires on 2022-06-01.<br>These files will be updated when the certificate renews.<br>Certbot has set up a scheduled task to automatically renew this certificate in the background.<br><br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br>If you like Certbot, please consider supporting our work by:<br>* Donating to ISRG / Let&#x27;s Encrypt: https://letsencrypt.org/donate<br>* Donating to EFF: https://eff.org/donate-le<br></code></pre></td></tr></table></figure><p>理论上此时你的 SSL 应该就立即生效了。你可以试着访问自己的网站，或者通过一些 SSL 检测工具来验证一下你的证书是否有效。</p><h2 id="5-自动更新-SSL-证书"><a href="#5-自动更新-SSL-证书" class="headerlink" title="5. 自动更新 SSL 证书"></a>5. 自动更新 SSL 证书</h2><p>虽然我们通过这个方式获得的 SSL 证书是免费的，但是它的有效期一般只有 90 天。所以这里我们可以配置他的自动更新。</p><p>如下这个命令可以让 certbot 一天运行两次以检查当前的 SSL 是否依然有效。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo systemctl status snap.certbot.renew.service<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Output<br>○ snap.certbot.renew.service - Service for snap application certbot.renew<br>     Loaded: loaded (/etc/systemd/system/snap.certbot.renew.service; static)<br>     Active: inactive (dead)<br>TriggeredBy: ● snap.certbot.renew.timer<br></code></pre></td></tr></table></figure><p>可以通过如下这个命令测试一下 SSL 是如何更新的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo certbot renew --dry-run<br></code></pre></td></tr></table></figure><h2 id="❤️-以上"><a href="#❤️-以上" class="headerlink" title="❤️ 以上"></a>❤️ 以上</h2>]]></content>
    
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3226. Number of Bit Changes to Make Two Integers Equal</title>
    <link href="/posts/3397917777.html"/>
    <url>/posts/3397917777.html</url>
    
    <content type="html"><![CDATA[<p>You are given two positive integers n and k.</p><p>You can choose any bit in the binary representation of n that is equal to 1 and change it to 0.</p><p>Return the number of changes needed to make n equal to k. If it is impossible, return -1.</p><p>Example 1:<br>Input: n &#x3D; 13, k &#x3D; 4<br>Output: 2</p><p>Explanation:<br>Initially, the binary representations of n and k are n &#x3D; (1101)2 and k &#x3D; (0100)2.<br>We can change the first and fourth bits of n. The resulting integer is n &#x3D; (0100)2 &#x3D; k.</p><p>Example 2:<br>Input: n &#x3D; 21, k &#x3D; 21<br>Output: 0</p><p>Explanation:<br>n and k are already equal, so no changes are needed.</p><p>Example 3:<br>Input: n &#x3D; 14, k &#x3D; 13<br>Output: -1</p><p>Explanation:<br>It is not possible to make n equal to k.</p><p>Constraints:<br>1 &lt;&#x3D; n, k &lt;&#x3D; 106</p><p>使两个整数相等的位更改次数。</p><blockquote>给你两个正整数 n 和 k。<p>你可以选择 n 的 二进制表示 中任意一个值为 1 的位，并将其改为 0。</p><p>返回使得 n 等于 k 所需要的更改次数。如果无法实现，返回 -1。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道位运算的问题。首先注意，这道题里我们只能改 n 的某个 digit，不能改 k 中的 digit；而且我们只能把 1 改成 0，不能把 0 改成 1。</p><p>那么判断是否能改和怎么改呢？因为不能改 k 中的任何 digit，所以我们可以计算一下 <code>n &amp; k</code>，如果<code>n &amp; k != k</code>，则说明 n 中有一些位置上存在 0，而我们是不能改动 0 的，这种 case 我们就直接返回 -1。如果<code>n &amp; k == k</code>，起码说明我们可以改。此时我们可以用各种语言自带的 API 统计一下 n 和 k 分别包含几个 1，然后返回他们的差值即可。</p><p>或者我们也可以看 <code>n | k</code> 是否等于 n，如果等于 n，则说明 k 里面不存在多余的 1。通过这个方式我们也可以判断是否可以改动。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minChanges</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> (n &amp; k) != k ? -<span class="hljs-number">1</span> : Integer.bitCount(n ^ k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minChanges</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">return</span> (n | k) != n ? -<span class="hljs-number">1</span> : Integer.bitCount(n ^ k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3216. Lexicographically Smallest String After a Swap</title>
    <link href="/posts/2502881258.html"/>
    <url>/posts/2502881258.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once.</p><p>Digits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.</p><p>Example 1:<br>Input: s &#x3D; “45320”<br>Output: “43520”</p><p>Explanation:<br>s[1] &#x3D;&#x3D; ‘5’ and s[2] &#x3D;&#x3D; ‘3’ both have the same parity, and swapping them results in the lexicographically smallest string.</p><p>Example 2:<br>Input: s &#x3D; “001”<br>Output: “001”</p><p>Explanation:<br>There is no need to perform a swap because s is already the lexicographically smallest.</p><p>Constraints:<br>2 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s consists only of digits.</p><p>交换后字典序最小的字符串。</p><blockquote>给你一个仅由数字组成的字符串 s，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。<p>如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意交换的规则，两个数字只能同为奇数或者同为偶数才能互相交换。所以思路是从左往右遍历所有的字符，如果某两个相邻的字符 <code>a 和 b (a 在左，b 在右)</code> 具有相同的奇偶性且 a &gt; b，则可以进行交换。照着这个思路，找到第一对符合条件的 a 和 b，即可交换并返回结果。为什么是第一对，是因为需要让字典序尽可能的小，你交换在后面的字符，字典序是不如交换第一对大的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSmallestString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] letters = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> letters[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> letters[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (helper(a, b) &amp;&amp; a &gt; b) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> letters[i - <span class="hljs-number">1</span>];<br>                letters[i - <span class="hljs-number">1</span>] = letters[i];<br>                letters[i] = temp;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(letters);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a % <span class="hljs-number">2</span> == b % <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 951. Flip Equivalent Binary Trees</title>
    <link href="/posts/11988317.html"/>
    <url>/posts/11988317.html</url>
    
    <content type="html"><![CDATA[<p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p><p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p><p>Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" alt="Example 1"><br>Input: root1 &#x3D; [1,2,3,4,5,6,null,null,null,7,8], root2 &#x3D; [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>Output: true<br>Explanation: We flipped at nodes with values 1, 3, and 5.</p><p>Example 2:<br>Input: root1 &#x3D; [], root2 &#x3D; []<br>Output: true</p><p>Example 3:<br>Input: root1 &#x3D; [], root2 &#x3D; [1]<br>Output: false</p><p>Constraints:<br>The number of nodes in each tree is in the range [0, 100].<br>Each tree will have unique node values in the range [0, 99].</p><p>翻转等价二叉树。</p><blockquote>我们可以为二叉树 T 定义一个 翻转操作 ，如下所示：选择任意节点，然后交换它的左子树和右子树。<p>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转 等价 于二叉树 Y。</p><p>这些树由根节点 root1 和 root2 给出。如果两个二叉树是否是翻转 等价 的函数，则返回 true ，否则返回 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意很直观，判断两棵树是否能通过翻转操作变成一样的。那么大致思路就是从根节点往下看，如果 root 节点一样，就往下看；下一层如果左节点 &#x3D;&#x3D; 左节点，右节点 &#x3D;&#x3D; 右节点或者 A 的左节点 &#x3D;&#x3D; B 的右节点，则说明二者可以通过翻转操作变成一样的。用 DFS 的方法遍历整棵树。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h) - 树的高度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> * int val;</span><br><span class="hljs-comment"> * TreeNode left;</span><br><span class="hljs-comment"> * TreeNode right;</span><br><span class="hljs-comment"> * TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> * TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> * TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> * this.val = val;</span><br><span class="hljs-comment"> * this.left = left;</span><br><span class="hljs-comment"> * this.right = right;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">flipEquiv</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == root2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span> || root2 == <span class="hljs-literal">null</span> || root1.val != root2.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right))<br>                || (flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3184. Count Pairs That Form a Complete Day I</title>
    <link href="/posts/280881127.html"/>
    <url>/posts/280881127.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i &lt; j and hours[i] + hours[j] forms a complete day.</p><p>A complete day is defined as a time duration that is an exact multiple of 24 hours.</p><p>For example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.</p><p>Example 1:<br>Input: hours &#x3D; [12,12,30,24,24]<br>Output: 2</p><p>Explanation:<br>The pairs of indices that form a complete day are (0, 1) and (3, 4).</p><p>Example 2:<br>Input: hours &#x3D; [72,48,24,3]<br>Output: 3</p><p>Explanation:<br>The pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).</p><p>Constraints:<br>1 &lt;&#x3D; hours.length &lt;&#x3D; 100<br>1 &lt;&#x3D; hours[i] &lt;&#x3D; 109</p><p>构成整天的下标对数目 I。</p><blockquote>给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。<p>整天 定义为时间持续时间是 24 小时的 整数倍 。</p><p>例如，1 天是 24 小时，2 天是 48 小时，3 天是 72 小时，以此类推。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>这道题的思路二可以直接用来解决 3185 题，与 3184 题是一模一样的。</code></p><h2 id="思路一-暴力解"><a href="#思路一-暴力解" class="headerlink" title="思路一 暴力解"></a>思路一 暴力解</h2><p>暴力解法是枚举所有可能的下标对，然后判断是否构成整天。时间复杂度为 O(n^2)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// brute force</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countCompleteDayPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] hours)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> hours.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> hours[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> hours[j];<br>                <span class="hljs-keyword">if</span> ((a + b) % <span class="hljs-number">24</span> == <span class="hljs-number">0</span>) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-利用模运算的规则"><a href="#思路二-利用模运算的规则" class="headerlink" title="思路二 - 利用模运算的规则"></a>思路二 - 利用模运算的规则</h2><p>题目要求我们找的 pair 是 a + b 形成的 hour 是一整天，可以是 24 小时也可以是 48 小时，只要是 24 的倍数即可。同时注意到模运算是有结合律的，即如果 <code>(a + b) % 24 = 0</code>，那么 <code>a % 24 + b % 24 = 24</code>。</p><p>所以这里我们可以用一个长度为 24 的数组<code>int[] map</code>把所有数字 % 24 后的值统计出来。设当前遍历到的小时是 hour，那么我们把它 % 24，即 <code>hour % 24</code>，把它存入 map 中。可以和<code>hour % 24</code>配对的 hour 是 <code>24 - hour % 24</code>。唯一的例外是 24 和 24 的倍数，具体参见代码。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(24) - O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countCompleteDayPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] hours)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> hours.length;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">24</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> h : hours) &#123;<br>            <span class="hljs-keyword">if</span> (h % <span class="hljs-number">24</span> != <span class="hljs-number">0</span>) &#123;<br>                count += map[<span class="hljs-number">24</span> - h % <span class="hljs-number">24</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count += map[<span class="hljs-number">0</span>];<br>            &#125;<br>            map[h % <span class="hljs-number">24</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1010. Pairs of Songs With Total Durations Divisible by 60<br>2453. Destroy Sequential Targets<br>3184. Count Pairs That Form a Complete Day I<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
      <tag>counting sort</tag>
      
      <tag>MOD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 910. Smallest Range II</title>
    <link href="/posts/1156564084.html"/>
    <url>/posts/1156564084.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and an integer k.</p><p>For each index i where 0 &lt;&#x3D; i &lt; nums.length, change nums[i] to be either nums[i] + k or nums[i] - k.</p><p>The score of nums is the difference between the maximum and minimum elements in nums.</p><p>Return the minimum score of nums after changing the values at each index.</p><p>Example 1:<br>Input: nums &#x3D; [1], k &#x3D; 0<br>Output: 0<br>Explanation: The score is max(nums) - min(nums) &#x3D; 1 - 1 &#x3D; 0.</p><p>Example 2:<br>Input: nums &#x3D; [0,10], k &#x3D; 2<br>Output: 6<br>Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) &#x3D; 8 - 2 &#x3D; 6.</p><p>Example 3:<br>Input: nums &#x3D; [1,3,6], k &#x3D; 3<br>Output: 3<br>Explanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) &#x3D; 6 - 3 &#x3D; 3.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>0 &lt;&#x3D; k &lt;&#x3D; 104</p><p>最小差值 II。</p><blockquote>给你一个整数数组 nums，和一个整数 k 。<p>对于每个下标 i（0 &lt;&#x3D; i &lt; nums.length），将 nums[i] 变成 nums[i] + k 或 nums[i] - k 。</p><p>nums 的 分数 是 nums 中最大元素和最小元素的差值。</p><p>在更改每个下标对应的值之后，返回 nums 的最小 分数 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是 908 题的版本二，题意跟 908 题稍有不同。在这道题里，对于每个元素 <code>nums[i]</code> 而言，你必须做 +k 或 -k 的操作。这道题我参考了<a href="https://leetcode.cn/problems/smallest-range-ii/solutions/2928780/xiao-de-bian-da-da-de-bian-xiao-pythonja-8fnp">这个帖子</a>，写的很好，图示也很清楚。</p><p>如果没有 k，那么这道题和 908 题一样，直接求最大值和最小值差值即可。但是因为牵涉到 k 的操作了，而且我们要找的这个差值 (max - min) 需要尽可能小，所以基本的思路是要让小的数字尽可能大（那就 + k），让大的数字尽可能小（那就 - k）。但是在操作的过程中极有可能导致 <code>min + k</code> 比 <code>max - k</code>要大。所以我们不能只考虑这两个值，还要考虑中间的那些值。</p><p>所以对于任何一个中间的 index <code>i</code> 而言，他左侧的元素是 <code>nums[0] 到 nums[i - 1]</code>；他右侧的元素是 <code>nums[i] 到 nums[n - 1]</code>。<code>nums[0] 到 nums[i - 1]</code> 都要 + k，<code>nums[i] 到 nums[n - 1]</code> 都要 - k。</p><p>这样一来，</p><ul><li>最大值就是 <code>nums[n - 1] - k</code> 和 <code>nums[i - 1] + k</code> 的最大值</li><li>最小值就是 <code>nums[i] - k</code> 和 <code>nums[0] + k</code> 的最小值</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - sort<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestRangeII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>Arrays.sort(nums);<br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> max - min;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            max = Math.max(nums[i - <span class="hljs-number">1</span>] + k, nums[n - <span class="hljs-number">1</span>] - k);<br>            min = Math.min(nums[<span class="hljs-number">0</span>] + k, nums[i] - k);<br>            res = Math.min(res, max - min);<br>        &#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1545. Find Kth Bit in Nth Binary String</title>
    <link href="/posts/2502083860.html"/>
    <url>/posts/2502083860.html</url>
    
    <content type="html"><![CDATA[<p>Given two positive integers n and k, the binary string Sn is formed as follows:<br>S1 &#x3D; “0”<br>Si &#x3D; Si - 1 + “1” + reverse(invert(Si - 1)) for i &gt; 1<br>Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).</p><p>For example, the first four strings in the above sequence are:<br>S1 &#x3D; “0”<br>S2 &#x3D; “011”<br>S3 &#x3D; “0111001”<br>S4 &#x3D; “011100110110001”<br>Return the kth bit in Sn. It is guaranteed that k is valid for the given n.</p><p>Example 1:<br>Input: n &#x3D; 3, k &#x3D; 1<br>Output: “0”<br>Explanation: S3 is “0111001”.<br>The 1st bit is “0”.</p><p>Example 2:<br>Input: n &#x3D; 4, k &#x3D; 11<br>Output: “1”<br>Explanation: S4 is “011100110110001”.<br>The 11th bit is “1”.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>1 &lt;&#x3D; k &lt;&#x3D; 2n - 1</p><p>找出第 N 个二进制字符串中的第 K 位。</p><blockquote>给你两个正整数 n 和 k，二进制字符串  Sn 的形成规则如下：S1 = "0"当 i > 1 时，Si = Si-1 + "1" + reverse(invert(Si-1))其中 + 表示串联操作，reverse(x) 返回反转 x 后得到的字符串，而 invert(x) 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）。<p>例如，符合上述描述的序列的前 4 个字符串依次是：<br>S1 &#x3D; “0”<br>S2 &#x3D; “011”<br>S3 &#x3D; “0111001”<br>S4 &#x3D; “011100110110001”<br>请你返回  Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路是递归。注意这个条件，<code>当 i &gt; 1 时，Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code>，当前字符串 Si 是由 Si-1 得到的。因着这个规则，我们可以试图用递归做。</p><ul><li>如果 k 是中间那个 1，那么就返回 1</li><li>如果 k 在左半边，那么就递归去找 Si - 1 的 k 位上的字符</li><li>如果 k 在右半边，那么就递归去找 Si - 1，然后找到与 k 轴对称的那个 index，再做 invert 操作，是 0 则返回 1，是 1 则返回 0。</li></ul><p>找与 k 轴对称的那个 index 的方法，自己需要演算一下。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 每次递归就找原长度的一半即可<br>空间O(n) - 栈空间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">findKthBit</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-comment">// 如果长度是1，那么就是S1</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br><span class="hljs-comment">// 如果k恰好是中间那个digit，那么就是1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k == (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// if at the first half</span><br>        <span class="hljs-keyword">if</span> (k &lt; (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> findKthBit(n - <span class="hljs-number">1</span>, k);<br>        &#125;<br><span class="hljs-comment">// 如果k是右半边的digit，找到k在上一个字符串里的位置的reverse位置上的digit再返回他的invert的值</span><br>        <span class="hljs-keyword">return</span> findKthBit(n - <span class="hljs-number">1</span>, len - k + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-string">&#x27;1&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>string</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 908. Smallest Range I</title>
    <link href="/posts/2286244288.html"/>
    <url>/posts/2286244288.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and an integer k.</p><p>In one operation, you can choose any index i where 0 &lt;&#x3D; i &lt; nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i.</p><p>The score of nums is the difference between the maximum and minimum elements in nums.</p><p>Return the minimum score of nums after applying the mentioned operation at most once for each index in it.</p><p>Example 1:<br>Input: nums &#x3D; [1], k &#x3D; 0<br>Output: 0<br>Explanation: The score is max(nums) - min(nums) &#x3D; 1 - 1 &#x3D; 0.</p><p>Example 2:<br>Input: nums &#x3D; [0,10], k &#x3D; 2<br>Output: 6<br>Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) &#x3D; 8 - 2 &#x3D; 6.</p><p>Example 3:<br>Input: nums &#x3D; [1,3,6], k &#x3D; 3<br>Output: 0<br>Explanation: Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) &#x3D; 4 - 4 &#x3D; 0.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>0 &lt;&#x3D; k &lt;&#x3D; 104</p><p>最小差值 I。</p><blockquote>给你一个整数数组 nums，和一个整数 k 。<p>在一个操作中，您可以选择 0 &lt;&#x3D; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i ，最多 只能 应用 一次 此操作。</p><p>nums 的 分数 是 nums 中最大和最小元素的差值。 </p><p>在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意说你可以对 input 数组里任何一个数字修改一次，将 nums[i] 改为 <code>nums[i] - x</code> 和 <code>nums[i] + x</code> 范围中的任何一个数字，求 nums 中最大和最小元素的差值。</p><p>这道题有两种情况，一是 nums 中原先存在的 max 和 min 的差值就小于 2 * k，那么我们只需要把两者改为一样即可，返回 0。二是两者的差值大于 2 * k，那么结果就是 (max - k) - (min + k)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestRangeI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            min = Math.min(min, num);<br>            max = Math.max(max, num);<br>        &#125;<br><br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (max == min) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> (max - k) - (min + k);<br>        <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">0</span>, diff);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2406. Divide Intervals Into Minimum Number of Groups</title>
    <link href="/posts/2190935650.html"/>
    <url>/posts/2190935650.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D integer array intervals where intervals[i] &#x3D; [left, right] represents the inclusive interval [left, right].</p><p>You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.</p><p>Return the minimum number of groups you need to make.</p><p>Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.</p><p>Example 1:<br>Input: intervals &#x3D; [[5,10],[6,8],[1,5],[2,3],[1,10]]<br>Output: 3<br>Explanation: We can divide the intervals into the following groups:</p><ul><li>Group 1: [1, 5], [6, 8].</li><li>Group 2: [2, 3], [5, 10].</li><li>Group 3: [1, 10].<br>It can be proven that it is not possible to divide the intervals into fewer than 3 groups.</li></ul><p>Example 2:<br>Input: intervals &#x3D; [[1,3],[5,6],[8,10],[11,13]]<br>Output: 1<br>Explanation: None of the intervals overlap, so we can put all of them in one group.</p><p>Constraints:<br>1 &lt;&#x3D; intervals.length &lt;&#x3D; 105<br>intervals[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; 106</p><p>将区间分为最少组数。</p><blockquote>给你一个二维整数数组 intervals ，其中 intervals[i] = [left, right] 表示 闭 区间 [left, right] 。<p>你需要将 intervals 划分为一个或者多个区间 组 ，每个区间 只 属于一个组，且同一个组中任意两个区间 不相交 。</p><p>请你返回 最少 需要划分成多少个组。</p><p>如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 相交 的。比方说区间 [1, 5] 和 [5, 8] 相交。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题思路同会议室 II。大致思路都是排序 + 比较，只是具体做法有些区别。以下请把 left 和 right 分别理解为一个会议的开始时间和结束时间。</p><h2 id="思路一-排序-最小堆"><a href="#思路一-排序-最小堆" class="headerlink" title="思路一 - 排序 + 最小堆"></a>思路一 - 排序 + 最小堆</h2><p>初始化的时候对 input 按 开始时间 排序，然后准备一个最小堆，是用来放入所有会议的 结束时间。遍历 input 数组，因为 input 已经按 开始时间 排过序，所以对于某个 开始时间 而言，我们拿他去跟堆顶的最小的 结束时间 比较。如果 开始时间 跟 结束时间 有重叠，则说明这两个会议时间是有交集的，一定要再开一个会议室（将当前结束时间放入堆中）。照着此题的题意就是这两个区间一定不能分在同一组。最后最小堆的 size 就是会议室的数量 - 也就是分组的数量。</p><h2 id="思路二-对-left-和-right-分别排序"><a href="#思路二-对-left-和-right-分别排序" class="headerlink" title="思路二 - 对 left 和 right 分别排序"></a>思路二 - 对 left 和 right 分别排序</h2><p>对会议的 开始时间 和 结束时间 分别排序。用双指针的方式遍历 开始时间 和 结束时间。如果某个 结束时间 比当前的 开始时间 小，则说明两个会议没有交集，可以分在同一组。如果某个 结束时间 比当前的 开始时间 大，则说明两个会议有交集，就需要再加一组。最后返回组的数量。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现 - 排序 + 最小堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minGroups</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a - b);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span>[] cur = intervals[i];<br>            <span class="hljs-keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peek() &lt; cur[<span class="hljs-number">0</span>]) &#123;<br>                queue.poll();<br>            &#125;<br>            queue.offer(cur[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实现 - 对 left 和 right 分别排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minGroups</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (intervals == <span class="hljs-literal">null</span> || intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-type">int</span>[] start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            start[i] = intervals[i][<span class="hljs-number">0</span>];<br>            end[i] = intervals[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        Arrays.sort(start);<br>        Arrays.sort(end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (start[i] &lt;= end[pointer]) &#123;<br>                res++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pointer++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">252. Meeting Rooms<br>253. Meeting Rooms II<br>2406. Divide Intervals Into Minimum Number of Groups<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
      <tag>heap</tag>
      
      <tag>line sweep</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 962. Maximum Width Ramp</title>
    <link href="/posts/2923917953.html"/>
    <url>/posts/2923917953.html</url>
    
    <content type="html"><![CDATA[<p>A ramp in an integer array nums is a pair (i, j) for which i &lt; j and nums[i] &lt;&#x3D; nums[j]. The width of such a ramp is j - i.</p><p>Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.</p><p>Example 1:<br>Input: nums &#x3D; [6,0,8,2,1,5]<br>Output: 4<br>Explanation: The maximum width ramp is achieved at (i, j) &#x3D; (1, 5): nums[1] &#x3D; 0 and nums[5] &#x3D; 5.</p><p>Example 2:<br>Input: nums &#x3D; [9,8,1,0,1,9,4,0,4,1]<br>Output: 7<br>Explanation: The maximum width ramp is achieved at (i, j) &#x3D; (2, 9): nums[2] &#x3D; 1 and nums[9] &#x3D; 1.</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 5 * 104</p><p>最大宽度坡。</p><blockquote>给定一个整数数组 A，坡是元组 (i, j)，其中 i < j 且 A[i] <= A[j]。这样的坡的宽度为 j - i。<p>找出 A 中的坡的最大宽度，如果不存在，返回 0 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路是单调栈，不过这道题跟一般的单调栈题目有些不同。这道题的单调栈找的是两个距离最远的下标。其余思路参见代码注释。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxWidthRamp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 入栈的元素越来越小</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty() || nums[i] &lt; nums[stack.peekLast()]) &#123;<br>                stack.offerLast(i);<br>            &#125;<br>        &#125;<br><br><span class="hljs-comment">// 从右往左扫描，把当前元素当做 j，栈顶元素当做 i，计算宽度</span><br><span class="hljs-comment">// 如果当前元素 &gt;= 栈顶元素，则记录两者的差值，并弹出栈顶元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[j] &gt;= nums[stack.peekLast()]) &#123;<br>                res = Math.max(res, j - stack.pollLast());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2491. Divide Players Into Teams of Equal Skill</title>
    <link href="/posts/3764186800.html"/>
    <url>/posts/3764186800.html</url>
    
    <content type="html"><![CDATA[<p>You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n &#x2F; 2 teams of size 2 such that the total skill of each team is equal.</p><p>The chemistry of a team is equal to the product of the skills of the players on that team.</p><p>Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.</p><p>Example 1:<br>Input: skill &#x3D; [3,2,5,1,3,4]<br>Output: 22<br>Explanation:<br>Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.<br>The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 &#x3D; 5 + 8 + 9 &#x3D; 22.</p><p>Example 2:<br>Input: skill &#x3D; [3,4]<br>Output: 12<br>Explanation:<br>The two players form a team with a total skill of 7.<br>The chemistry of the team is 3 * 4 &#x3D; 12.</p><p>Example 3:<br>Input: skill &#x3D; [1,1,2,3]<br>Output: -1<br>Explanation:<br>There is no way to divide the players into teams such that the total skill of each team is equal.</p><p>Constraints:<br>2 &lt;&#x3D; skill.length &lt;&#x3D; 105<br>skill.length is even.<br>1 &lt;&#x3D; skill[i] &lt;&#x3D; 1000</p><p>划分技能点相等的团队。</p><blockquote>给你一个正整数数组 skill ，数组长度为 偶数 n ，其中 skill[i] 表示第 i 个玩家的技能点。将所有玩家分成 n / 2 个 2 人团队，使每一个团队的技能点之和 相等 。<p>团队的 化学反应 等于团队中玩家的技能点 乘积 。</p><p>返回所有团队的 化学反应 之和，如果无法使每个团队的技能点之和相等，则返回 -1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意题目的题设，如果 input 数组最后是能组成 n &#x2F; 2 组团队且每一个团队的技能点之和相等的话，那么技能点的和 sum &#x3D; 最小的玩家技能点 + 最大的玩家技能点。所以这里我们可以将 input 数组排序，然后用双指针的方式从两边往中间逼近。如果有任何一组技能点的和 !&#x3D; sum则说明配对失败，返回 -1。</p><p>注意题目的数据范围，res 要用 long 类型，否则会溢出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dividePlayers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] skill)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> skill.length;<br>        <span class="hljs-type">int</span>[] sorted = skill.clone();<br>        Arrays.sort(sorted);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> sorted[<span class="hljs-number">0</span>] + sorted[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> sorted[left++];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sorted[right--];<br>            <span class="hljs-keyword">if</span> (l + r != sum) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += l * r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1497. Check If Array Pairs Are Divisible by k</title>
    <link href="/posts/2043078748.html"/>
    <url>/posts/2043078748.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers arr of even length n and an integer k.</p><p>We want to divide the array into exactly n &#x2F; 2 pairs such that the sum of each pair is divisible by k.</p><p>Return true If you can find a way to do that or false otherwise.</p><p>Example 1:<br>Input: arr &#x3D; [1,2,3,4,5,10,6,7,8,9], k &#x3D; 5<br>Output: true<br>Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).</p><p>Example 2:<br>Input: arr &#x3D; [1,2,3,4,5,6], k &#x3D; 7<br>Output: true<br>Explanation: Pairs are (1,6),(2,5) and(3,4).</p><p>Example 3:<br>Input: arr &#x3D; [1,2,3,4,5,6], k &#x3D; 10<br>Output: false<br>Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.</p><p>Constraints:<br>arr.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>n is even.<br>-109 &lt;&#x3D; arr[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>检查数组对是否可以被 k 整除。</p><blockquote>给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。<p>现在需要把数组恰好分成 n &#x2F; 2 对，以使每对数字的和都能够被 k 整除。</p><p>如果存在这样的分法，请返回 true ；否则，返回 false。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如何判断某两个数字 a + b 的和是否可以被 k 整除？这里分两种情况</p><ul><li>a 和 b 各自都能被 k 整除，那么 a + b 也应该可以被 k 整除。比如 a &#x3D; 9, b &#x3D; 6, k &#x3D; 3, a + b &#x3D; 15, 15 % 3 &#x3D; 0</li><li>a 和 b 不能同时被 k 整除，但是 a % k + b % k 可以被 k 整除。比如 a &#x3D; 8, b &#x3D; 1, k &#x3D; 9, a % k + b % k &#x3D; 8 + 1 &#x3D; 9 % 9 &#x3D; 0</li></ul><p>上面的推论不难得到。这道题还有第二个需要注意的点就是 input 里是有负数的。即使有负数我们也无需担心，上面提到的模运算的结合律还是成立的。这里可以手动算一下就知道。</p><p>具体做法是这里我们需要处理一下 input 数组里的每一个数字，因为他们有正有负，这里我把他们统统处理成比 k 小的正数，然后我们找与其配对的数字的时候就会比较容易了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canArrange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i] % k;<br>            <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>) &#123;<br>                temp += k;<br>            &#125;<br>            map.put(temp, map.getOrDefault(temp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (key != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> map.get(key);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> map.getOrDefault(k - key, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (x != y) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(<span class="hljs-number">0</span>) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 641. Design Circular Deque</title>
    <link href="/posts/3708123366.html"/>
    <url>/posts/3708123366.html</url>
    
    <content type="html"><![CDATA[<p>Design your implementation of the circular double-ended queue (deque).</p><p>Implement the MyCircularDeque class:<br>MyCircularDeque(int k) Initializes the deque with a maximum size of k.<br>boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.<br>boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.<br>boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.<br>boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.<br>int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.<br>int getRear() Returns the last item from Deque. Returns -1 if the deque is empty.<br>boolean isEmpty() Returns true if the deque is empty, or false otherwise.<br>boolean isFull() Returns true if the deque is full, or false otherwise.</p><p>Example 1:<br>Input<br>[“MyCircularDeque”, “insertLast”, “insertLast”, “insertFront”, “insertFront”, “getRear”, “isFull”, “deleteLast”, “insertFront”, “getFront”]<br>[[3], [1], [2], [3], [4], [], [], [], [4], []]<br>Output<br>[null, true, true, true, false, 2, true, true, true, 4]</p><p>Explanation<br>MyCircularDeque myCircularDeque &#x3D; new MyCircularDeque(3);<br>myCircularDeque.insertLast(1);  &#x2F;&#x2F; return True<br>myCircularDeque.insertLast(2);  &#x2F;&#x2F; return True<br>myCircularDeque.insertFront(3); &#x2F;&#x2F; return True<br>myCircularDeque.insertFront(4); &#x2F;&#x2F; return False, the queue is full.<br>myCircularDeque.getRear();      &#x2F;&#x2F; return 2<br>myCircularDeque.isFull();       &#x2F;&#x2F; return True<br>myCircularDeque.deleteLast();   &#x2F;&#x2F; return True<br>myCircularDeque.insertFront(4); &#x2F;&#x2F; return True<br>myCircularDeque.getFront();     &#x2F;&#x2F; return 4</p><p>Constraints:<br>1 &lt;&#x3D; k &lt;&#x3D; 1000<br>0 &lt;&#x3D; value &lt;&#x3D; 1000<br>At most 2000 calls will be made to insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.</p><p>设计循环双端队列。</p><blockquote>设计实现双端队列。<p>实现 MyCircularDeque 类:</p><ul><li>MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。</li><li>boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。</li><li>boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。</li><li>boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。</li><li>boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。</li><li>int getFront() )：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。</li><li>int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。</li><li>boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false  。</li><li>boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。</blockquote></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题思路类似 622 题，无非是把普通的 queue 变成 dequeue。做这道题之前可以先做一些相关题目。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    Node prev;<br>    Node next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularDeque</span> &#123;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> k;<br>    Node head;<br>    Node tail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.k = k;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertFront</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        newNode.next = head.next;<br>        newNode.prev = head;<br>        head.next.prev = newNode;<br>        head.next = newNode;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertLast</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isFull()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        newNode.next = tail;<br>        newNode.prev = tail.prev;<br>        tail.prev.next = newNode;<br>        tail.prev = newNode;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        head.next.next.prev = head;<br>        head.next = head.next.next;<br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deleteLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        tail.prev.prev.next = tail;<br>        tail.prev = tail.prev.prev;<br>        size--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.next.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> tail.prev.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size == k;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCircularDeque object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span><br><span class="hljs-comment"> * boolean param_1 = obj.insertFront(value);</span><br><span class="hljs-comment"> * boolean param_2 = obj.insertLast(value);</span><br><span class="hljs-comment"> * boolean param_3 = obj.deleteFront();</span><br><span class="hljs-comment"> * boolean param_4 = obj.deleteLast();</span><br><span class="hljs-comment"> * int param_5 = obj.getFront();</span><br><span class="hljs-comment"> * int param_6 = obj.getRear();</span><br><span class="hljs-comment"> * boolean param_7 = obj.isEmpty();</span><br><span class="hljs-comment"> * boolean param_8 = obj.isFull();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">146. LRU Cache<br>460. LFU Cache<br>622. Design Circular Queue<br>641. Design Circular Deque<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
      <tag>linked list</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2414. Length of the Longest Alphabetical Continuous Substring</title>
    <link href="/posts/4164148831.html"/>
    <url>/posts/4164148831.html</url>
    
    <content type="html"><![CDATA[<p>An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string “abcdefghijklmnopqrstuvwxyz”.</p><p>For example, “abc” is an alphabetical continuous string, while “acb” and “za” are not.<br>Given a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.</p><p>Example 1:<br>Input: s &#x3D; “abacaba”<br>Output: 2<br>Explanation: There are 4 distinct continuous substrings: “a”, “b”, “c” and “ab”.<br>“ab” is the longest continuous substring.</p><p>Example 2:<br>Input: s &#x3D; “abcde”<br>Output: 5<br>Explanation: “abcde” is the longest continuous substring.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of only English lowercase letters.</p><p>最长的字母序连续子字符串的长度。</p><blockquote>字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 "abcdefghijklmnopqrstuvwxyz" 的任意子字符串都是 字母序连续字符串 。<p>例如，”abc” 是一个字母序连续字符串，而 “acb” 和 “za” 不是。<br>给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断两个字母是否是字母表中连续的字母，就是去判断他们 ASCII 码的差值是否为 1。而且这道题降低了难度，”za” 这样的字母序是不算作连续的字符串的。</p><p>思路是双指针，我们需要两个指针，左指针指向当前字母，右指针从下一个字母开始一直往右走，判断两个指针指向的字母的 ASCII 码的差值是否等于两个指针下标的差。如果是，则说明这两个字母是连续的，我们需要更新最长的字母序连续子字符串的长度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)，n 是字符串 s 的长度。<br>空间O(1)，只需要常数的空间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestContinuousSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.length()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; i - start == s.charAt(i) - s.charAt(start)) &#123;<br>                i++;<br>            &#125;<br>            res = Math.max(res, i - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种更简便的做法是用 for 循环，判断当前字母的 ASCII 码是否比上一个字母的 ASCII 码大 1，如果是，则说明这两个字母是连续的，我们需要更新最长的字母序连续子字符串的长度；如果不是则说明这两个字母不是连续的，我们需要重新开始。</p><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestContinuousSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-keyword">if</span> (s.charAt(i) - s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>count++;<br>res = Math.max(res, count);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>count = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 884. Uncommon Words from Two Sentences</title>
    <link href="/posts/1381901360.html"/>
    <url>/posts/1381901360.html</url>
    
    <content type="html"><![CDATA[<p>A sentence is a string of single-space separated words where each word consists only of lowercase letters.</p><p>A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p><p>Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.</p><p>Example 1:<br>Input: s1 &#x3D; “this apple is sweet”, s2 &#x3D; “this apple is sour”<br>Output: [“sweet”,”sour”]</p><p>Explanation:<br>The word “sweet” appears only in s1, while the word “sour” appears only in s2.</p><p>Example 2:<br>Input: s1 &#x3D; “apple apple”, s2 &#x3D; “banana”<br>Output: [“banana”]</p><p>Constraints:<br>1 &lt;&#x3D; s1.length, s2.length &lt;&#x3D; 200<br>s1 and s2 consist of lowercase English letters and spaces.<br>s1 and s2 do not have leading or trailing spaces.<br>All the words in s1 and s2 are separated by a single space.</p><p>两句话中的不常见单词。</p><blockquote>句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。<p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。</p><p>给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是让我们找某些单词，这些单词需要在其中一个句子中恰好出现一次，在另一个句子中却没有出现。这个条件等同于这些要找的单词在<strong>全局只出现一次</strong>。</p><p>我们可以用一个HashMap来统计每个单词出现的次数，然后遍历两个句子，统计每个单词出现的次数，如果出现次数为1，则加入到结果集中。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] uncommonFromSentences(String s1, String s2) &#123;<br>        HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : s1.split(<span class="hljs-string">&quot; &quot;</span>)) &#123;<br>            map.put(word, map.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (String word : s2.split(<span class="hljs-string">&quot; &quot;</span>)) &#123;<br>            map.put(word, map.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : s1.split(<span class="hljs-string">&quot; &quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(word) == <span class="hljs-number">1</span>) &#123;<br>                list.add(word);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String word : s2.split(<span class="hljs-string">&quot; &quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(word) == <span class="hljs-number">1</span>) &#123;<br>                list.add(word);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        String[] res = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2419. Longest Subarray With Maximum Bitwise AND</title>
    <link href="/posts/463918335.html"/>
    <url>/posts/463918335.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums of size n.</p><p>Consider a non-empty subarray from nums that has the maximum possible bitwise AND.</p><p>In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.<br>Return the length of the longest such subarray.</p><p>The bitwise AND of an array is the bitwise AND of all the numbers in it.</p><p>A subarray is a contiguous sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,3,2,2]<br>Output: 2<br>Explanation:<br>The maximum possible bitwise AND of a subarray is 3.<br>The longest subarray with that value is [3,3], so we return 2.</p><p>Example 2:<br>Input: nums &#x3D; [1,2,3,4]<br>Output: 1<br>Explanation:<br>The maximum possible bitwise AND of a subarray is 4.<br>The longest subarray with that value is [4], so we return 1.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 106</p><p>按位与最大的最长子数组。</p><blockquote>给你一个长度为 n 的整数数组 nums 。<p>考虑 nums 中进行 按位与（bitwise AND）运算得到的值 最大 的 非空 子数组。</p><p>换句话说，令 k 是 nums 任意 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。<br>返回满足要求的 最长 子数组的长度。</p><p>数组的按位与就是对数组中的所有数字进行按位与运算。</p><p>子数组 是数组中的一个连续元素序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考察的是对位运算的敏感度吧我觉得。注意 AND 运算有一个特点，假如你有一个足够大的数字，比如 15 好了，他的二进制表达是 1111（四个 1）。如果 15 是数组里最大的数字，那么他跟任何其他数字做 AND 操作的结果都只会让结果变得更小，因为其他比 15 小的数字的二进制表达里面包含 0，与 15 AND 之后，结果只会比 15 更小。</p><p>所以这道题我们找到数组最大值 max 之后，需要判断连续的 max 到底有几个。最后返回最长的子数组的长度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// First pass: find the maximum element</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            max = Math.max(max, num);<br>        &#125;<br><br>        <span class="hljs-comment">// Second pass: count the longest subarray of max elements</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == max) &#123;<br>                cnt++;<br>                res = Math.max(res, cnt);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// reset count when encountering a different element</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2326. Spiral Matrix IV</title>
    <link href="/posts/3244292270.html"/>
    <url>/posts/3244292270.html</url>
    
    <content type="html"><![CDATA[<p>You are given two integers m and n, which represent the dimensions of a matrix.</p><p>You are also given the head of a linked list of integers.</p><p>Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.</p><p>Return the generated matrix.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg" alt="Example 1"><br>Input: m &#x3D; 3, n &#x3D; 5, head &#x3D; [3,0,2,6,8,1,7,9,4,2,5,5,0]<br>Output: [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]<br>Explanation: The diagram above shows how the values are printed in the matrix.<br>Note that the remaining spaces in the matrix are filled with -1.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg" alt="Example 2"><br>Input: m &#x3D; 1, n &#x3D; 4, head &#x3D; [0,1,2]<br>Output: [[0,1,2,-1]]<br>Explanation: The diagram above shows how the values are printed from left to right in the matrix.<br>The last space in the matrix is set to -1.</p><p>Constraints:<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>1 &lt;&#x3D; m * n &lt;&#x3D; 105<br>The number of nodes in the list is in the range [1, m * n].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>螺旋矩阵 IV。</p><blockquote>给你两个整数：m 和 n ，表示矩阵的维数。<p>另给你一个整数链表的头节点 head 。</p><p>请你生成一个大小为 m x n 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 左上角 开始、顺时针 按 螺旋 顺序填充。如果还存在剩余的空格，则用 -1 填充。</p><p>返回生成的矩阵。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>还是按照类似54题那样的遍历方式，无非是把 node.val 放入坐标里。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn) - output matrix</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] spiralMatrix(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, ListNode head) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">// initial the matrix with -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-comment">// left to right</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>res[top][i] = cur.val;<br>cur = cur.next;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>top++;<br><br>            <span class="hljs-comment">// right to bottom</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>res[i][right] = cur.val;<br>cur = cur.next;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>right--;<br><br>            <span class="hljs-comment">// right to left</span><br>            <span class="hljs-keyword">if</span> (top &lt;= bottom) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>res[bottom][i] = cur.val;<br>cur = cur.next;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>bottom--;<br><br>            <span class="hljs-comment">// bottom to top</span><br>            <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br><span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>res[i][left] = cur.val;<br>cur = cur.next;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>left++;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>linked list</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 885. Spiral Matrix III</title>
    <link href="/posts/1411971418.html"/>
    <url>/posts/1411971418.html</url>
    
    <content type="html"><![CDATA[<p>You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.</p><p>You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid’s boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.</p><p>Return an array of coordinates representing the positions of the grid in the order you visited them.</p><p>Example 1:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png" alt="Example 1"><br>Input: rows &#x3D; 1, cols &#x3D; 4, rStart &#x3D; 0, cStart &#x3D; 0<br>Output: [[0,0],[0,1],[0,2],[0,3]]</p><p>Example 2:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png" alt="Example 2"><br>Input: rows &#x3D; 5, cols &#x3D; 6, rStart &#x3D; 1, cStart &#x3D; 4<br>Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</p><p>Constraints:<br>1 &lt;&#x3D; rows, cols &lt;&#x3D; 100<br>0 &lt;&#x3D; rStart &lt; rows<br>0 &lt;&#x3D; cStart &lt; cols</p><p>螺旋矩阵 III。</p><blockquote>在 rows x cols 的网格上，你从单元格 (rStart, cStart) 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。<p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 rows x cols 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题题意不难理解，但是有一个不太直观的地方是，我们在螺旋行走的时候，每一个方向到底走几步就可以换方向了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(r<em>c)<br>空间O(r</em>c)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] spiralMatrixIII(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> rStart, <span class="hljs-type">int</span> cStart) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rows * cols][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        res[index++] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; rStart, cStart &#125;;<br><br>        <span class="hljs-comment">// directions, right, down, left, up</span><br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123; &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> &#125;, &#123; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125; &#125;;<br>        <span class="hljs-comment">// 步长</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rStart;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cStart;<br>        <span class="hljs-keyword">while</span> (index &lt; rows * cols) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span>[] dir = dirs[i];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; step; j++) &#123;<br>                    r += dir[<span class="hljs-number">0</span>];<br>                    c += dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 如果这个坐标在结果集的范围内，则把这个坐标加入结果集</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; rows &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; cols) &#123;<br>                        res[index++] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; r, c &#125;;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 往左走和往右走的时候，步长要+1</span><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == <span class="hljs-number">3</span>) &#123;<br>                    step++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2390. Removing Stars From a String</title>
    <link href="/posts/2668463127.html"/>
    <url>/posts/2668463127.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s, which contains stars *.</p><p>In one operation, you can:<br>Choose a star in s.<br>Remove the closest non-star character to its left, as well as remove the star itself.<br>Return the string after all stars have been removed.</p><p>Note:<br>The input will be generated such that the operation is always possible.<br>It can be shown that the resulting string will always be unique.</p><p>Example 1:<br>Input: s &#x3D; “leet*<em>cod</em>e”<br>Output: “lecoe”<br>Explanation: Performing the removals from left to right:</p><ul><li>The closest character to the 1st star is ‘t’ in “leet*<em>cod</em>e”. s becomes “lee<em>cod</em>e”.</li><li>The closest character to the 2nd star is ‘e’ in “lee<em>cod</em>e”. s becomes “lecod*e”.</li><li>The closest character to the 3rd star is ‘d’ in “lecod*e”. s becomes “lecoe”.<br>There are no more stars, so we return “lecoe”.</li></ul><p>Example 2:<br>Input: s &#x3D; “erase*****”<br>Output: “”<br>Explanation: The entire string is removed, so we return an empty string.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of lowercase English letters and stars *.<br>The operation above can be performed on s.</p><p>从字符串中移除星号。</p><blockquote>给你一个包含若干星号 * 的字符串 s 。<p>在一步操作中，你可以：</p><p>选中 s 中的一个星号。<br>移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。<br>返回移除 所有 星号之后的字符串。</p><p>注意：</p><p>生成的输入保证总是可以执行题面中描述的操作。<br>可以证明结果字符串是唯一的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/removing-stars-from-a-string">https://leetcode.cn/problems/removing-stars-from-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 stack。如果遇到字母则入栈；遇到星号的时候，如果栈内有字母则弹出，没有字母则可以直接丢弃星号。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - stack</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeStars</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; !queue.isEmpty()) &#123;<br>                queue.pollLast();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.offerLast(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            sb.append(queue.pollFirst());<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2181. Merge Nodes in Between Zeros</title>
    <link href="/posts/3237274235.html"/>
    <url>/posts/3237274235.html</url>
    
    <content type="html"><![CDATA[<p>You are given the head of a linked list, which contains a series of integers separated by 0’s. The beginning and end of the linked list will have Node.val &#x3D;&#x3D; 0.</p><p>For every two consecutive 0’s, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0’s.</p><p>Return the head of the modified linked list.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png" alt="Example 1"><br>Input: head &#x3D; [0,3,1,0,4,5,2,0]<br>Output: [4,11]<br>Explanation:<br>The above figure represents the given linked list. The modified list contains</p><ul><li>The sum of the nodes marked in green: 3 + 1 &#x3D; 4.</li><li>The sum of the nodes marked in red: 4 + 5 + 2 &#x3D; 11.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png" alt="Example 2"><br>Input: head &#x3D; [0,1,0,3,0,2,2,0]<br>Output: [1,3,4]<br>Explanation:<br>The above figure represents the given linked list. The modified list contains</p><ul><li>The sum of the nodes marked in green: 1 &#x3D; 1.</li><li>The sum of the nodes marked in red: 3 &#x3D; 3.</li><li>The sum of the nodes marked in yellow: 2 + 2 &#x3D; 4.</li></ul><p>Constraints:<br>The number of nodes in the list is in the range [3, 2 * 105].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>There are no two consecutive nodes with Node.val &#x3D;&#x3D; 0.<br>The beginning and end of the linked list have Node.val &#x3D;&#x3D; 0.</p><p>合并零之间的节点。</p><blockquote>给你一个链表的头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。<p>对于每两个相邻的 0 ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。</p><p>返回修改后链表的头节点 head 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是链表类的简单题，请直接参考代码注释。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeNodes</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 遇到0就开始计算0之间的node的和</span><br>            <span class="hljs-keyword">if</span> (cur.val == <span class="hljs-number">0</span>) &#123;<br>                sum = <span class="hljs-number">0</span>;<br>                cur = cur.next;<br>                <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.val != <span class="hljs-number">0</span>) &#123;<br>                    sum += cur.val;<br>                    cur = cur.next;<br>                &#125;<br><span class="hljs-comment">// 遇到下一个0或者list结尾就把之前计算的和放到新的node中</span><br>                <span class="hljs-keyword">if</span> (sum != <span class="hljs-number">0</span>) &#123;<br>                    p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>                    p = p.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>linked list</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3142. Check if Grid Satisfies Conditions</title>
    <link href="/posts/135857717.html"/>
    <url>/posts/135857717.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is:<br>Equal to the cell below it, i.e. grid[i][j] &#x3D;&#x3D; grid[i + 1][j] (if it exists).<br>Different from the cell to its right, i.e. grid[i][j] !&#x3D; grid[i][j + 1] (if it exists).<br>Return true if all the cells satisfy these conditions, otherwise, return false.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2024/04/15/examplechanged.png" alt="Example 1"><br>Input: grid &#x3D; [[1,0,2],[1,0,2]]<br>Output: true</p><p>Explanation:<br>All the cells in the grid satisfy the conditions.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2024/03/27/example21.png" alt="Example 2"><br>Input: grid &#x3D; [[1,1,1],[0,0,0]]<br>Output: false</p><p>Explanation:<br>All cells in the first row are equal.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2024/03/31/changed.png" alt="Example 3"><br>Input: grid &#x3D; [[1],[2],[3]]<br>Output: false</p><p>Explanation:<br>Cells in the first column have different values.</p><p>Constraints:<br>1 &lt;&#x3D; n, m &lt;&#x3D; 10<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 9</p><p>判断矩阵是否满足条件。</p><blockquote>给你一个大小为 m x n 的二维矩阵 grid 。你需要判断每一个格子 grid[i][j] 是否满足：如果它下面的格子存在，那么它需要等于它下面的格子，也就是 grid[i][j] == grid[i + 1][j] 。如果它右边的格子存在，那么它需要不等于它右边的格子，也就是 grid[i][j] != grid[i][j + 1] 。如果 所有 格子都满足以上条件，那么返回 true ，否则返回 false 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及算法，就是矩阵的遍历。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">satisfiesConditions</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// grid[i][j] == grid[i + 1][j]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] != grid[i + <span class="hljs-number">1</span>][j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// grid[i][j] != grid[i][j + 1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == grid[i][j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2053. Kth Distinct String in an Array</title>
    <link href="/posts/2933557121.html"/>
    <url>/posts/2933557121.html</url>
    
    <content type="html"><![CDATA[<p>A distinct string is a string that is present only once in an array.</p><p>Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string “”.</p><p>Note that the strings are considered in the order in which they appear in the array.</p><p>Example 1:<br>Input: arr &#x3D; [“d”,”b”,”c”,”b”,”c”,”a”], k &#x3D; 2<br>Output: “a”<br>Explanation:<br>The only distinct strings in arr are “d” and “a”.<br>“d” appears 1st, so it is the 1st distinct string.<br>“a” appears 2nd, so it is the 2nd distinct string.<br>Since k &#x3D;&#x3D; 2, “a” is returned. </p><p>Example 2:<br>Input: arr &#x3D; [“aaa”,”aa”,”a”], k &#x3D; 1<br>Output: “aaa”<br>Explanation:<br>All strings in arr are distinct, so the 1st string “aaa” is returned.</p><p>Example 3:<br>Input: arr &#x3D; [“a”,”b”,”a”], k &#x3D; 3<br>Output: “”<br>Explanation:<br>The only distinct string is “b”. Since there are fewer than 3 distinct strings, we return an empty string “”.</p><p>Constraints:<br>1 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; arr[i].length &lt;&#x3D; 5<br>arr[i] consists of lowercase English letters.</p><p>数组中第 K 个独一无二的字符串。</p><blockquote>独一无二的字符串 指的是在一个数组中只出现过 一次 的字符串。给你一个字符串数组 arr 和一个整数 k ，请你返回 arr 中第 k 个 独一无二的字符串 。如果 少于 k 个独一无二的字符串，那么返回 空字符串 "" 。注意，按照字符串在原数组中的 顺序 找到第 k 个独一无二字符串。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要遍历两遍 input 数组。第一遍遍历，用 hashmap 记录每个不同字符的出现次数。第二次遍历，挑出所有只出现过一次的字符串，放在一个 list 中。遍历结束后，如果 list 的长度不足 k，则返回空字符串；反之则返回第 k 个字符串。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">kthDistinct</span><span class="hljs-params">(String[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : arr) &#123;<br>            map.put(str, map.getOrDefault(str, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : arr) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(str) == <span class="hljs-number">1</span>) &#123;<br>                res.add(str);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res.size() &lt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.get(k - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2134. Minimum Swaps to Group All 1s Together II</title>
    <link href="/posts/289974058.html"/>
    <url>/posts/289974058.html</url>
    
    <content type="html"><![CDATA[<p>A swap is defined as taking two distinct positions in an array and swapping the values in them.</p><p>A circular array is defined as an array where we consider the first element and the last element to be adjacent.</p><p>Given a binary circular array nums, return the minimum number of swaps required to group all 1’s present in the array together at any location.</p><p>Example 1:<br>Input: nums &#x3D; [0,1,0,1,1,0,0]<br>Output: 1<br>Explanation: Here are a few of the ways to group all the 1’s together:<br>[0,0,1,1,1,0,0] using 1 swap.<br>[0,1,1,1,0,0,0] using 1 swap.<br>[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).<br>There is no way to group all 1’s together with 0 swaps.<br>Thus, the minimum number of swaps required is 1.</p><p>Example 2:<br>Input: nums &#x3D; [0,1,1,1,0,0,1,1,0]<br>Output: 2<br>Explanation: Here are a few of the ways to group all the 1’s together:<br>[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).<br>[1,1,1,1,1,0,0,0,0] using 2 swaps.<br>There is no way to group all 1’s together with 0 or 1 swaps.<br>Thus, the minimum number of swaps required is 2.</p><p>Example 3:<br>Input: nums &#x3D; [1,1,0,0,1]<br>Output: 0<br>Explanation: All the 1’s are already grouped together due to the circular property of the array.<br>Thus, the minimum number of swaps required is 0.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>nums[i] is either 0 or 1.</p><p>最少交换次数来组合所有的 1 II。</p><blockquote>交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。给你一个 二进制环形 数组 nums ，返回在 任意位置 将数组中的所有 1 聚集在一起需要的最少交换次数。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题跟版本一 1151 题很像，唯一不同的地方是题目多了一个条件，给的 input 是环形数组。环形数组中找连续的 1 的个数其实是比较难的，因为最优解有可能是断开的（一部分 1 在数组起点，一部分 1 在数组终点），但是我们可以换一种思路。因为 input 数组中只有 0 和 1 两种数字，那么我们可以试着比较把所有的 1 聚集在一起的开销少还是把所有的 0 聚集在一起的开销少。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">zeros</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>                zeros++;<br>            &#125;<br>        &#125;<br>        ones = n - zeros;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> helper(nums, <span class="hljs-number">0</span>, zeros);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> helper(nums, <span class="hljs-number">1</span>, ones);<br>        <span class="hljs-keyword">return</span> Math.min(a, b);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[end] == target) &#123;<br>                count++;<br>            &#125;<br>            end++;<br>            <span class="hljs-keyword">if</span> (end - start == p) &#123;<br>                res = Math.min(res, p - count);<br>                <span class="hljs-keyword">if</span> (nums[start] == target) &#123;<br>                    count--;<br>                &#125;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1151. Minimum Swaps to Group All 1s Together<br>2134. Minimum Swaps to Group All 1s Together II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1380. Lucky Numbers in a Matrix</title>
    <link href="/posts/4020803870.html"/>
    <url>/posts/4020803870.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.</p><p>A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</p><p>Example 1:<br>Input: matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]<br>Output: [15]<br>Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.</p><p>Example 2:<br>Input: matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]]<br>Output: [12]<br>Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.</p><p>Example 3:<br>Input: matrix &#x3D; [[7,8],[1,2]]<br>Output: [7]<br>Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.</p><p>Constraints:<br>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 50<br>1 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 105.<br>All elements in the matrix are distinct.</p><p>矩阵中的幸运数。</p><blockquote>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。<p>幸运数 是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大</blockquote></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道二维矩阵的基础题，正常遍历这个二维数组。然后我们需要用两个一维数组分别记录每一行的最大值和每一列的最大值。接着我们再次遍历每一行的最大值和每一列的最大值，如果某一行的最大值恰巧是某一列的最小值，则把这个值加入结果集。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(m + n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">luckyNumbers</span> <span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        Arrays.fill(rows, Integer.MAX_VALUE);<br>        <span class="hljs-type">int</span>[] cols = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(cols, Integer.MIN_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                rows[i] = Math.min(rows[i], val);<br>                cols[j] = Math.max(cols[j], val);<br>            &#125;<br>        &#125;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                <span class="hljs-keyword">if</span> (rows[i] == cur &amp;&amp; cols[j] == cur) &#123;<br>                    res.add(cur);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3096. Minimum Levels to Gain More Points</title>
    <link href="/posts/97181666.html"/>
    <url>/posts/97181666.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary array possible of length n.</p><p>Alice and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] &#x3D;&#x3D; 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it.</p><p>At the start of the game, Alice will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels.</p><p>Alice wants to know the minimum number of levels she should play to gain more points than Bob, if both players play optimally to maximize their points.</p><p>Return the minimum number of levels Alice should play to gain more points. If this is not possible, return -1.</p><p>Note that each player must play at least 1 level.</p><p>Example 1:<br>Input: possible &#x3D; [1,0,1,0]<br>Output: 1</p><p>Explanation:<br>Let’s look at all the levels that Alice can play up to:</p><p>If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has -1 + 1 - 1 &#x3D; -1 point.<br>If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 1 - 1 &#x3D; 0 points, while Bob has 1 - 1 &#x3D; 0 points.</p><p>If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 1 - 1 + 1 &#x3D; 1 point, while Bob has -1 point.<br>Alice must play a minimum of 1 level to gain more points.</p><p>Example 2:<br>Input: possible &#x3D; [1,1,1,1,1]<br>Output: 3</p><p>Explanation:<br>Let’s look at all the levels that Alice can play up to:</p><p>If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has 4 points.<br>If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 2 points, while Bob has 3 points.<br>If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 3 points, while Bob has 2 points.<br>If Alice plays till level 3 and Bob plays the rest of the levels, Alice has 4 points, while Bob has 1 point.<br>Alice must play a minimum of 3 levels to gain more points.</p><p>Example 3:<br>Input: possible &#x3D; [0,0]<br>Output: -1</p><p>Explanation:<br>The only possible way is for both players to play 1 level each. Alice plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Alice can’t gain more points than Bob.</p><p>Constraints:<br>2 &lt;&#x3D; n &#x3D;&#x3D; possible.length &lt;&#x3D; 105<br>possible[i] is either 0 or 1.</p><p>得到更多分数的最少关卡数目。</p><blockquote>给你一个长度为 n 的二进制数组 possible 。<p>Alice 和 Bob 正在玩一个有 n 个关卡的游戏，游戏中有一些关卡是 困难 模式，其他的关卡是 简单 模式。如果 possible[i] &#x3D;&#x3D; 0 ，那么第 i 个关卡是 困难 模式。一个玩家通过一个简单模式的关卡可以获得 1 分，通过困难模式的关卡将失去 1 分。</p><p>游戏的一开始，Alice 将从第 0 级开始 按顺序 完成一些关卡，然后 Bob 会完成剩下的所有关卡。</p><p>假设两名玩家都采取最优策略，目的是 最大化 自己的得分，Alice 想知道自己 最少 需要完成多少个关卡，才能获得比 Bob 更多的分数。</p><p>请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。</p><p>注意，每个玩家都至少需要完成 1 个关卡。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。Alice 需要确保自己在尽可能少完成关卡的情况下得分比 Bob 高，那么当 Alice 的得分第一次比 Bob 高的时候，我们就可以停下了，这个位置就是题目要求我们找的位置。</p><p>具体的做法是我们需要遍历 input 数组两遍。第一次遍历的时候统计整个数组的前缀和，记为 sum。第二次遍历的时候我们一边遍历，一边比较 Alice 和 Bob 的分数差。其中 Bob 在某个 index 的分数 &#x3D; sum - Alice 在这个 index 停下的分数。注意第二次遍历的时候 for 循环要在 n - 1 停下，因为题目要求每个玩家都至少需要完成 1 个关卡。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLevels</span><span class="hljs-params">(<span class="hljs-type">int</span>[] possible)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> possible.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> possible[i] == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            sum += score;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> possible[i] == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            alice += score;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> sum - alice;<br>            <span class="hljs-keyword">if</span> (alice &gt; bob) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2196. Create Binary Tree From Descriptions</title>
    <link href="/posts/3080780969.html"/>
    <url>/posts/3080780969.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D integer array descriptions where descriptions[i] &#x3D; [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,<br>If isLefti &#x3D;&#x3D; 1, then childi is the left child of parenti.<br>If isLefti &#x3D;&#x3D; 0, then childi is the right child of parenti.<br>Construct the binary tree described by descriptions and return its root.</p><p>The test cases will be generated such that the binary tree is valid.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png" alt="Example 1"><br>Input: descriptions &#x3D; [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]<br>Output: [50,20,80,15,17,19]<br>Explanation: The root node is the node with value 50 since it has no parent.<br>The resulting binary tree is shown in the diagram.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png" alt="Example 2"><br>Input: descriptions &#x3D; [[1,2,1],[2,3,0],[3,4,1]]<br>Output: [1,2,null,null,3,4]<br>Explanation: The root node is the node with value 1 since it has no parent.<br>The resulting binary tree is shown in the diagram.</p><p>Constraints:<br>1 &lt;&#x3D; descriptions.length &lt;&#x3D; 104<br>descriptions[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; parent, child &lt;&#x3D; 105<br>0 &lt;&#x3D; isLeft &lt;&#x3D; 1<br>The binary tree described by descriptions is valid.</p><p>根据描述创建二叉树。</p><blockquote>给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parent, child, isLeft] 表示 parent 是 child 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：<p>如果 isLeft &#x3D;&#x3D; 1 ，那么 child 就是 parent 的左子节点。<br>如果 isLeft &#x3D;&#x3D; 0 ，那么 child 就是 parent 的右子节点。<br>请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。</p><p>测试用例会保证可以构造出 有效 的二叉树。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是哈希表 + 模拟。遍历 input 数组，因为题目说了二叉树中各节点的值互不相同，所以这里我们可以用一个哈希表记录&lt;node val, TreeNode&gt;的关系。因为每个 description 展示的是两个 node 之间的关系，所以在用哈希表存好&lt;node val, TreeNode&gt;之后，我们还可以连接这两个节点，以保存节点之间的父子关系。</p><p>这里同时我用了一个 visited 数组，记录所有遍历到的 child 节点。最后我再次遍历这个 visited 数组的时候，唯一一个没有被遍历到的值就是根节点的值 root.val，所以最后返回的是 map.get(root.val) 就是根节点。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">createBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] descriptions)</span> &#123;<br>HashMap&lt;Integer, TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">int</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100001</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; descriptions.length; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> descriptions[i][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> descriptions[i][<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">isLeft</span> <span class="hljs-operator">=</span> descriptions[i][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">if</span> (!map.containsKey(parent)) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(parent);<br>map.put(parent, node);<br>&#125;<br><span class="hljs-keyword">if</span> (!map.containsKey(child)) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(child);<br>map.put(child, node);<br>&#125;<br><br><span class="hljs-comment">// build parent, child relationship</span><br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> map.get(parent);<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> map.get(child);<br><span class="hljs-comment">// visited数组记录所有遍历过的child node</span><br>visited[child] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (isLeft == <span class="hljs-number">1</span>) &#123;<br>p.left = c;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p.right = c;<br>&#125;<br>&#125;<br><br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br><span class="hljs-keyword">for</span> (Integer i : map.keySet()) &#123;<br><span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>) &#123;<br>root = map.get(i);<br><span class="hljs-keyword">return</span> root;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2938. Separate Black and White Balls</title>
    <link href="/posts/1903118322.html"/>
    <url>/posts/1903118322.html</url>
    
    <content type="html"><![CDATA[<p>There are n balls on a table, each ball has a color black or white.</p><p>You are given a 0-indexed binary string s of length n, where 1 and 0 represent black and white balls, respectively.</p><p>In each step, you can choose two adjacent balls and swap them.</p><p>Return the minimum number of steps to group all the black balls to the right and all the white balls to the left.</p><p>Example 1:<br>Input: s &#x3D; “101”<br>Output: 1<br>Explanation: We can group all the black balls to the right in the following way:</p><ul><li>Swap s[0] and s[1], s &#x3D; “011”.<br>Initially, 1s are not grouped together, requiring at least 1 step to group them to the right.</li></ul><p>Example 2:<br>Input: s &#x3D; “100”<br>Output: 2<br>Explanation: We can group all the black balls to the right in the following way:</p><ul><li>Swap s[0] and s[1], s &#x3D; “010”.</li><li>Swap s[1] and s[2], s &#x3D; “001”.<br>It can be proven that the minimum number of steps needed is 2.</li></ul><p>Example 3:<br>Input: s &#x3D; “0111”<br>Output: 0<br>Explanation: All the black balls are already grouped to the right.</p><p>Constraints:<br>1 &lt;&#x3D; n &#x3D;&#x3D; s.length &lt;&#x3D; 105<br>s[i] is either ‘0’ or ‘1’.</p><p>区分黑球与白球。</p><blockquote>桌子上有 n 个球，每个球的颜色不是黑色，就是白色。<p>给你一个长度为 n 、下标从 0 开始的二进制字符串 s，其中 1 和 0 分别代表黑色和白色的球。</p><p>在每一步中，你可以选择两个相邻的球并交换它们。</p><p>返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 最小步数」。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是追击型双指针。题目要求我们把所有的黑球（1）都移到右侧，所有白球（0）都移到左侧。同时注意交换的原则，一个黑球移到右侧的前提是同时有一个白球移到左侧，所以一个黑球如果被移动了，那么同时涉及到的白球就不要再重复计算移动次数了。</p><p>题目最终的目标是让球形成类似如下这样，0 在左侧，1 在右侧。<br><code>000000011111111</code></p><p>具体的做法是从左往右遍历 input 字符串，如果当前遇到的是一个白球（0），那么我要尽可能地把他往左移动。这里我需要两个指针 i 和 j，i 表示的是我当前遍历到的位置，j 表示的是下一个白球可以被移动到的位置。那么在当我遇到某一个白球的时候，这个白球移动的距离 &#x3D; i - j。每遇到一个白球我就做一次这个动作，并把这个移动的距离累加到结果里。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumSteps</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-keyword">while</span> (i &lt; n) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> s.charAt(i);<br><span class="hljs-comment">// 遇到白色</span><br><span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>res += i - j;<br>j++;<br>&#125;<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2028. Find Missing Observations</title>
    <link href="/posts/2736396816.html"/>
    <url>/posts/2736396816.html</url>
    
    <content type="html"><![CDATA[<p>You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.</p><p>You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.</p><p>Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.</p><p>The average value of a set of k numbers is the sum of the numbers divided by k.</p><p>Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.</p><p>Example 1:<br>Input: rolls &#x3D; [3,2,4,3], mean &#x3D; 4, n &#x3D; 2<br>Output: [6,6]<br>Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) &#x2F; 6 &#x3D; 4.</p><p>Example 2:<br>Input: rolls &#x3D; [1,5,6], mean &#x3D; 3, n &#x3D; 4<br>Output: [2,3,2,2]<br>Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) &#x2F; 7 &#x3D; 3.</p><p>Example 3:<br>Input: rolls &#x3D; [1,2,3,4], mean &#x3D; 6, n &#x3D; 4<br>Output: []<br>Explanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are.</p><p>Constraints:<br>m &#x3D;&#x3D; rolls.length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 105<br>1 &lt;&#x3D; rolls[i], mean &lt;&#x3D; 6</p><p>找出缺失的观测数据。</p><blockquote>现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。<p>给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。</p><p>返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p>k 个数字的 平均值 为这些数字求和后再除以 k 。</p><p>注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道数学题。已知 m 次的投掷数据和 n + m 次投掷数据的平均值，要求返回的是剩下 n 次的投掷数据，如果存在多组符合要求的答案，只需要返回其中任意一组即可。</p><p>设n + m 次投掷数据的总和是 totalSum，已知的 m 次投掷数据的总和是 curSum，那么剩下的 n 次投掷数据的总和是 restSum &#x3D; totalSum - curSum。如果 restSum &lt; n 或 restSum &gt; 6 * n，则不存在答案，返回空数组。</p><p>一般的 case 是我们用 restSum &#x2F; n 得到一个商 quotient 和一个余数 remainder，那么对于最后需要输出的数组 res，每一个位置上的值是 quotient + (i &lt; remainder ? 1 : 0)，每一个 quotient 需要 + 1 直到把 remainder 用完为止。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] missingRolls(<span class="hljs-type">int</span>[] rolls, <span class="hljs-type">int</span> mean, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> rolls.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">totalSum</span> <span class="hljs-operator">=</span> mean * (n + m);<br><span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> roll : rolls) &#123;<br>curSum += roll;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">restSum</span> <span class="hljs-operator">=</span> totalSum - curSum;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (restSum &lt; n || restSum &gt; <span class="hljs-number">6</span> * n) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-type">int</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> restSum / n;<br><span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> restSum % n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>res[i] = quotient + (i &lt; remainder ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>math</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2903. Find Indices With Index and Value Difference I</title>
    <link href="/posts/1006169978.html"/>
    <url>/posts/1006169978.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.</p><p>Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:<br>abs(i - j) &gt;&#x3D; indexDifference, and<br>abs(nums[i] - nums[j]) &gt;&#x3D; valueDifference<br>Return an integer array answer, where answer &#x3D; [i, j] if there are two such indices, and answer &#x3D; [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.</p><p>Note: i and j may be equal.</p><p>Example 1:<br>Input: nums &#x3D; [5,1,4,1], indexDifference &#x3D; 2, valueDifference &#x3D; 4<br>Output: [0,3]<br>Explanation: In this example, i &#x3D; 0 and j &#x3D; 3 can be selected.<br>abs(0 - 3) &gt;&#x3D; 2 and abs(nums[0] - nums[3]) &gt;&#x3D; 4.<br>Hence, a valid answer is [0,3].<br>[3,0] is also a valid answer.</p><p>Example 2:<br>Input: nums &#x3D; [2,1], indexDifference &#x3D; 0, valueDifference &#x3D; 0<br>Output: [0,0]<br>Explanation: In this example, i &#x3D; 0 and j &#x3D; 0 can be selected.<br>abs(0 - 0) &gt;&#x3D; 0 and abs(nums[0] - nums[0]) &gt;&#x3D; 0.<br>Hence, a valid answer is [0,0].<br>Other valid answers are [0,1], [1,0], and [1,1].</p><p>Example 3:<br>Input: nums &#x3D; [1,2,3], indexDifference &#x3D; 2, valueDifference &#x3D; 4<br>Output: [-1,-1]<br>Explanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.<br>Hence, [-1,-1] is returned.</p><p>Constraints:<br>1 &lt;&#x3D; n &#x3D;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 50<br>0 &lt;&#x3D; indexDifference &lt;&#x3D; 100<br>0 &lt;&#x3D; valueDifference &lt;&#x3D; 50</p><p>找出满足差值条件的下标 I。</p><blockquote>给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。<p>你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：</p><p>abs(i - j) &gt;&#x3D; indexDifference 且<br>abs(nums[i] - nums[j]) &gt;&#x3D; valueDifference<br>返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer &#x3D; [i, j] ；否则，answer &#x3D; [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p>注意：i 和 j 可能 相等 。</p></blockquote><h2 id="思路一-暴力解"><a href="#思路一-暴力解" class="headerlink" title="思路一 - 暴力解"></a>思路一 - 暴力解</h2><p>两层 for 循环，遍历所有可能的 i 和 j，判断是否满足条件。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findIndices(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> indexDifference, <span class="hljs-type">int</span> valueDifference) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (Math.abs(i - j) &gt;= indexDifference &amp;&amp; Math.abs(nums[i] - nums[j]) &gt;= valueDifference) &#123;<br>                    res[<span class="hljs-number">0</span>] = i;<br>                    res[<span class="hljs-number">1</span>] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-滑动窗口"><a href="#思路二-滑动窗口" class="headerlink" title="思路二 - 滑动窗口"></a>思路二 - 滑动窗口</h2><p>一个更好的思路是使用滑动窗口。这里我们滑动窗口的尺寸是固定的，为 indexDifference。我们用一个 for 循环，遍历所有可能的 i，然后创建另一个变量 j，使得 j 和 i 的距离一直保持为 indexDifference。在遍历的过程中，因为 i 和 j 的距离满足题目的要求了，所以我们可以在遍历的过程中记录 j 遇到的最大值和最小值，当走到某个 i 位置的时候，如果发现 nums[i] - min &gt;&#x3D; valueDifference 或者 max - nums[i] &gt;&#x3D; valueDifference，我们就可以返回 [minIndex, i] 或者 [maxIndex, i]，就说明找到一个可行解了。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findIndices(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> indexDifference, <span class="hljs-type">int</span> valueDifference) &#123;<br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> j;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexDifference; i &lt; nums.length; i++) &#123;<br>j = i - indexDifference;<br><span class="hljs-keyword">if</span> (nums[j] &gt; max) &#123;<br>max = nums[j];<br>maxIndex = j;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[j] &lt; min) &#123;<br>min = nums[j];<br>minIndex = j;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[i] - min &gt;= valueDifference) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; minIndex, i &#125;;<br>&#125;<br><span class="hljs-keyword">if</span> (max - nums[i] &gt;= valueDifference) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; maxIndex, i &#125;;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2831. Find the Longest Equal Subarray</title>
    <link href="/posts/874156265.html"/>
    <url>/posts/874156265.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums and an integer k.</p><p>A subarray is called equal if all of its elements are equal. Note that the empty subarray is an equal subarray.</p><p>Return the length of the longest possible equal subarray after deleting at most k elements from nums.</p><p>A subarray is a contiguous, possibly empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,2,3,1,3], k &#x3D; 3<br>Output: 3<br>Explanation: It’s optimal to delete the elements at index 2 and index 4.<br>After deleting them, nums becomes equal to [1, 3, 3, 3].<br>The longest equal subarray starts at i &#x3D; 1 and ends at j &#x3D; 3 with length equal to 3.<br>It can be proven that no longer equal subarrays can be created.</p><p>Example 2:<br>Input: nums &#x3D; [1,1,2,2,1,1], k &#x3D; 2<br>Output: 4<br>Explanation: It’s optimal to delete the elements at index 2 and index 3.<br>After deleting them, nums becomes equal to [1, 1, 1, 1].<br>The array itself is an equal subarray, so the answer is 4.<br>It can be proven that no longer equal subarrays can be created.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums.length<br>0 &lt;&#x3D; k &lt;&#x3D; nums.length</p><p>找出最长等值子数组。</p><blockquote>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。<p>如果子数组中所有元素都相等，则认为子数组是一个 等值子数组 。注意，空数组是 等值子数组 。</p><p>从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。</p><p>子数组 是数组中一个连续且可能为空的元素序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口。题目的最终目标是让我们找到一个最长的等值子数组。准确地说与其说是子数组，不如说是子序列，因为最终题目要求的最长的子数组里面的元素的下标并不是连续的。</p><p>这里我们需要一个 hashmap，key 是每个不同元素，value 是一个 queue，存储的是当前元素在 input 数组内出现的下标。然后我们开始遍历 input 数组，根据遇到的不同元素，把他们的下标都放到各自对应的 queue 中。每当放入一个下标的时候，我们判断，如果当前这个元素能组成最长的等值子数组，那么他第一次出现的下标（假设为 i）和最后一次出现的下标（假设为 j）之间的距离一定要满足 i + k &lt;&#x3D; j。如果不满足这个条件，说明 i 和 j 距离太远，需要从 i 开始删除一些元素，直到满足题目条件为止。</p><p>通常情况，i 和 j 之间的距离一定比这个元素实际的个数要大，因为中间夹杂了其他的元素，但是我们要保证其中夹杂的其他元素的个数 &lt;&#x3D; k。而当前这个相同元素的实际个数 &#x3D; queue.size()。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestEqualSubarray</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        HashMap&lt;Integer, Deque&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums.get(i);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(num)) &#123;<br>                map.put(num, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;());<br>            &#125;<br>            map.get(num).offerLast(i);<br>            Deque&lt;Integer&gt; q = map.get(num);<br>            <span class="hljs-keyword">while</span> (!q.isEmpty() &amp;&amp; i - q.peekFirst() + <span class="hljs-number">1</span> &gt; q.size() + k) &#123;<br>                q.pollFirst();<br>            &#125;<br>            res = Math.max(res, q.size());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1863. Sum of All Subset XOR Totals</title>
    <link href="/posts/2736963258.html"/>
    <url>/posts/2736963258.html</url>
    
    <content type="html"><![CDATA[<p>The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.</p><p>For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 &#x3D; 1.<br>Given an array nums, return the sum of all XOR totals for every subset of nums. </p><p>Note: Subsets with the same elements should be counted multiple times.</p><p>An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.</p><p>Example 1:<br>Input: nums &#x3D; [1,3]<br>Output: 6<br>Explanation: The 4 subsets of [1,3] are:</p><ul><li>The empty subset has an XOR total of 0.</li><li>[1] has an XOR total of 1.</li><li>[3] has an XOR total of 3.</li><li>[1,3] has an XOR total of 1 XOR 3 &#x3D; 2.<br>0 + 1 + 3 + 2 &#x3D; 6</li></ul><p>Example 2:<br>Input: nums &#x3D; [5,1,6]<br>Output: 28<br>Explanation: The 8 subsets of [5,1,6] are:</p><ul><li>The empty subset has an XOR total of 0.</li><li>[5] has an XOR total of 5.</li><li>[1] has an XOR total of 1.</li><li>[6] has an XOR total of 6.</li><li>[5,1] has an XOR total of 5 XOR 1 &#x3D; 4.</li><li>[5,6] has an XOR total of 5 XOR 6 &#x3D; 3.</li><li>[1,6] has an XOR total of 1 XOR 6 &#x3D; 7.</li><li>[5,1,6] has an XOR total of 5 XOR 1 XOR 6 &#x3D; 2.<br>0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 &#x3D; 28</li></ul><p>Example 3:<br>Input: nums &#x3D; [3,4,5,6,7,8]<br>Output: 480<br>Explanation: The sum of all XOR totals for every subset is 480.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 12<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 20</p><p>找出所有子集的异或总和再求和。</p><blockquote>一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。<p>例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 &#x3D; 1 。<br>给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p><p>数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照求 subset 的方式，枚举每个元素参与和不参与 XOR 运算的情况，然后把所有情况的结果累加起来。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(2^n) - 这里的 n 是 12<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subsetXORSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>&#125;<br>helper(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> xor)</span> &#123;<br><span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>res += xor;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 当前元素参与XOR</span><br>helper(nums, index + <span class="hljs-number">1</span>, xor ^ nums[index]);<br><span class="hljs-comment">// 当前元素不参与XOR</span><br>helper(nums, index + <span class="hljs-number">1</span>, xor);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>backtracking</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1953. Maximum Number of Weeks for Which You Can Work</title>
    <link href="/posts/3427306978.html"/>
    <url>/posts/3427306978.html</url>
    
    <content type="html"><![CDATA[<p>There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.</p><p>You can work on the projects following these two rules:<br>Every week, you will finish exactly one milestone of one project. You must work every week.<br>You cannot work on two milestones from the same project for two consecutive weeks.</p><p>Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project’s milestones due to these constraints.</p><p>Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.</p><p>Example 1:<br>Input: milestones &#x3D; [1,2,3]<br>Output: 6<br>Explanation: One possible scenario is:<br>​​​​- During the 1st week, you will work on a milestone of project 0.</p><ul><li>During the 2nd week, you will work on a milestone of project 2.</li><li>During the 3rd week, you will work on a milestone of project 1.</li><li>During the 4th week, you will work on a milestone of project 2.</li><li>During the 5th week, you will work on a milestone of project 1.</li><li>During the 6th week, you will work on a milestone of project 2.<br>The total number of weeks is 6.</li></ul><p>Example 2:<br>Input: milestones &#x3D; [5,2,1]<br>Output: 7<br>Explanation: One possible scenario is:</p><ul><li>During the 1st week, you will work on a milestone of project 0.</li><li>During the 2nd week, you will work on a milestone of project 1.</li><li>During the 3rd week, you will work on a milestone of project 0.</li><li>During the 4th week, you will work on a milestone of project 1.</li><li>During the 5th week, you will work on a milestone of project 0.</li><li>During the 6th week, you will work on a milestone of project 2.</li><li>During the 7th week, you will work on a milestone of project 0.<br>The total number of weeks is 7.<br>Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.<br>Thus, one milestone in project 0 will remain unfinished.</li></ul><p>Constraints:<br>n &#x3D;&#x3D; milestones.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; milestones[i] &lt;&#x3D; 109</p><p>你可以工作的最大周数。</p><blockquote>给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。<p>你可以按下面两个规则参与项目中的工作：</p><ul><li>每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。</li><li>在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。</li></ul><p>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p><p>返回在不违反上面规则的情况下你 最多 能工作多少周。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。题目要求我们尽可能多地完成任务且每两个连续的任务不能是同样的。为了尽可能多地完成任务，一个不难想到的思路是我们能否先找到任务量最多的任务，如果我们能完成这个任务量最多的任务，那么我们不就可以把剩下的任务穿插在这个最多的任务中间了吗？这样也满足题目不能连续两周做同一个任务的要求。</p><p>想到这个思路不难，这里我们说明一下这个思路的可行性。我们遍历一遍 input 数组，找到任务数量最多的任务，记为 longest。同时我们累加每一个任务，把全局所有任务数量的总和记为 sum，那么除 longest 之外的其他任务的数量 rest &#x3D; sum - longest。假设我们能跑完 longest 的所有任务，那么我们至少需要 rest &gt;&#x3D; longest - 1。举例，比如 longest &#x3D; 10，那么我们要让 rest 不小于 9 才行，因为 10 个任务中间有 9 个空隙可以插进去。</p><p>因此，当我们找到 longest 之后，我们可以直接判断，如果 rest &gt;&#x3D; longest - 1，那么可以完成所有任务；反之如果不满足这个条件，那么我们只能满足 2 * rest + 1 个任务。在剩下的 rest 个任务中间插入 rest + 1 个最多类型的任务。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">numberOfWeeks</span><span class="hljs-params">(<span class="hljs-type">int</span>[] milestones)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">longest</span> <span class="hljs-operator">=</span> milestones[<span class="hljs-number">0</span>];<br><span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> milestone : milestones) &#123;<br>longest = Math.max(longest, milestone);<br>sum += milestone;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> sum - longest;<br><span class="hljs-keyword">if</span> (rest &lt; longest - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> rest * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3075. Maximize Happiness of Selected Children</title>
    <link href="/posts/1338501949.html"/>
    <url>/posts/1338501949.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array happiness of length n, and a positive integer k.</p><p>There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.</p><p>In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.</p><p>Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.</p><p>Example 1:<br>Input: happiness &#x3D; [1,2,3], k &#x3D; 2<br>Output: 4<br>Explanation: We can pick 2 children in the following way:</p><ul><li>Pick the child with the happiness value &#x3D;&#x3D; 3. The happiness value of the remaining children becomes [0,1].</li><li>Pick the child with the happiness value &#x3D;&#x3D; 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.<br>The sum of the happiness values of the selected children is 3 + 1 &#x3D; 4.</li></ul><p>Example 2:<br>Input: happiness &#x3D; [1,1,1,1], k &#x3D; 2<br>Output: 1<br>Explanation: We can pick 2 children in the following way:</p><ul><li>Pick any child with the happiness value &#x3D;&#x3D; 1. The happiness value of the remaining children becomes [0,0,0].</li><li>Pick the child with the happiness value &#x3D;&#x3D; 0. The happiness value of the remaining child becomes [0,0].<br>The sum of the happiness values of the selected children is 1 + 0 &#x3D; 1.</li></ul><p>Example 3:<br>Input: happiness &#x3D; [2,3,4,5], k &#x3D; 1<br>Output: 5<br>Explanation: We can pick 1 child in the following way:</p><ul><li>Pick the child with the happiness value &#x3D;&#x3D; 5. The happiness value of the remaining children becomes [1,2,3].<br>The sum of the happiness values of the selected children is 5.</li></ul><p>Constraints:<br>1 &lt;&#x3D; n &#x3D;&#x3D; happiness.length &lt;&#x3D; 2 * 105<br>1 &lt;&#x3D; happiness[i] &lt;&#x3D; 108<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><p>幸福值最大化的选择方案。</p><blockquote>给你一个长度为 n 的数组 happiness ，以及一个 正整数 k 。<p>n 个孩子站成一队，其中第 i 个孩子的 幸福值 是 happiness[i] 。你计划组织 k 轮筛选从这 n 个孩子中选出 k 个孩子。</p><p>在每一轮选择一个孩子时，所有 尚未 被选中的孩子的 幸福值 将减少 1 。注意，幸福值 不能 变成负数，且只有在它是正数的情况下才会减少。</p><p>选择 k 个孩子，并使你选中的孩子幸福值之和最大，返回你能够得到的 最大值 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是排序。把 input 数组排序，之后按照从大到小开始扫描数组。每遇到一个孩子的时候，先按照规则将他的幸福值减去相应的数值，比如之前已经选择了 X 个孩子，就需要把当前孩子的幸福值 - X。做过这个减法之后，如果当前孩子的幸福值还大于 0 的话，就把当前孩子的幸福值累加到结果里。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumHappinessSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] happiness, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(happiness);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">deduct</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> happiness.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            happiness[i] = Math.max(<span class="hljs-number">0</span>, happiness[i] - deduct);<br>            res += happiness[i];<br>            deduct++;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2960. Count Tested Devices After Test Operations</title>
    <link href="/posts/2783829724.html"/>
    <url>/posts/2783829724.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.</p><p>Your task is to test each device i in order from 0 to n - 1, by performing the following test operations:<br>If batteryPercentages[i] is greater than 0:<br>Increment the count of tested devices.<br>Decrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] &#x3D; max(0, batteryPercentages[j] - 1).<br>Move to the next device.<br>Otherwise, move to the next device without performing any test.<br>Return an integer denoting the number of devices that will be tested after performing the test operations in order.</p><p>Example 1:<br>Input: batteryPercentages &#x3D; [1,1,2,1,3]<br>Output: 3<br>Explanation: Performing the test operations in order starting from device 0:<br>At device 0, batteryPercentages[0] &gt; 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].<br>At device 1, batteryPercentages[1] &#x3D;&#x3D; 0, so we move to the next device without testing.<br>At device 2, batteryPercentages[2] &gt; 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].<br>At device 3, batteryPercentages[3] &#x3D;&#x3D; 0, so we move to the next device without testing.<br>At device 4, batteryPercentages[4] &gt; 0, so there are now 3 tested devices, and batteryPercentages stays the same.<br>So, the answer is 3.</p><p>Example 2:<br>Input: batteryPercentages &#x3D; [0,1,2]<br>Output: 2<br>Explanation: Performing the test operations in order starting from device 0:<br>At device 0, batteryPercentages[0] &#x3D;&#x3D; 0, so we move to the next device without testing.<br>At device 1, batteryPercentages[1] &gt; 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].<br>At device 2, batteryPercentages[2] &gt; 0, so there are now 2 tested devices, and batteryPercentages stays the same.<br>So, the answer is 2.</p><p>Constraints:<br>1 &lt;&#x3D; n &#x3D;&#x3D; batteryPercentages.length &lt;&#x3D; 100<br>0 &lt;&#x3D; batteryPercentages[i] &lt;&#x3D; 100</p><p>统计已测试设备。</p><blockquote>给你一个长度为 n 、下标从 0 开始的整数数组 batteryPercentages ，表示 n 个设备的电池百分比。<p>你的任务是按照顺序测试每个设备 i，执行以下测试操作：</p><p>如果 batteryPercentages[i] 大于 0：<br>增加 已测试设备的计数。<br>将下标在 [i + 1, n - 1] 的所有设备的电池百分比减少 1，确保它们的电池百分比 不会低于 0 ，即 batteryPercentages[j] &#x3D; max(0, batteryPercentages[j] - 1)。<br>移动到下一个设备。<br>否则，移动到下一个设备而不执行任何测试。<br>返回一个整数，表示按顺序执行测试操作后 已测试设备 的数量。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是差分数组。暴力解就不展示了，思路是需要一个两层 for 循环，第一层 for 是去遍历每个设备，如果当前设备电量大于 0，则第二层 for 循环需要去遍历剩下的设备并对每个剩下的设备的电池百分比 - 1。</p><p>这道题的最优解是差分数组。还是需要遍历一遍 input 数组，遍历的时候，如果当前设备的电量大于 0，则 count++，count 记录的是已测试过的设备的数量。接着往之后的设备看，如果当前设备在按规则（电池百分比减少 1）减去电量之后，电量仍然大于 0，则 count++。最后返回的是 count。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countTestedDevices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] batteryPercentages)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> batteryPercentages.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>batteryPercentages[i] = Math.max(<span class="hljs-number">0</span>, batteryPercentages[i] - count);<br><span class="hljs-keyword">if</span> (batteryPercentages[i] &gt; <span class="hljs-number">0</span>) &#123;<br>count++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2105. Watering Plants II</title>
    <link href="/posts/1725533005.html"/>
    <url>/posts/1725533005.html</url>
    
    <content type="html"><![CDATA[<p>Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x &#x3D; i.</p><p>Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:<br>Alice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.<br>It takes the same amount of time to water each plant regardless of how much water it needs.<br>Alice&#x2F;Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.<br>In case both Alice and Bob reach the same plant, the one with more water currently in his&#x2F;her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.<br>Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice’s and Bob’s watering cans respectively, return the number of times they have to refill to water all the plants.</p><p>Example 1:<br>Input: plants &#x3D; [2,2,3,3], capacityA &#x3D; 5, capacityB &#x3D; 5<br>Output: 1<br>Explanation:</p><ul><li>Initially, Alice and Bob have 5 units of water each in their watering cans.</li><li>Alice waters plant 0, Bob waters plant 3.</li><li>Alice and Bob now have 3 units and 2 units of water respectively.</li><li>Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.<br>So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 &#x3D; 1.</li></ul><p>Example 2:<br>Input: plants &#x3D; [2,2,3,3], capacityA &#x3D; 3, capacityB &#x3D; 4<br>Output: 2<br>Explanation:</p><ul><li>Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.</li><li>Alice waters plant 0, Bob waters plant 3.</li><li>Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.</li><li>Since neither of them have enough water for their current plants, they refill their cans and then water the plants.<br>So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 &#x3D; 2.</li></ul><p>Example 3:<br>Input: plants &#x3D; [5], capacityA &#x3D; 10, capacityB &#x3D; 8<br>Output: 0<br>Explanation:</p><ul><li>There is only one plant.</li><li>Alice’s watering can has 10 units of water, whereas Bob’s can has 8 units. Since Alice has more water in her can, she waters this plant.<br>So, the total number of times they have to refill is 0.</li></ul><p>Constraints:<br>n &#x3D;&#x3D; plants.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; plants[i] &lt;&#x3D; 106<br>max(plants[i]) &lt;&#x3D; capacityA, capacityB &lt;&#x3D; 109</p><p>给植物浇水 II。</p><blockquote>Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。<p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：</p><p>Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。<br>无论需要多少水，为每株植物浇水所需的时间都是相同的。<br>如果 Alice&#x2F;Bob 水罐中的水足以 完全 灌溉植物，他们 必须 给植物浇水。否则，他们 首先（立即）重新装满罐子，然后给植物浇水。<br>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水 更多 的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。<br>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我是先做了版本一2079题才来做这道题的。原本以为从一个人浇水变成两个人浇水，还是让你算需要的步数，结果这道题其实让你算的是两个人补水的次数。</p><p>既然 Alice 和 Bob 分别从花园的两端往中间走，那么这道题的总体思路还是双指针往中间逼近。无论是 Alice 还是 Bob，只要他们当前水桶里的水不能满足其当前所在位置的浇花需求，这个人就需要补水（补水次数 + 1）。</p><p>这道题最后的 corner case 是当 Alice 和 Bob 相遇的时候，如果这个位置还未浇水，需要再补水（补水次数 + 1）。不过<code>如果他俩水量相同，那么 Alice 优先给这株植物浇水</code>这个条件似乎没有用上。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumRefill</span><span class="hljs-params">(<span class="hljs-type">int</span>[] plants, <span class="hljs-type">int</span> capacityA, <span class="hljs-type">int</span> capacityB)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> plants.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">alice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketA</span> <span class="hljs-operator">=</span> capacityA;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketB</span> <span class="hljs-operator">=</span> capacityB;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (alice &lt; bob) &#123;<br>            <span class="hljs-keyword">if</span> (bucketA &lt; plants[alice]) &#123;<br>                res++;<br>                bucketA = capacityA;<br>            &#125;<br>            bucketA -= plants[alice++];<br><br>            <span class="hljs-keyword">if</span> (bucketB &lt; plants[bob]) &#123;<br>                res++;<br>                bucketB = capacityB;<br>            &#125;<br>            bucketB -= plants[bob--];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (alice == bob &amp;&amp; Math.max(bucketA, bucketB) &lt; plants[alice]) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2079. Watering Plants</title>
    <link href="/posts/1731658428.html"/>
    <url>/posts/1731658428.html</url>
    
    <content type="html"><![CDATA[<p>You want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x &#x3D; i. There is a river at x &#x3D; -1 that you can refill your watering can at.</p><p>Each plant needs a specific amount of water. You will water the plants in the following way:<br>Water the plants in order from left to right.<br>After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.<br>You cannot refill the watering can early.<br>You are initially at the river (i.e., x &#x3D; -1). It takes one step to move one unit on the x-axis.</p><p>Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.</p><p>Example 1:<br>Input: plants &#x3D; [2,2,3,3], capacity &#x3D; 5<br>Output: 14<br>Explanation: Start at the river with a full watering can:</p><ul><li>Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.</li><li>Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.</li><li>Since you cannot completely water plant 2, walk back to the river to refill (2 steps).</li><li>Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.</li><li>Since you cannot completely water plant 3, walk back to the river to refill (3 steps).</li><li>Walk to plant 3 (4 steps) and water it.<br>Steps needed &#x3D; 1 + 1 + 2 + 3 + 3 + 4 &#x3D; 14.</li></ul><p>Example 2:<br>Input: plants &#x3D; [1,1,1,4,2,3], capacity &#x3D; 4<br>Output: 30<br>Explanation: Start at the river with a full watering can:</p><ul><li>Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).</li><li>Water plant 3 (4 steps). Return to river (4 steps).</li><li>Water plant 4 (5 steps). Return to river (5 steps).</li><li>Water plant 5 (6 steps).<br>Steps needed &#x3D; 3 + 3 + 4 + 4 + 5 + 5 + 6 &#x3D; 30.</li></ul><p>Example 3:<br>Input: plants &#x3D; [7,7,7,7,7,7,7], capacity &#x3D; 8<br>Output: 49<br>Explanation: You have to refill before watering each plant.<br>Steps needed &#x3D; 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 &#x3D; 49.</p><p>Constraints:<br>n &#x3D;&#x3D; plants.length<br>1 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; plants[i] &lt;&#x3D; 106<br>max(plants[i]) &lt;&#x3D; capacity &lt;&#x3D; 109</p><p>给植物浇水。</p><blockquote>你打算用一个水罐给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。x = -1 处有一条河，你可以在那里重新灌满你的水罐。<p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p><p>按从左到右的顺序给植物浇水。<br>在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。<br>你 不能 提前重新灌满水罐。<br>最初，你在河边（也就是，x &#x3D; -1），在 x 轴上每移动 一个单位 都需要 一步 。</p><p>给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题意模拟，遍历 plants 数组，具体参见代码注释。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wateringPlants</span><span class="hljs-params">(<span class="hljs-type">int</span>[] plants, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> capacity;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; plants.length) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">plant</span> <span class="hljs-operator">=</span> plants[i];<br><span class="hljs-comment">// 如果当前水不够，返回河边打水，再走回来</span><br>            <span class="hljs-keyword">if</span> (bucket &lt; plant) &#123;<br>                res += i * <span class="hljs-number">2</span>;<br>                bucket = capacity;<br>            &#125;<br><span class="hljs-comment">// 往前走一步，浇水，再看下一个位置</span><br>            res++;<br>            bucket -= plant;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2487. Remove Nodes From Linked List</title>
    <link href="/posts/2002398807.html"/>
    <url>/posts/2002398807.html</url>
    
    <content type="html"><![CDATA[<p>You are given the head of a linked list.</p><p>Remove every node which has a node with a greater value anywhere to the right side of it.</p><p>Return the head of the modified linked list.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/10/02/drawio.png" alt="Example 1"><br>Input: head &#x3D; [5,2,13,3,8]<br>Output: [13,8]<br>Explanation: The nodes that should be removed are 5, 2 and 3.</p><ul><li>Node 13 is to the right of node 5.</li><li>Node 13 is to the right of node 2.</li><li>Node 8 is to the right of node 3.</li></ul><p>Example 2:<br>Input: head &#x3D; [1,1,1,1]<br>Output: [1,1,1,1]<br>Explanation: Every node has value 1, so no nodes are removed.</p><p>Constraints:<br>The number of the nodes in the given list is in the range [1, 105].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><p>从链表中移除节点。</p><blockquote>给你一个链表的头节点 head 。移除每个右侧有一个更大数值的节点。返回修改后链表的头节点 head 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题意，如果某个 node 的右侧有一个比他 val 更大的 node，需要把这个 node 删除。那么这里我们可以反过来思考，如果我们从右往左遍历整个链表，我们可以先把第一个节点的 val 当做最大值，记为 max，再往左遍历的时候，如果当前节点值比 max 小，则把当前节点移除；否则把当前节点的节点值记为 max，继续往左遍历。这样做的好处是，我们只需要遍历一次链表，就可以把所有需要删除的节点都删除掉。不过我们需要将 input 链表整个反转一次，遍历一次，再反转回去。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNodes</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        head = reverse(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.next.val &lt; max) &#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = cur.next.val;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        head = reverse(head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>linked list</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2739. Total Distance Traveled</title>
    <link href="/posts/414539670.html"/>
    <url>/posts/414539670.html</url>
    
    <content type="html"><![CDATA[<p>A truck has two fuel tanks. You are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters.</p><p>The truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in the main tank, if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank.</p><p>Return the maximum distance which can be traveled.</p><p>Note: Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.</p><p>Example 1:<br>Input: mainTank &#x3D; 5, additionalTank &#x3D; 10<br>Output: 60<br>Explanation:<br>After spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) &#x3D; 1 litre and distance traveled is 50km.<br>After spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.<br>Total distance traveled is 60km.</p><p>Example 2:<br>Input: mainTank &#x3D; 1, additionalTank &#x3D; 2<br>Output: 10<br>Explanation:<br>After spending 1 litre of fuel, the main tank becomes empty.<br>Total distance traveled is 10km.</p><p>Constraints:<br>1 &lt;&#x3D; mainTank, additionalTank &lt;&#x3D; 100</p><p>总行驶距离。</p><blockquote>卡车有两个油箱。给你两个整数，mainTank 表示主油箱中的燃料（以升为单位），additionalTank 表示副油箱中的燃料（以升为单位）。<p>该卡车每耗费 1 升燃料都可以行驶 10 km。每当主油箱使用了 5 升燃料时，如果副油箱至少有 1 升燃料，则会将 1 升燃料从副油箱转移到主油箱。</p><p>返回卡车可以行驶的最大距离。</p><p>注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 5 升燃料时突然且立即发生。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，但是这道题通过率很低，我想是因为很多人忽略了一个细节，就是当 mainTank 烧了 5 升燃料的时候，会获得 1 升燃料的补偿，此时虽然跑了 50 km，但是对于 mainTank 来说，实际只消耗了 4 升燃料。所以为了求我们从 additionalTank 获得了多少燃料的补偿，并不是简单用 mainTank &#x2F; 5 即可。</p><p>这里我注意到，在 mainTank 初始值在一定范围内的时候，他获得补偿的次数是有规律的。比如<br>mainTank 在 1 - 4 之间的时候，补偿了 0 次<br>mainTank 在 5 - 9 之间的时候，补偿了 1 次<br>mainTank 在 10 - 14 之间的时候，补偿了 2 次<br>mainTank 在 15 - 19 之间的时候，补偿了 3 次</p><p>所以卡车一共可以获得的补偿次数 &#x3D; (mainTank - 1) &#x2F; 4。想通了这一点，剩下的内容就很简单了。当然这道题也可以用 while 循环做，但是如果数据量太大容易超时。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distanceTraveled</span><span class="hljs-params">(<span class="hljs-type">int</span> mainTank, <span class="hljs-type">int</span> additionalTank)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> (mainTank - <span class="hljs-number">1</span>) / <span class="hljs-number">4</span>;<br>        mainTank += Math.min(additionalTank, times);<br>        res = <span class="hljs-number">10</span> * mainTank;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2073. Time Needed to Buy Tickets</title>
    <link href="/posts/674239195.html"/>
    <url>/posts/674239195.html</url>
    
    <content type="html"><![CDATA[<p>There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.</p><p>You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].</p><p>Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.</p><p>Return the time taken for the person at position k (0-indexed) to finish buying tickets.</p><p>Example 1:<br>Input: tickets &#x3D; [2,3,2], k &#x3D; 2<br>Output: 6<br>Explanation: </p><ul><li>In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].</li><li>In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].<br>The person at position 2 has successfully bought 2 tickets and it took 3 + 3 &#x3D; 6 seconds.</li></ul><p>Example 2:<br>Input: tickets &#x3D; [5,1,1,1], k &#x3D; 0<br>Output: 8<br>Explanation:</p><ul><li>In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].</li><li>In the next 4 passes, only the person in position 0 is buying tickets.<br>The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 &#x3D; 8 seconds.</li></ul><p>Constraints:<br>n &#x3D;&#x3D; tickets.length<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; tickets[i] &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt; n</p><p>买票需要的时间。</p><blockquote>有 n 个人前来排队买票，其中第 0 人站在队伍 最前方 ，第 (n - 1) 人站在队伍 最后方 。<p>给你一个下标从 0 开始的整数数组 tickets ，数组长度为 n ，其中第 i 人想要购买的票数为 tickets[i] 。</p><p>每个人买票都需要用掉 恰好 1 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。</p><p>返回位于位置 k（下标从 0 开始）的人完成买票需要的时间（以秒为单位）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的暴力解是用一个队列，把所有人需要购买的票数放进去，然后开始遍历每一个元素。但是如果人数太多（n 太大）就一定会超时。</p><p>这里我提供一个次优解，不需要用队列，就是简单的模拟。当第 k 个人还未完成购票的时候，就一直遍历整个 input 数组。因为每个人一次只能购买一张票，一次购买的动作耗时一秒钟，所以我们一直遍历整个数组直到第 k 个人完成购票，才把循环 break，返回结果。</p><p>这里同时我提供一个网上看到的<a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/solutions/1102684/mai-piao-xu-yao-de-shi-jian-by-leetcode-jnfxx">最优解</a>，时间复杂度为O(n)，但是很难想到。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n * k)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">timeRequiredToBuy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] tickets, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tickets.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (tickets[k] &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (tickets[i] &gt; <span class="hljs-number">0</span>) &#123;<br>tickets[i]--;<br>time++;<br><span class="hljs-keyword">if</span> (i == k &amp;&amp; tickets[k] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> time;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> time;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2192. All Ancestors of a Node in a Directed Acyclic Graph</title>
    <link href="/posts/2413990597.html"/>
    <url>/posts/2413990597.html</url>
    
    <content type="html"><![CDATA[<p>You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).</p><p>You are also given a 2D integer array edges, where edges[i] &#x3D; [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.</p><p>Return a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.</p><p>A node u is an ancestor of another node v if u can reach v via a set of edges.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/12/12/e1.png" alt="Example 1"><br>Input: n &#x3D; 8, edgeList &#x3D; [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]<br>Output: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]<br>Explanation:<br>The above diagram represents the input graph.</p><ul><li>Nodes 0, 1, and 2 do not have any ancestors.</li><li>Node 3 has two ancestors 0 and 1.</li><li>Node 4 has two ancestors 0 and 2.</li><li>Node 5 has three ancestors 0, 1, and 3.</li><li>Node 6 has five ancestors 0, 1, 2, 3, and 4.</li><li>Node 7 has four ancestors 0, 1, 2, and 3.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/12/12/e2.png" alt="Example 2"><br>Input: n &#x3D; 5, edgeList &#x3D; [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]<br>Output: [[],[0],[0,1],[0,1,2],[0,1,2,3]]<br>Explanation:<br>The above diagram represents the input graph.</p><ul><li>Node 0 does not have any ancestor.</li><li>Node 1 has one ancestor 0.</li><li>Node 2 has two ancestors 0 and 1.</li><li>Node 3 has three ancestors 0, 1, and 2.</li><li>Node 4 has four ancestors 0, 1, 2, and 3.</li></ul><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 1000<br>0 &lt;&#x3D; edges.length &lt;&#x3D; min(2000, n * (n - 1) &#x2F; 2)<br>edges[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; fromi, toi &lt;&#x3D; n - 1<br>fromi !&#x3D; toi<br>There are no duplicate edges.<br>The graph is directed and acyclic.</p><p>有向无环图中一个节点的所有祖先。</p><blockquote>给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。<p>给你一个二维整数数组 edges ，其中 edges[i] &#x3D; [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。</p><p>请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。</p><p>如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我用一个类似反向 DFS 的方法解决这道题。题意是找图中每个节点的祖先。因为图本身是有向无环图（DAG），每条边是有方向的，所以为了找祖先，我们可以在建图的时候把每条边反过来理解。比如如果有一条边是从 A 到 B 的，那么我们在建图的时候可以把 A 加到 B 的邻接表上，意思是如果从 B 出发，能走到他的祖先 A。</p><p>下面的步骤就跟一般的图的遍历很类似了，我们还是需要一个 boolean 数组记录遍历过程中每个点是否被访问到，具体参见代码。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">getAncestors</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br><span class="hljs-comment">// 反向建图</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>graph[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>&#125;<br><br>List&lt;Integer&gt;[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>res[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br><span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>Arrays.fill(visited, <span class="hljs-literal">false</span>);<br>dfs(graph, visited, i);<br>visited[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">// res[i] 不含 i</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (visited[j]) &#123;<br>res[i].add(j);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> Arrays.asList(res);<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt;[] graph, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> u)</span> &#123;<br>visited[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br><span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>dfs(graph, visited, v);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>graph</tag>
      
      <tag>topological sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2962. Count Subarrays Where Max Element Appears at Least K Times</title>
    <link href="/posts/1261282593.html"/>
    <url>/posts/1261282593.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and a positive integer k.</p><p>Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.</p><p>A subarray is a contiguous sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,2,3,3], k &#x3D; 2<br>Output: 6<br>Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].</p><p>Example 2:<br>Input: nums &#x3D; [1,4,2,1], k &#x3D; 3<br>Output: 0<br>Explanation: No subarray contains the element 4 at least 3 times.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 106<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>统计最大元素出现至少 K 次的子数组。</p><blockquote>给你一个整数数组 nums 和一个 正整数 k 。<p>请你统计有多少满足 「 nums 中的 最大 元素」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。</p><p>子数组是数组中的一个连续元素序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难想到是滑动窗口。但是注意这道题问的是最大元素出现<strong>至少 k 次</strong>的子数组，而不是恰好 k 次。如果问的是恰好 k 次的话，当右指针遇到第 k 个最大元素的时候，左指针就可以开始动了，类似76题那种形式。但是这道题当右指针移动到第 k 个最大元素的时候，因为左右指针中间包含了 k 个最大元素，所以左指针及其左边，都是合法的子数组，都包含了起码 k 个最大元素。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().orElseThrow();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[end++];<br>            <span class="hljs-keyword">if</span> (cur == max) &#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (count &gt;= k) &#123;<br>                <span class="hljs-keyword">if</span> (nums[start++] == max) &#123;<br>                    count--;<br>                &#125;<br>            &#125;<br>            res += start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2789. Largest Element in an Array after Merge Operations</title>
    <link href="/posts/495996551.html"/>
    <url>/posts/495996551.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array nums consisting of positive integers.</p><p>You can do the following operation on the array any number of times:<br>Choose an integer i such that 0 &lt;&#x3D; i &lt; nums.length - 1 and nums[i] &lt;&#x3D; nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.<br>Return the value of the largest element that you can possibly obtain in the final array.</p><p>Example 1:<br>Input: nums &#x3D; [2,3,7,9,3]<br>Output: 21<br>Explanation: We can apply the following operations on the array:</p><ul><li>Choose i &#x3D; 0. The resulting array will be nums &#x3D; [5,7,9,3].</li><li>Choose i &#x3D; 1. The resulting array will be nums &#x3D; [5,16,3].</li><li>Choose i &#x3D; 0. The resulting array will be nums &#x3D; [21,3].<br>The largest element in the final array is 21. It can be shown that we cannot obtain a larger element.</li></ul><p>Example 2:<br>Input: nums &#x3D; [5,3,3]<br>Output: 11<br>Explanation: We can do the following operations on the array:</p><ul><li>Choose i &#x3D; 1. The resulting array will be nums &#x3D; [5,6].</li><li>Choose i &#x3D; 0. The resulting array will be nums &#x3D; [11].<br>There is only one element in the final array, which is 11.</li></ul><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 106</p><p>合并后数组中的最大元素。</p><blockquote>给你一个下标从 0 开始、由正整数组成的数组 nums 。<p>你可以在数组上执行下述操作 任意 次：<br>选中一个同时满足 0 &lt;&#x3D; i &lt; nums.length - 1 和 nums[i] &lt;&#x3D; nums[i + 1] 的整数 i 。将元素 nums[i + 1] 替换为 nums[i] + nums[i + 1] ，并从数组中删除元素 nums[i] 。</p><p>返回你可以从最终数组中获得的 最大 元素的值。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。对于数组中的元素，只有满足 nums[i] &lt;&#x3D; nums[i + 1] 的时候，才能将 nums[i + 1] 替换为 nums[i] + nums[i + 1]，那么比较自然的想法是可以从数组的最右侧开始往左扫描，如果发现某个元素 nums[i] &gt;&#x3D; nums[i - 1]，就可以将 nums[i] 累加到 nums[i - 1] 上。这里我用一个变量 sum 来统计过程中能找到的最大的累加和。如果发现某个元素 nums[i] &gt; sum，则说明从右往左扫的时候需要在这里停下，sum 要从 nums[i] 开始重新统计。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxArrayValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (sum &gt;= nums[i]) &#123;<br>                sum += (<span class="hljs-type">long</span>) nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum = (<span class="hljs-type">long</span>) nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2129. Capitalize the Title</title>
    <link href="/posts/76471328.html"/>
    <url>/posts/76471328.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:<br>If the length of the word is 1 or 2 letters, change all letters to lowercase.<br>Otherwise, change the first letter to uppercase and the remaining letters to lowercase.<br>Return the capitalized title.</p><p>Example 1:<br>Input: title &#x3D; “capiTalIze tHe titLe”<br>Output: “Capitalize The Title”<br>Explanation:<br>Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.</p><p>Example 2:<br>Input: title &#x3D; “First leTTeR of EACH Word”<br>Output: “First Letter of Each Word”<br>Explanation:<br>The word “of” has length 2, so it is all lowercase.<br>The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.</p><p>Example 3:<br>Input: title &#x3D; “i lOve leetcode”<br>Output: “i Love Leetcode”<br>Explanation:<br>The word “i” has length 1, so it is lowercase.<br>The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.</p><p>Constraints:<br>1 &lt;&#x3D; title.length &lt;&#x3D; 100<br>title consists of words separated by a single space without any leading or trailing spaces.<br>Each word consists of uppercase and lowercase English letters and is non-empty.</p><p>将标题首字母大写。</p><blockquote><p>给你一个字符串 title ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 大写 ：<br>如果单词的长度为 1 或者 2 ，所有字母变成小写。<br>否则，将单词首字母大写，剩余字母变成小写。<br>请你返回 大写后 的 title 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断每个单词的长度，然后根据情况做不同的操作。考察对字符串的拼接和大小写的转换。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - stringbuilder</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">capitalizeTitle</span><span class="hljs-params">(String title)</span> &#123;<br>        String[] words = title.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>            <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>                sb.append(word.toLowerCase());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(word.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + word.substring(<span class="hljs-number">1</span>).toLowerCase());<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2575. Find the Divisibility Array of a String</title>
    <link href="/posts/2159500709.html"/>
    <url>/posts/2159500709.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.</p><p>The divisibility array div of word is an integer array of length n such that:</p><p>div[i] &#x3D; 1 if the numeric value of word[0,…,i] is divisible by m, or<br>div[i] &#x3D; 0 otherwise.<br>Return the divisibility array of word.</p><p>Example 1:<br>Input: word &#x3D; “998244353”, m &#x3D; 3<br>Output: [1,1,0,0,0,1,1,0,0]<br>Explanation: There are only 4 prefixes that are divisible by 3: “9”, “99”, “998244”, and “9982443”.</p><p>Example 2:<br>Input: word &#x3D; “1010”, m &#x3D; 10<br>Output: [0,1,0,1]<br>Explanation: There are only 2 prefixes that are divisible by 10: “10”, and “1010”.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>word.length &#x3D;&#x3D; n<br>word consists of digits from 0 to 9<br>1 &lt;&#x3D; m &lt;&#x3D; 109</p><p>找出字符串的可整除数组。</p><blockquote>给你一个下标从 0 开始的字符串 word ，长度为 n ，由从 0 到 9 的数字组成。另给你一个正整数 m 。<p>word 的 可整除数组 div  是一个长度为 n 的整数数组，并满足：</p><ul><li>如果 word[0,…,i] 所表示的 数值 能被 m 整除，div[i] &#x3D; 1</li><li>否则，div[i] &#x3D; 0<br>返回 word 的可整除数组。</blockquote></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，就是从左往右扫描 word 里的数字前缀，看看这个前缀是否可以被 m 整除。注意题目给的数据范围，word 的长度最大可以到 10^5，如果一个数字的长度达到 10^5，不要说 long，哪怕是 double 也放不下。所以这道题的考点是需要在拼接每一个数字前缀的时候就要不断地对这个数字 % m，否则是会越界造成计算错误的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - output</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] divisibilityArray(String word, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word.length();<br>        <span class="hljs-type">int</span>[] div = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            num = num * <span class="hljs-number">10</span> + (word.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            num %= m;<br>            <span class="hljs-keyword">if</span> (num % m == <span class="hljs-number">0</span>) &#123;<br>                div[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> div;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>MOD</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1750. Minimum Length of String After Deleting Similar Ends</title>
    <link href="/posts/3177659100.html"/>
    <url>/posts/3177659100.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s consisting only of characters ‘a’, ‘b’, and ‘c’. You are asked to apply the following algorithm on the string any number of times:</p><ol><li>Pick a non-empty prefix from the string s where all the characters in the prefix are equal.</li><li>Pick a non-empty suffix from the string s where all the characters in this suffix are equal.</li><li>The prefix and the suffix should not intersect at any index.</li><li>The characters from the prefix and suffix must be the same.</li><li>Delete both the prefix and the suffix.</li></ol><p>Return the minimum length of s after performing the above operation any number of times (possibly zero times).</p><p>Example 1:<br>Input: s &#x3D; “ca”<br>Output: 2<br>Explanation: You can’t remove any characters, so the string stays as is.</p><p>Example 2:<br>Input: s &#x3D; “cabaabac”<br>Output: 0<br>Explanation: An optimal sequence of operations is:</p><ul><li>Take prefix &#x3D; “c” and suffix &#x3D; “c” and remove them, s &#x3D; “abaaba”.</li><li>Take prefix &#x3D; “a” and suffix &#x3D; “a” and remove them, s &#x3D; “baab”.</li><li>Take prefix &#x3D; “b” and suffix &#x3D; “b” and remove them, s &#x3D; “aa”.</li><li>Take prefix &#x3D; “a” and suffix &#x3D; “a” and remove them, s &#x3D; “”.</li></ul><p>Example 3:<br>Input: s &#x3D; “aabccabba”<br>Output: 3<br>Explanation: An optimal sequence of operations is:</p><ul><li>Take prefix &#x3D; “aa” and suffix &#x3D; “a” and remove them, s &#x3D; “bccabb”.</li><li>Take prefix &#x3D; “b” and suffix &#x3D; “bb” and remove them, s &#x3D; “cca”.</li></ul><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s only consists of characters ‘a’, ‘b’, and ‘c’.</p><p>删除字符串两端相同字符后的最短长度。</p><blockquote><p>给你一个只包含字符 ‘a’，’b’ 和 ‘c’ 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：</p></blockquote><ol><li>选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。</li><li>选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。</li><li>前缀和后缀在字符串中任意位置都不能有交集。</li><li>前缀和后缀包含的所有字符都要相同。</li><li>同时删除前缀和后缀。<br>请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题目描述的意思，不难想到思路是双指针从两边往中间逼近。这道题需要想清楚最后的细节，一共三种 case，<br><strong>如果字符串不是回文或者中间部分不是回文，该返回什么长度</strong><br>这种 case 最简单，就是返回左指针和右指针的间距 + 1 即可，参考这个例子</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">abcd<br>lr<br></code></pre></td></tr></table></figure><p>这个 case 的长度是 4，其实就等于 right - left + 1</p><p><strong>如果字符串本身就是回文，且是类似abba这种形式的，该返回什么长度？</strong><br>如果字符串本身就是回文但是长度是偶数，那么最后左指针和右指针会交错，因为 while 循环需要保证 left &lt;&#x3D; right</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">abba<br>rl<br></code></pre></td></tr></table></figure><p><strong>如果字符串本身就是回文，且是类似aba这种形式的，该返回什么长度？</strong><br>如果字符串本身就是回文但是长度是奇数，比如这种极端的例子，此时我们开始移动 l 指针的时候，最后左指针和右指针也会交错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">aaa<br>lr<br></code></pre></td></tr></table></figure><p>你会发现这三种 case 最后都可以返回 right - left + 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumLength</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(left);<br><span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == c) &#123;<br>left++;<br>&#125;<br><span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == c) &#123;<br>right--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> right - left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2368. Reachable Nodes With Restrictions</title>
    <link href="/posts/2740601310.html"/>
    <url>/posts/2740601310.html</url>
    
    <content type="html"><![CDATA[<p>There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.</p><p>You are given a 2D integer array edges of length n - 1 where edges[i] &#x3D; [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.</p><p>Return the maximum number of nodes you can reach from node 0 without visiting a restricted node.</p><p>Note that node 0 will not be a restricted node.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png" alt="Example 1"><br>Input: n &#x3D; 7, edges &#x3D; [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted &#x3D; [4,5]<br>Output: 4<br>Explanation: The diagram above shows the tree.<br>We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png" alt="Example 2"><br>Input: n &#x3D; 7, edges &#x3D; [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted &#x3D; [4,2,1]<br>Output: 3<br>Explanation: The diagram above shows the tree.<br>We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.</p><p>Constraints:<br>2 &lt;&#x3D; n &lt;&#x3D; 105<br>edges.length &#x3D;&#x3D; n - 1<br>edges[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; ai, bi &lt; n<br>ai !&#x3D; bi<br>edges represents a valid tree.<br>1 &lt;&#x3D; restricted.length &lt; n<br>1 &lt;&#x3D; restricted[i] &lt; n<br>All the values of restricted are unique.</p><p>受限条件下可到达节点的数目。</p><blockquote><p>现有一棵由 n 个节点组成的无向树，节点编号从 0 到 n - 1 ，共有 n - 1 条边。<br>给你一个二维整数数组 edges ，长度为 n - 1 ，其中 edges[i] &#x3D; [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。另给你一个整数数组 restricted 表示 受限 节点。<br>在不访问受限节点的前提下，返回你可以从节点 0 到达的 最多 节点数目。<br>注意，节点 0 不 会标记为受限节点。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考的是图的遍历。关于图的题目，基本还是这么几个步骤</p><ul><li>图的建立</li><li>图的遍历</li><li>标记访问过的点避免死循环</li><li>记录需要的步数或者统计访问过的node个数，这个看具体题目要求</li></ul><p>所以这道题的步骤是</p><ul><li>图的建立</li><li>图的遍历，这里我用bfs遍历</li><li>遍历之前先标记那些restricted nodes，这样第一次遇到的时候直接就不访问了</li><li>用BFS遍历所有能访问到的节点，访问过的节点记得标记成visited</li><li>queue中元素都弹出则说明访问结束，最后返回能访问到的点的个数</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reachableNodes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span>[] restricted)</span> &#123;<br>        List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            graph[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);<br>            graph[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">// 处理restricted的node</span><br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : restricted) &#123;<br>            visited[num] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// BFS</span><br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-number">0</span>);<br>        visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[cur]) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>                    queue.offer(next);<br>                    visited[next] = <span class="hljs-literal">true</span>;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>graph</tag>
      
      <tag>union find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2864. Maximum Odd Binary Number</title>
    <link href="/posts/3856055272.html"/>
    <url>/posts/3856055272.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary string s that contains at least one ‘1’.</p><p>You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.</p><p>Return a string representing the maximum odd binary number that can be created from the given combination.</p><p>Note that the resulting string can have leading zeros.</p><p>Example 1:<br>Input: s &#x3D; “010”<br>Output: “001”<br>Explanation: Because there is just one ‘1’, it must be in the last position. So the answer is “001”.</p><p>Example 2:<br>Input: s &#x3D; “0101”<br>Output: “1001”<br>Explanation: One of the ‘1’s must be in the last position. The maximum number that can be made with the remaining digits is “100”. So the answer is “1001”.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s consists only of ‘0’ and ‘1’.<br>s contains at least one ‘1’.</p><p>最大二进制奇数。</p><blockquote><p>给你一个 二进制 字符串 s ，其中至少包含一个 ‘1’ 。<br>你必须按某种方式 重新排列 字符串中的位，使得到的二进制数字是可以由该组合生成的 最大二进制奇数 。<br>以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。<br>注意 返回的结果字符串 可以 含前导零。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为需要保证最后的输出是一个奇数，所以需要预留一个 1 放在最低位，其他的 1 统统放在最高位。<br>具体做法是先扫描一遍 input 字符串，记录一下 0 的个数和 1 的个数，在保证最后一个位置是 1 的情况下优先放 1，其余位置放 0 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">maximumOddBinaryNumber</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                one++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> n - one;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; one - <span class="hljs-number">1</span>; i++) &#123;<br>            sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; zero; i++) &#123;<br>            sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2583. Kth Largest Sum in a Binary Tree</title>
    <link href="/posts/2991325968.html"/>
    <url>/posts/2991325968.html</url>
    
    <content type="html"><![CDATA[<p>You are given the root of a binary tree and a positive integer k.</p><p>The level sum in the tree is the sum of the values of the nodes that are on the same level.</p><p>Return the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.</p><p>Note that two nodes are on the same level if they have the same distance from the root.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png" alt="Example 1"><br>Input: root &#x3D; [5,8,9,2,1,3,7,4,6], k &#x3D; 2<br>Output: 13<br>Explanation: The level sums are the following:</p><ul><li>Level 1: 5.</li><li>Level 2: 8 + 9 &#x3D; 17.</li><li>Level 3: 2 + 1 + 3 + 7 &#x3D; 13.</li><li>Level 4: 4 + 6 &#x3D; 10.<br>The 2nd largest level sum is 13.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png" alt="Example 2"><br>Input: root &#x3D; [1,2,null,3], k &#x3D; 1<br>Output: 3<br>Explanation: The largest level sum is 3.</p><p>Constraints:<br>The number of nodes in the tree is n.<br>2 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 106<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><p>二叉树中的第 K 大层和。</p><blockquote><p>给你一棵二叉树的根节点 root 和一个正整数 k 。<br>树中的 层和 是指 同一层 上节点值的总和。<br>返回树中第 k 大的层和（不一定不同）。如果树少于 k 层，则返回 -1 。<br>注意，如果两个节点与根节点的距离相同，则认为它们在同一层。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单 BFS 题，用一个 list 存每一层的节点值的和，然后返回第 k 大的，如果树少于 k 层，则返回 -1 。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">kthLargestLevelSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Long&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                sum += cur.val;<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                &#125;<br>            &#125;<br>            list.add(sum);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list.size() &lt; k) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> list.size();<br>        Collections.sort(list);<br>        <span class="hljs-keyword">return</span> list.get(n - k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2476. Closest Nodes Queries in a Binary Search Tree</title>
    <link href="/posts/3398880083.html"/>
    <url>/posts/3398880083.html</url>
    
    <content type="html"><![CDATA[<p>You are given the root of a binary search tree and an array queries of size n consisting of positive integers.</p><p>Find a 2D array answer of size n where answer[i] &#x3D; [mini, maxi]:<br>mini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.<br>maxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.<br>Return the array answer.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png" alt="Example 1"><br>Input: root &#x3D; [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries &#x3D; [2,5,16]<br>Output: [[2,2],[4,6],[15,-1]]<br>Explanation: We answer the queries in the following way:</p><ul><li>The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].</li><li>The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].</li><li>The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png" alt="Example 2"><br>Input: root &#x3D; [4,null,9], queries &#x3D; [3]<br>Output: [[-1,4]]<br>Explanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].</p><p>Constraints:<br>The number of nodes in the tree is in the range [2, 105].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 106<br>n &#x3D;&#x3D; queries.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; queries[i] &lt;&#x3D; 106</p><p>二叉搜索树最近节点查询。</p><blockquote><p>给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。<br>请你找出一个长度为 n 的 二维 答案数组 answer ，其中 answer[i] &#x3D; [mini, maxi] ：<br>mini 是树中小于等于 queries[i] 的 最大值 。如果不存在这样的值，则使用 -1 代替。<br>maxi 是树中大于等于 queries[i] 的 最小值 。如果不存在这样的值，则使用 -1 代替。<br>返回数组 answer 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我先提供一个次优解，思路是用treeset将二叉搜索树中的所有节点记录下来，然后利用 treeset 里的 ceiling 和 floor 两个特别的函数去分别找到比目标小的数字中的最大的和比目标大的数字中的最小的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - 为什么有 nlogn 是因为 treeset 有排序的动作<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        helper(root, set);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queries.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> queries.get(i);<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">if</span> (set.floor(val) != <span class="hljs-literal">null</span>) &#123;<br>                list.add(set.floor(val));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                list.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (set.ceiling(val) != <span class="hljs-literal">null</span>) &#123;<br>                list.add(set.ceiling(val));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                list.add(-<span class="hljs-number">1</span>);<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, TreeSet&lt;Integer&gt; set)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        set.add(root.val);<br>        helper(root.left, set);<br>        helper(root.right, set);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>treemap</tag>
      
      <tag>binary search</tag>
      
      <tag>bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2108. Find First Palindromic String in the Array</title>
    <link href="/posts/2527744301.html"/>
    <url>/posts/2527744301.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string “”.</p><p>A string is palindromic if it reads the same forward and backward.</p><p>Example 1:<br>Input: words &#x3D; [“abc”,”car”,”ada”,”racecar”,”cool”]<br>Output: “ada”<br>Explanation: The first string that is palindromic is “ada”.<br>Note that “racecar” is also palindromic, but it is not the first.</p><p>Example 2:<br>Input: words &#x3D; [“notapalindrome”,”racecar”]<br>Output: “racecar”<br>Explanation: The first and only string that is palindromic is “racecar”.</p><p>Example 3:<br>Input: words &#x3D; [“def”,”ghi”]<br>Output: “”<br>Explanation: There are no palindromic strings, so the empty string is returned.</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 100<br>words[i] consists only of lowercase English letters.</p><p>找出数组中的第一个回文字符串。</p><blockquote><p>给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 “” 。<br>回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到 input 数组里第一个出现的回文串。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn) - m个单词，单词平均长度为n<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">firstPalindrome</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String w : words) &#123;<br>            <span class="hljs-keyword">if</span> (helper(w)) &#123;<br>                <span class="hljs-keyword">return</span> w;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> word.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (word.charAt(left) != word.charAt(right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">7. Reverse Integer<br>9. Palindrome Number<br>2108. Find First Palindromic String in the Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2641. Cousins in Binary Tree II</title>
    <link href="/posts/2162354682.html"/>
    <url>/posts/2162354682.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins’ values.</p><p>Two nodes of a binary tree are cousins if they have the same depth with different parents.</p><p>Return the root of the modified tree.</p><p>Note that the depth of a node is the number of edges in the path from the root node to it.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2023/01/11/example11.png" alt="Example 1"><br>Input: root &#x3D; [5,4,9,1,10,null,7]<br>Output: [0,0,0,7,7,null,11]<br>Explanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.</p><ul><li>Node with value 5 does not have any cousins so its sum is 0.</li><li>Node with value 4 does not have any cousins so its sum is 0.</li><li>Node with value 9 does not have any cousins so its sum is 0.</li><li>Node with value 1 has a cousin with value 7 so its sum is 7.</li><li>Node with value 10 has a cousin with value 7 so its sum is 7.</li><li>Node with value 7 has cousins with values 1 and 10 so its sum is 11.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2023/01/11/diagram33.png" alt="Example 2"><br>Input: root &#x3D; [3,1,2]<br>Output: [0,0,0]<br>Explanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.</p><ul><li>Node with value 3 does not have any cousins so its sum is 0.</li><li>Node with value 1 does not have any cousins so its sum is 0.</li><li>Node with value 2 does not have any cousins so its sum is 0.</li></ul><p>Constraints:<br>The number of nodes in the tree is in the range [1, 105].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><p>二叉树的堂兄弟节点 II。</p><blockquote><p>给你一棵二叉树的根 root ，请你将每个节点的值替换成该节点的所有 堂兄弟节点值的和 。<br>如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 堂兄弟 。<br>请你返回修改值之后，树的根 root 。<br>注意，一个节点的深度指的是从树根节点到这个节点经过的边数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题跟 <a href="https://shurui91.github.io/posts/4130356496.html">993 题</a>版本一类似，节点值的修改规则也涉及到判断两个节点是否互为堂兄弟节点。同时因为堂兄弟节点的其中一个先决条件是两个节点的深度要一样，所以思路会往 BFS 上靠。</p><p>这道题的 BFS 做法有些特殊，一般情况下我们只需要用一个 queue 即可做到 BFS。但是这道题我们需要用到两个 list 实现 queue 的功能，一个记录当前层的节点，另一个记录下一层的节点；同时对于树的每一层，我们需要遍历两遍。</p><p>当我们遍历当前层的节点的时候，我们需要同时累加下一层的所有节点值的和，记为 nextLevelSum</p><ul><li>第一遍遍历当前层的时候，我们是为了计算 nextLevelSum</li><li>第二遍遍历当前层的时候，我们是为了站在当前层去修改下一层的节点值</li></ul><p>这个站在当前层去修改下一层的节点值的做法有点类似 117 题。117 题的最优解也是用 BFS 遍历一棵树，站在某一层上去处理下一层的节点的链接。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">replaceValueInTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        root.val = <span class="hljs-number">0</span>;<br>List&lt;TreeNode&gt; q = List.of(root);<br><span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>List&lt;TreeNode&gt; temp = q;<br>q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">nextLevelSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 站在当前层统计 nextLevelSum</span><br><span class="hljs-keyword">for</span> (TreeNode node : temp) &#123;<br><span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>q.add(node.left);<br>nextLevelSum += node.left.val;<br>&#125;<br><span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>q.add(node.right);<br>nextLevelSum += node.right.val;<br>&#125;<br>&#125;<br><br>            <span class="hljs-comment">// 站在当前层去修改下一层的节点值</span><br><span class="hljs-keyword">for</span> (TreeNode node : temp) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">childrenSum</span> <span class="hljs-operator">=</span> (node.left != <span class="hljs-literal">null</span> ? node.left.val : <span class="hljs-number">0</span>) + (node.right != <span class="hljs-literal">null</span> ? node.right.val : <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>node.left.val = nextLevelSum - childrenSum;<br>&#125;<br><span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>node.right.val = nextLevelSum - childrenSum;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">993. Cousins in Binary Tree<br>2641. Cousins in Binary Tree II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] LCP 30. 魔塔游戏</title>
    <link href="/posts/36345806.html"/>
    <url>/posts/36345806.html</url>
    
    <content type="html"><![CDATA[<h1 id="LCP-30-魔塔游戏"><a href="#LCP-30-魔塔游戏" class="headerlink" title="LCP 30. 魔塔游戏"></a>LCP 30. 魔塔游戏</h1><p>小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具&#x2F;怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。</p><p>小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血&#x2F;打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣<strong>最少需要调整几次</strong>，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。</p><p>示例 1：<br>输入：nums &#x3D; [100,100,100,-250,-60,-140,-50,-50,100,150]<br>输出：1<br>解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。</p><p>示例 2：<br>输入：nums &#x3D; [-200,-300,400,0]<br>输出：-1<br>解释：调整访问顺序也无法完成全部房间的访问。</p><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p><p><a href="https://leetcode.cn/problems/p0NxJO/description/">题目出处</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>房间里的数字有正有负，我们要确保的是小扣遍历完所有的房间之后血量依然大于零。一个比较容易发现的 corner case 是如果所有房间里的数字的累加和 + 1（小扣的原始血量）&lt;&#x3D; 0，那么说明无论怎么调整访问顺序都不行，此时返回 -1。反之如果所有房间里的数字的累加和 + 1（小扣的原始血量）&gt; 0 则说明一定有可行解。</p><p>此时我们讨论一般的情形，我们用一个变量 cur 记录过程中小扣的血量，遇到房间，就把房间内的血量累加到 cur。一般的情形是房间里的数字有正有负，在这期间也许走到某一个房间的时候小扣的血量会小于等于 0。为了让调整的次数尽可能少，此时我们需要用一个最小堆记录遍历过程中所有的负数，遍历到一个负数，在把他累加到 cur 的同事，也把这个数字放入最小堆，这样最大的负数在堆顶。当我们走到某个房间发现经过这个房间之后血量小于等于 0，此时我们把堆顶元素弹出，并把这个元素再从 cur 中减去，意思是跳过之前某个遇到的伤害最大的房间，也把他造成的伤害减去。在这个过程中我们用一个变量 count 记录调整的次数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">magicTower</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0</span>) &#123;<br>                cur += num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur += num;<br>                queue.offer(nums[i]);<br>                <span class="hljs-keyword">if</span> (cur &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; cur &lt;= <span class="hljs-number">0</span>) &#123;<br>                        cur -= queue.poll();<br>                        count++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 292. Nim Game</title>
    <link href="/posts/2832354358.html"/>
    <url>/posts/2832354358.html</url>
    
    <content type="html"><![CDATA[<p>You are playing the following Nim Game with your friend:<br>Initially, there is a heap of stones on the table.<br>You and your friend will alternate taking turns, and you go first.<br>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.<br>The one who removes the last stone is the winner.<br>Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.</p><p>Example 1:<br>Input: n &#x3D; 4<br>Output: false<br>Explanation: These are the possible outcomes:</p><ol><li>You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.</li><li>You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.</li><li>You remove 3 stones. Your friend removes the last stone. Your friend wins.<br>In all outcomes, your friend wins.</li></ol><p>Example 2:<br>Input: n &#x3D; 1<br>Output: true</p><p>Example 3:<br>Input: n &#x3D; 2<br>Output: true</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><p>Nim 游戏。</p><blockquote>你和你的朋友，两个人一起玩 Nim 游戏：<p>桌子上有一堆石头。<br>你们轮流进行自己的回合， 你作为先手 。<br>每一回合，轮到的人拿掉 1 - 3 块石头。<br>拿掉最后一块石头的人就是获胜者。<br>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道博弈论的题。我们看一下规律。</p><ol><li>如果石子数量在 1 - 3 之间，那么先手获胜</li><li>如果石子数量 &#x3D; 4，先手无论拿几个石子，后手都会获胜，因为后手可以拿到最后一个石子</li><li>如果石子数量在 5 - 7 之间，那么先手可以通过控制剩余石子数 &#x3D; 4 来决定自己拿几个石子，只要剩余石子个数 &#x3D; 4，那么还是先手获胜。比如一开始是 7 个石子，先手拿 3 个，剩余石子个数 &#x3D; 4，此时无论后手怎么拿，最后一个石子还是会被先手拿到</li><li>如果石子数量 &#x3D; 8，先手无论拿几个石子，后手都会获胜，因为先手拿完之后，石子数量介于 5 - 7 之间，只要后手确保自己拿完之后剩余石子数量 &#x3D; 4，后手就会获胜了，等同于 case 2。</li></ol><p>所以只要石子数量不是 4 的倍数，先手获胜。<br><a href="https://leetcode.cn/problems/nim-game/solutions/1003856/gong-shui-san-xie-noxiang-xin-ke-xue-xi-wmz2t/?envType=daily-question&envId=2024-02-04">引用</a></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWinNim</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>brainteaser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2966. Divide Array Into Arrays With Max Difference</title>
    <link href="/posts/2013326185.html"/>
    <url>/posts/2013326185.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums of size n and a positive integer k.</p><p>Divide the array into one or more arrays of size 3 satisfying the following conditions:</p><p>Each element of nums should be in exactly one array.<br>The difference between any two elements in one array is less than or equal to k.<br>Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,4,8,7,9,3,5,1], k &#x3D; 2<br>Output: [[1,1,3],[3,4,5],[7,8,9]]<br>Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].<br>The difference between any two elements in each array is less than or equal to 2.<br>Note that the order of elements is not important.</p><p>Example 2:<br>Input: nums &#x3D; [1,3,3,2,7,3], k &#x3D; 3<br>Output: []<br>Explanation: It is not possible to divide the array satisfying all the conditions.</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>n is a multiple of 3.<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>划分数组并满足最大差限制。</p><blockquote><p>给你一个长度为 n 的整数数组 nums，以及一个正整数 k 。<br>将这个数组划分为一个或多个长度为 3 的子数组，并满足以下条件：<br>nums 中的 每个 元素都必须 恰好 存在于某个子数组中。<br>子数组中 任意 两个元素的差必须小于或等于 k 。<br>返回一个 二维数组 ，包含所有的子数组。如果不可能满足条件，就返回一个空数组。如果有多个答案，返回 任意一个 即可。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目只问是否可以划分，并不在意数组元素的是否需要保持不变，所以这里我选择对 input 数组排序。排序过后，可以每次看三个元素 nums[i], nums[i + 1], nums[i + 2]。如果 nums[i + 2] - nums[i] &gt; k，说明当前这一行的最大元素和最小元素的差不满足题意，直接返回一个空的二维数组。如果满足题意，则还是每次看三个元素直到填满最后的二维数组。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(3n) - O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] divideArray(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length / <span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i += <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] - nums[i - <span class="hljs-number">2</span>] &lt;= k) &#123;<br>                res[m] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; nums[i - <span class="hljs-number">2</span>], nums[i - <span class="hljs-number">1</span>], nums[i] &#125;;<br>                m++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2859. Sum of Values at Indices With K Set Bits</title>
    <link href="/posts/3551767289.html"/>
    <url>/posts/3551767289.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums and an integer k.</p><p>Return an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.</p><p>The set bits in an integer are the 1’s present when it is written in binary.</p><p>For example, the binary representation of 21 is 10101, which has 3 set bits.</p><p>Example 1:<br>Input: nums &#x3D; [5,10,1,5,2], k &#x3D; 1<br>Output: 13<br>Explanation: The binary representation of the indices are:<br>0 &#x3D; 0002<br>1 &#x3D; 0012<br>2 &#x3D; 0102<br>3 &#x3D; 0112<br>4 &#x3D; 1002<br>Indices 1, 2, and 4 have k &#x3D; 1 set bits in their binary representation.<br>Hence, the answer is nums[1] + nums[2] + nums[4] &#x3D; 13.</p><p>Example 2:<br>Input: nums &#x3D; [4,3,2,1], k &#x3D; 2<br>Output: 1<br>Explanation: The binary representation of the indices are:<br>0 &#x3D; 002<br>1 &#x3D; 012<br>2 &#x3D; 102<br>3 &#x3D; 112<br>Only index 3 has k &#x3D; 2 set bits in its binary representation.<br>Hence, the answer is nums[3] &#x3D; 1.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; k &lt;&#x3D; 10</p><p>计算 K 置位下标对应元素的和。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。<br>请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。<br>整数的二进制表示中的 1 就是这个整数的 置位 。<br>例如，21 的二进制表示为 10101 ，其中有 3 个置位。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于数组内的每一个数字，我们看一下数字的二进制表达里有几个 1，如果当前数字的二进制表达里 1 的个数等于这个数字在 input 数组内的下标，则把这个数字累加到结果里。</p><p>计算数字的二进制表达里有几个 1 等同于 191 题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumIndicesWithKSetBits</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (helper(i) == k) &#123;<br>                res += nums.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">191. Number of 1 Bits<br>2859. Sum of Values at Indices With K Set Bits<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2744. Find Maximum Number of String Pairs</title>
    <link href="/posts/2279246855.html"/>
    <url>/posts/2279246855.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array words consisting of distinct strings.</p><p>The string words[i] can be paired with the string words[j] if:</p><p>The string words[i] is equal to the reversed string of words[j].<br>0 &lt;&#x3D; i &lt; j &lt; words.length.<br>Return the maximum number of pairs that can be formed from the array words.</p><p>Note that each string can belong in at most one pair.</p><p>Example 1:<br>Input: words &#x3D; [“cd”,”ac”,”dc”,”ca”,”zz”]<br>Output: 2<br>Explanation: In this example, we can form 2 pair of strings in the following way:</p><ul><li>We pair the 0th string with the 2nd string, as the reversed string of word[0] is “dc” and is equal to words[2].</li><li>We pair the 1st string with the 3rd string, as the reversed string of word[1] is “ca” and is equal to words[3].<br>It can be proven that 2 is the maximum number of pairs that can be formed.</li></ul><p>Example 2:<br>Input: words &#x3D; [“ab”,”ba”,”cc”]<br>Output: 1<br>Explanation: In this example, we can form 1 pair of strings in the following way:</p><ul><li>We pair the 0th string with the 1st string, as the reversed string of words[1] is “ab” and is equal to words[0].<br>It can be proven that 1 is the maximum number of pairs that can be formed.</li></ul><p>Example 3:<br>Input: words &#x3D; [“aa”,”ab”]<br>Output: 0<br>Explanation: In this example, we are unable to form any pair of strings.</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 50<br>words[i].length &#x3D;&#x3D; 2<br>words consists of distinct strings.<br>words[i] contains only lowercase English letters.</p><p>最大字符串配对数目。</p><blockquote><p>给你一个下标从 0 开始的数组 words ，数组中包含 互不相同 的字符串。<br>如果字符串 words[i] 与字符串 words[j] 满足以下条件，我们称它们可以匹配：<br>字符串 words[i] 等于 words[j] 的反转字符串。<br>0 &lt;&#x3D; i &lt; j &lt; words.length<br>请你返回数组 words 中的 最大 匹配数目。<br>注意，每个字符串最多匹配一次。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目给的是一些互不相同的字符串，所以一开始我用一个 hashset 把所有字符串存起来。因为题目要我们找的匹配字符串其实是找两个互为回文的字符串，所以这里我写一个 reverse 函数判断回文，对于某个单词，我得到他的回文之后去 hashset 判断这个回文是否存在于 hashset。注意这里有一个 corner case 是如果是类似 aaa 或者 zz 这种本身就是回文的单词，我们需要忽略。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumNumberOfStringPairs</span><span class="hljs-params">(String[] words)</span> &#123;<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (String word : words) &#123;<br><span class="hljs-keyword">if</span> (!word.equals(reverse(word))) &#123;<br>set.add(word);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (String word : words) &#123;<br><span class="hljs-keyword">if</span> (set.contains(word) &amp;&amp; set.contains(reverse(word))) &#123;<br>count++;<br>set.remove(word);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">reverse</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">char</span>[] letters = s.toCharArray();<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> letters[left];<br>letters[left] = letters[right];<br>letters[right] = temp;<br>left++;<br>right--;<br>&#125;<br><span class="hljs-keyword">return</span> String.valueOf(letters);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2085. Count Common Words With One Occurrence</title>
    <link href="/posts/2678313631.html"/>
    <url>/posts/2678313631.html</url>
    
    <content type="html"><![CDATA[<p>Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.</p><p>Example 1:<br>Input: words1 &#x3D; [“leetcode”,”is”,”amazing”,”as”,”is”], words2 &#x3D; [“amazing”,”leetcode”,”is”]<br>Output: 2<br>Explanation:</p><ul><li>“leetcode” appears exactly once in each of the two arrays. We count this string.</li><li>“amazing” appears exactly once in each of the two arrays. We count this string.</li><li>“is” appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.</li><li>“as” appears once in words1, but does not appear in words2. We do not count this string.<br>Thus, there are 2 strings that appear exactly once in each of the two arrays.</li></ul><p>Example 2:<br>Input: words1 &#x3D; [“b”,”bb”,”bbb”], words2 &#x3D; [“a”,”aa”,”aaa”]<br>Output: 0<br>Explanation: There are no strings that appear in each of the two arrays.</p><p>Example 3:<br>Input: words1 &#x3D; [“a”,”ab”], words2 &#x3D; [“a”,”a”,”a”,”ab”]<br>Output: 1<br>Explanation: The only string that appears exactly once in each of the two arrays is “ab”.</p><p>Constraints:<br>1 &lt;&#x3D; words1.length, words2.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; words1[i].length, words2[j].length &lt;&#x3D; 30<br>words1[i] and words2[j] consists only of lowercase English letters.</p><p>统计出现过一次的公共字符串。</p><blockquote><p>给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用两个 hashmap map1 和 map2 分别记录 words1 和 words2 中每个不同单词的出现次数。遍历 map1 中的 keySet，如果 keySet 中的单词在 words1 和 words2 中均只出现一次，则这是一个符合题意的公共字符串。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countWords</span><span class="hljs-params">(String[] words1, String[] words2)</span> &#123;<br>        HashMap&lt;String, Integer&gt; map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words1) &#123;<br>            map1.put(word, map1.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        HashMap&lt;String, Integer&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words2) &#123;<br>            map2.put(word, map2.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String word : map1.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map1.get(word);<br>            <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span> &amp;&amp; map2.containsKey(word) &amp;&amp; map2.get(word) == <span class="hljs-number">1</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2696. Minimum String Length After Removing Substrings</title>
    <link href="/posts/4203426242.html"/>
    <url>/posts/4203426242.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s consisting only of uppercase English letters.</p><p>You can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings “AB” or “CD” from s.</p><p>Return the minimum possible length of the resulting string that you can obtain.</p><p>Note that the string concatenates after removing the substring and could produce new “AB” or “CD” substrings.</p><p>Example 1:<br>Input: s &#x3D; “ABFCACDB”<br>Output: 2<br>Explanation: We can do the following operations:</p><ul><li>Remove the substring “ABFCACDB”, so s &#x3D; “FCACDB”.</li><li>Remove the substring “FCACDB”, so s &#x3D; “FCAB”.</li><li>Remove the substring “FCAB”, so s &#x3D; “FC”.<br>So the resulting length of the string is 2.<br>It can be shown that it is the minimum length that we can obtain.</li></ul><p>Example 2:<br>Input: s &#x3D; “ACBBD”<br>Output: 5<br>Explanation: We cannot do any operations on the string so the length remains the same.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s consists only of uppercase English letters.</p><p>删除子串后的字符串最小长度。</p><blockquote><p>给你一个仅由 大写 英文字符组成的字符串 s 。<br>你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 “AB” 或 “CD” 子字符串。<br>通过执行操作，删除所有 “AB” 和 “CD” 子串，返回可获得的最终字符串的 最小 可能长度。<br>注意，删除子串后，重新连接出的字符串可能会产生新的 “AB” 或 “CD” 子串。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历字符串中的每一个字母，将每个字母入栈。如果当前字母是 B，检查栈顶元素是否为 A，如果是则把 A 弹出；如果当前字母是 D，检查栈顶元素是否为 C，如果是则把 C 弹出。最后返回栈内元素个数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minLength</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peekLast() == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>                stack.pollLast();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;D&#x27;</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peekLast() == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>                stack.pollLast();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.offerLast(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1979. Find Greatest Common Divisor of Array</title>
    <link href="/posts/3832381755.html"/>
    <url>/posts/3832381755.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.</p><p>The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.</p><p>Example 1:<br>Input: nums &#x3D; [2,5,6,9,10]<br>Output: 2<br>Explanation:<br>The smallest number in nums is 2.<br>The largest number in nums is 10.<br>The greatest common divisor of 2 and 10 is 2.</p><p>Example 2:<br>Input: nums &#x3D; [7,5,6,8,3]<br>Output: 1<br>Explanation:<br>The smallest number in nums is 3.<br>The largest number in nums is 8.<br>The greatest common divisor of 3 and 8 is 1.</p><p>Example 3:<br>Input: nums &#x3D; [3,3]<br>Output: 3<br>Explanation:<br>The smallest number in nums is 3.<br>The largest number in nums is 3.<br>The greatest common divisor of 3 and 3 is 3.</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><p>找出数组的最大公约数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>与其他求最大公约数的题目类似。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 需要用O(n)的时间找到最大的数字和最小的数字，然后再去求二者的最大公约数。<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findGCD</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            min = Math.min(min, num);<br>            max = Math.max(max, num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(min, max);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> b;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a == b) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(b, a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>gcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2807. Insert Greatest Common Divisors in Linked List</title>
    <link href="/posts/985411869.html"/>
    <url>/posts/985411869.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a linked list head, in which each node contains an integer value.</p><p>Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.</p><p>Return the linked list after insertion.</p><p>The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" alt="Example 1"><br>Input: head &#x3D; [18,6,10,3]<br>Output: [18,6,6,2,10,1,3]<br>Explanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes (nodes in blue are the inserted nodes).</p><ul><li>We insert the greatest common divisor of 18 and 6 &#x3D; 6 between the 1st and the 2nd nodes.</li><li>We insert the greatest common divisor of 6 and 10 &#x3D; 2 between the 2nd and the 3rd nodes.</li><li>We insert the greatest common divisor of 10 and 3 &#x3D; 1 between the 3rd and the 4th nodes.<br>There are no more adjacent nodes, so we return the linked list.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" alt="Example 2"><br>Input: head &#x3D; [7]<br>Output: [7]<br>Explanation: The 1st diagram denotes the initial linked list and the 2nd diagram denotes the linked list after inserting the new nodes.<br>There are no pairs of adjacent nodes, so we return the initial linked list.</p><p>Constraints:<br>The number of nodes in the list is in the range [1, 5000].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>在链表中插入最大公约数。<br>给你一个链表的头 head ，每个结点包含一个整数值。<br>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 最大公约数 。<br>请你返回插入之后的链表。<br>两个数的 最大公约数 是可以被两个数字整除的最大正整数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题意，在每两个相邻的 node 之间再插入一个新的 node。注意求最大公约数的做法，需要时常复习。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">insertGreatestCommonDivisors</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> cur.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> cur.next.val;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(gcd(first, second));<br>            newNode.next = cur.next;<br>            cur.next = newNode;<br>            cur = cur.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> b;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a == b) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            <span class="hljs-keyword">return</span> gcd(a - b, b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> gcd(b - a, a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>gcd</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1578. Minimum Time to Make Rope Colorful</title>
    <link href="/posts/3452602333.html"/>
    <url>/posts/3452602333.html</url>
    
    <content type="html"><![CDATA[<p>Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.</p><p>Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.</p><p>Return the minimum time Bob needs to make the rope colorful.</p><p>Example 1:<br>Input: colors &#x3D; “abaac”, neededTime &#x3D; [1,2,3,4,5]<br>Output: 3<br>Explanation: In the above image, ‘a’ is blue, ‘b’ is red, and ‘c’ is green.<br>Bob can remove the blue balloon at index 2. This takes 3 seconds.<br>There are no longer two consecutive balloons of the same color. Total time &#x3D; 3.</p><p>Example 2:<br>Input: colors &#x3D; “abc”, neededTime &#x3D; [1,2,3]<br>Output: 0<br>Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.</p><p>Example 3:<br>Input: colors &#x3D; “aabaa”, neededTime &#x3D; [1,2,3,4,1]<br>Output: 2<br>Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.<br>There are no longer two consecutive balloons of the same color. Total time &#x3D; 1 + 1 &#x3D; 2.</p><p>Constraints:<br>n &#x3D;&#x3D; colors.length &#x3D;&#x3D; neededTime.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; neededTime[i] &lt;&#x3D; 104<br>colors contains only lowercase English letters.</p><p>使绳子变成彩色的最短时间。</p><blockquote><p>Alice 把 n 个气球排列在一根绳子上。给你一个下标从 0 开始的字符串 colors ，其中 colors[i] 是第 i 个气球的颜色。<br>Alice 想要把绳子装扮成 彩色 ，且她不希望两个连续的气球涂着相同的颜色，所以她喊来 Bob 帮忙。Bob 可以从绳子上移除一些气球使绳子变成 彩色 。给你一个下标从 0 开始的整数数组 neededTime ，其中 neededTime[i] 是 Bob 从绳子上移除第 i 个气球需要的时间（以秒为单位）。<br>返回 Bob 使绳子变成 彩色 需要的 最少时间 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。对于任何两个连续的气球，如果他们的颜色相同，则需要去除 neededTime 更多的那个。<br>具体的实现上，对于任何两个连续的气球 i 和 i + 1，如果 i 的 neededTime 更多，则我们在累加 i + 1 的 neededTime 的同时，将 i 和 i + 1 的位置 swap 一下，这样就能使 i 可以跟后面的 i + 2 继续比较了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(String colors, <span class="hljs-type">int</span>[] neededTime)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> colors.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (colors.charAt(i) == colors.charAt(i + <span class="hljs-number">1</span>)) &#123;<br>                res += Math.min(neededTime[i], neededTime[i + <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (neededTime[i] &gt; neededTime[i + <span class="hljs-number">1</span>]) &#123;<br>                    swap(neededTime, i, i + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2660. Determine the Winner of a Bowling Game</title>
    <link href="/posts/969600274.html"/>
    <url>/posts/969600274.html</url>
    
    <content type="html"><![CDATA[<p>You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.</p><p>The bowling game consists of n turns, and the number of pins in each turn is exactly 10.</p><p>Assume a player hit xi pins in the ith turn. The value of the ith turn for the player is:</p><p>2xi if the player hit 10 pins in any of the previous two turns.<br>Otherwise, It is xi.<br>The score of the player is the sum of the values of their n turns.</p><p>Return<br>1 if the score of player 1 is more than the score of player 2,<br>2 if the score of player 2 is more than the score of player 1, and<br>0 in case of a draw.</p><p>Example 1:<br>Input: player1 &#x3D; [4,10,7,9], player2 &#x3D; [6,5,2,3]<br>Output: 1<br>Explanation: The score of player1 is 4 + 10 + 2<em>7 + 2</em>9 &#x3D; 46.<br>The score of player2 is 6 + 5 + 2 + 3 &#x3D; 16.<br>Score of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.</p><p>Example 2:<br>Input: player1 &#x3D; [3,5,7,6], player2 &#x3D; [8,10,10,2]<br>Output: 2<br>Explanation: The score of player1 is 3 + 5 + 7 + 6 &#x3D; 21.<br>The score of player2 is 8 + 10 + 2<em>10 + 2</em>2 &#x3D; 42.<br>Score of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.</p><p>Example 3:<br>Input: player1 &#x3D; [2,3], player2 &#x3D; [4,1]<br>Output: 0<br>Explanation: The score of player1 is 2 + 3 &#x3D; 5<br>The score of player2 is 4 + 1 &#x3D; 5<br>The score of player1 equals to the score of player2, so, there is a draw, and the answer is 0.</p><p>Constraints:<br>n &#x3D;&#x3D; player1.length &#x3D;&#x3D; player2.length<br>1 &lt;&#x3D; n &lt;&#x3D; 1000<br>0 &lt;&#x3D; player1[i], player2[i] &lt;&#x3D; 10</p><p>保龄球游戏的获胜者。</p><blockquote>给你两个下标从 0 开始的整数数组 player1 和 player2 ，分别表示玩家 1 和玩家 2 击中的瓶数。<p>保龄球比赛由 n 轮组成，每轮的瓶数恰好为 10 。</p><p>假设玩家在第 i 轮中击中 xi 个瓶子。玩家第 i 轮的价值为：</p><p>如果玩家在该轮的前两轮的任何一轮中击中了 10 个瓶子，则为 2xi 。<br>否则，为 xi 。<br>玩家的得分是其 n 轮价值的总和。</p><p>返回</p><p>如果玩家 1 的得分高于玩家 2 的得分，则为 1 ；<br>如果玩家 2 的得分高于玩家 1 的得分，则为 2 ；<br>如果平局，则为 0 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照题目的定义，我们计算一下每个玩家的得分。对于某一轮的分数，如果往前看一轮（或者两轮）是合法的且前一轮（或者前两轮）的分数是 10 分，那么当前轮的分数可以乘以 2。比较两个 player 谁的分数更高。简单模拟题意即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">isWinner</span><span class="hljs-params">(<span class="hljs-type">int</span>[] player1, <span class="hljs-type">int</span>[] player2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> player1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">score1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; player1[i - <span class="hljs-number">1</span>] == <span class="hljs-number">10</span>) &#123;<br>                score1 += <span class="hljs-number">2</span> * player1[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; player1[i - <span class="hljs-number">2</span>] == <span class="hljs-number">10</span>) &#123;<br>                score1 += <span class="hljs-number">2</span> * player1[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                score1 += player1[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">score2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; player2[i - <span class="hljs-number">1</span>] == <span class="hljs-number">10</span>) &#123;<br>                score2 += <span class="hljs-number">2</span> * player2[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; player2[i - <span class="hljs-number">2</span>] == <span class="hljs-number">10</span>) &#123;<br>                score2 += <span class="hljs-number">2</span> * player2[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                score2 += player2[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (score1 &gt; score2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score1 &lt; score2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1496. Path Crossing</title>
    <link href="/posts/1525497990.html"/>
    <url>/posts/1525497990.html</url>
    
    <content type="html"><![CDATA[<p>Given a string path, where path[i] &#x3D; ‘N’, ‘S’, ‘E’ or ‘W’, each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.</p><p>Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/06/10/screen-shot-2020-06-10-at-123929-pm.png" alt="Example 1"><br>Input: path &#x3D; “NES”<br>Output: false<br>Explanation: Notice that the path doesn’t cross any point more than once.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/06/10/screen-shot-2020-06-10-at-123843-pm.png" alt="Example 2"><br>Input: path &#x3D; “NESWW”<br>Output: true<br>Explanation: Notice that the path visits the origin twice.</p><p>Constraints:<br>1 &lt;&#x3D; path.length &lt;&#x3D; 104<br>path[i] is either ‘N’, ‘S’, ‘E’, or ‘W’.</p><p>判断路径是否相交。</p><blockquote><p>给你一个字符串 path，其中 path[i] 的值可以是 ‘N’、’S’、’E’ 或者 ‘W’，分别表示向北、向南、向东、向西移动一个单位。<br>你从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。<br>如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 true ；否则，返回 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把坐标转换成一个字符串记录在 hashset，如果遇到重复的坐标则说明路径会相交，返回 true；否则返回 false。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPathCrossing</span><span class="hljs-params">(String path)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> path.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        set.add(x + <span class="hljs-string">&quot;,&quot;</span> + y);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> path.charAt(i);<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;<br>                y++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;S&#x27;</span>) &#123;<br>                y--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>                x++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;W&#x27;</span>) &#123;<br>                x--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!set.add(x + <span class="hljs-string">&quot;,&quot;</span> + y)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2415. Reverse Odd Levels of Binary Tree</title>
    <link href="/posts/2438119101.html"/>
    <url>/posts/2438119101.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.</p><p>For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].<br>Return the root of the reversed tree.</p><p>A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.</p><p>The level of a node is the number of edges along the path between it and the root node.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/07/28/first_case1.png" alt="Example 1"><br>Input: root &#x3D; [2,3,5,8,13,21,34]<br>Output: [2,5,3,8,13,21,34]<br>Explanation:<br>The tree has only one odd level.<br>The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/07/28/second_case3.png" alt="Example 2"><br>Input: root &#x3D; [7,13,11]<br>Output: [7,11,13]<br>Explanation:<br>The nodes at level 1 are 13, 11, which are reversed and become 11, 13.</p><p>Example 3:<br>Input: root &#x3D; [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]<br>Output: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]<br>Explanation:<br>The odd levels have non-zero values.<br>The nodes at level 1 were 1, 2, and are 2, 1 after the reversal.<br>The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 214].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>root is a perfect binary tree.</p><p>反转二叉树的奇数层。</p><blockquote><p>给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。<br>例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。<br>反转后，返回树的根节点。<br>完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。<br>节点的 层数 等于该节点到根节点之间的边数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我提供一个 前序遍历&#x2F;DFS 的思路，我需要一个 helper 函数，因为需要统计当前层的深度。如果遇到奇数层，则需要交换当前层的左右两个节点。这个 helper 函数是从第二层开始的因为第一层只有 root 一个节点。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">reverseOddLevels</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root.left, root.right, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode left, TreeNode right, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (depth % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> left.val;<br>            left.val = right.val;<br>            right.val = temp;<br>        &#125;<br>        helper(left.right, right.left, depth + <span class="hljs-number">1</span>);<br>        helper(left.left, right.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2482. Difference Between Ones and Zeros in Row and Column</title>
    <link href="/posts/1054293803.html"/>
    <url>/posts/1054293803.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed m x n binary matrix grid.</p><p>A 0-indexed m x n difference matrix diff is created with the following procedure:<br>Let the number of ones in the ith row be onesRowi.<br>Let the number of ones in the jth column be onesColj.<br>Let the number of zeros in the ith row be zerosRowi.<br>Let the number of zeros in the jth column be zerosColj.<br>diff[i][j] &#x3D; onesRowi + onesColj - zerosRowi - zerosColj<br>Return the difference matrix diff.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png" alt="Example 1"><br>Input: grid &#x3D; [[0,1,1],[1,0,1],[0,0,1]]<br>Output: [[0,0,4],[0,0,4],[-2,-2,2]]<br>Explanation:</p><ul><li>diff[0][0] &#x3D; onesRow0 + onesCol0 - zerosRow0 - zerosCol0 &#x3D; 2 + 1 - 1 - 2 &#x3D; 0 </li><li>diff[0][1] &#x3D; onesRow0 + onesCol1 - zerosRow0 - zerosCol1 &#x3D; 2 + 1 - 1 - 2 &#x3D; 0 </li><li>diff[0][2] &#x3D; onesRow0 + onesCol2 - zerosRow0 - zerosCol2 &#x3D; 2 + 3 - 1 - 0 &#x3D; 4 </li><li>diff[1][0] &#x3D; onesRow1 + onesCol0 - zerosRow1 - zerosCol0 &#x3D; 2 + 1 - 1 - 2 &#x3D; 0 </li><li>diff[1][1] &#x3D; onesRow1 + onesCol1 - zerosRow1 - zerosCol1 &#x3D; 2 + 1 - 1 - 2 &#x3D; 0 </li><li>diff[1][2] &#x3D; onesRow1 + onesCol2 - zerosRow1 - zerosCol2 &#x3D; 2 + 3 - 1 - 0 &#x3D; 4 </li><li>diff[2][0] &#x3D; onesRow2 + onesCol0 - zerosRow2 - zerosCol0 &#x3D; 1 + 1 - 2 - 2 &#x3D; -2</li><li>diff[2][1] &#x3D; onesRow2 + onesCol1 - zerosRow2 - zerosCol1 &#x3D; 1 + 1 - 2 - 2 &#x3D; -2</li><li>diff[2][2] &#x3D; onesRow2 + onesCol2 - zerosRow2 - zerosCol2 &#x3D; 1 + 3 - 2 - 0 &#x3D; 2</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png" alt="Example 2"><br>Input: grid &#x3D; [[1,1,1],[1,1,1]]<br>Output: [[5,5,5],[5,5,5]]<br>Explanation:</p><ul><li>diff[0][0] &#x3D; onesRow0 + onesCol0 - zerosRow0 - zerosCol0 &#x3D; 3 + 2 - 0 - 0 &#x3D; 5</li><li>diff[0][1] &#x3D; onesRow0 + onesCol1 - zerosRow0 - zerosCol1 &#x3D; 3 + 2 - 0 - 0 &#x3D; 5</li><li>diff[0][2] &#x3D; onesRow0 + onesCol2 - zerosRow0 - zerosCol2 &#x3D; 3 + 2 - 0 - 0 &#x3D; 5</li><li>diff[1][0] &#x3D; onesRow1 + onesCol0 - zerosRow1 - zerosCol0 &#x3D; 3 + 2 - 0 - 0 &#x3D; 5</li><li>diff[1][1] &#x3D; onesRow1 + onesCol1 - zerosRow1 - zerosCol1 &#x3D; 3 + 2 - 0 - 0 &#x3D; 5</li><li>diff[1][2] &#x3D; onesRow1 + onesCol2 - zerosRow1 - zerosCol2 &#x3D; 3 + 2 - 0 - 0 &#x3D; 5</li></ul><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>1 &lt;&#x3D; m * n &lt;&#x3D; 105<br>grid[i][j] is either 0 or 1.</p><p>行和列中一和零的差值。</p><blockquote><p>给你一个下标从 0 开始的 m x n 二进制矩阵 grid 。<br>我们按照如下过程，定义一个下标从 0 开始的 m x n 差值矩阵 diff ：<br>令第 i 行一的数目为 onesRowi 。<br>令第 j 列一的数目为 onesColj 。<br>令第 i 行零的数目为 zerosRowi 。<br>令第 j 列零的数目为 zerosColj 。<br>diff[i][j] &#x3D; onesRowi + onesColj - zerosRowi - zerosColj<br>请你返回差值矩阵 diff 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>创建两个hashmap分别记录每一行和每一列上 1 的个数，然后按照题目给的公式返回二维数组。这里我用数组代替 hashmap 加快速度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn) - output matrix</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] onesMinusZeros(<span class="hljs-type">int</span>[][] grid) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] rowMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[] colMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    rowMap[i]++;<br>                    colMap[j]++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[][] diff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                diff[i][j] = rowMap[i] + colMap[j] - (m - rowMap[i]) - (n - colMap[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2697. Lexicographically Smallest Palindrome</title>
    <link href="/posts/3645504380.html"/>
    <url>/posts/3645504380.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.</p><p>Your task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.</p><p>A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.</p><p>Return the resulting palindrome string.</p><p>Example 1:<br>Input: s &#x3D; “egcfe”<br>Output: “efcfe”<br>Explanation: The minimum number of operations to make “egcfe” a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is “efcfe”, by changing ‘g’.</p><p>Example 2:<br>Input: s &#x3D; “abcd”<br>Output: “abba”<br>Explanation: The minimum number of operations to make “abcd” a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is “abba”.</p><p>Example 3:<br>Input: s &#x3D; “seven”<br>Output: “neven”<br>Explanation: The minimum number of operations to make “seven” a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is “neven”.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s consists of only lowercase English letters.</p><p>字典序最小回文串。</p><blockquote><p>给你一个由 小写英文字母 组成的字符串 s ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 替换  s 中的一个字符。<br>请你执行 尽可能少的操作 ，使 s 变成一个 回文串 。如果执行 最少 操作次数的方案不止一种，则只需选取 字典序最小 的方案。<br>对于两个长度相同的字符串 a 和 b ，在 a 和 b 出现不同的第一个位置，如果该位置上 a 中对应字母比 b 中对应字母在字母表中出现顺序更早，则认为 a 的字典序比 b 的字典序要小。<br>返回最终的回文字符串。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就是处理回文串那一类的题，唯一需要留意的是当左右指针指向的元素不一样的时候，把字典序较大的那一个字母替换成字典序较小的那一个。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeSmallestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] letters = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> letters[left];<br>            <span class="hljs-type">char</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> letters[right];<br>            <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>                letters[left] = r;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                letters[right] = l;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(letters);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1903. Largest Odd Number in String</title>
    <link href="/posts/399132142.html"/>
    <url>/posts/399132142.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string “” if no odd integer exists.</p><p>A substring is a contiguous sequence of characters within a string.</p><p>Example 1:<br>Input: num &#x3D; “52”<br>Output: “5”<br>Explanation: The only non-empty substrings are “5”, “2”, and “52”. “5” is the only odd number.</p><p>Example 2:<br>Input: num &#x3D; “4206”<br>Output: “”<br>Explanation: There are no odd numbers in “4206”.</p><p>Example 3:<br>Input: num &#x3D; “35427”<br>Output: “35427”<br>Explanation: “35427” is already an odd number.</p><p>Constraints:<br>1 &lt;&#x3D; num.length &lt;&#x3D; 105<br>num only consists of digits and does not contain any leading zeros.</p><p>字符串中的最大奇数。</p><blockquote><p>给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 “” 。<br>子字符串 是字符串中的一个连续的字符序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。因为只允许删除字符，但是从左往右删除字符是无法改变数字的奇偶性的，所以思路是从右往左遍历 input 字符串，看看最右边一个字符串到底是奇数还是偶数。如果是奇数就可以直接返回了；如果是偶数，则删除当前字符，接着看左边的字符。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestOddNumber</span><span class="hljs-params">(String num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> num.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> num.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (d % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> num.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> str;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1716. Calculate Money in Leetcode Bank</title>
    <link href="/posts/2716823774.html"/>
    <url>/posts/2716823774.html</url>
    
    <content type="html"><![CDATA[<p>Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.</p><p>He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.</p><p>Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.</p><p>Example 1:<br>Input: n &#x3D; 4<br>Output: 10<br>Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 &#x3D; 10.</p><p>Example 2:<br>Input: n &#x3D; 10<br>Output: 37<br>Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) &#x3D; 37. Notice that on the 2nd Monday, Hercy only puts in $2.</p><p>Example 3:<br>Input: n &#x3D; 20<br>Output: 96<br>Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) &#x3D; 96.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 1000</p><p>计算力扣银行的钱。</p><blockquote><p>Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。<br>最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比<code>前一个周一</code>多存入 1 块钱。<br>给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道数学题。因为存钱是按照星期来存的，所以我们一开始用 n 除以 7，看看一共有几个星期；如果有余数，则再进行计算。对于一整个星期，计算方式就是等差数列。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(round)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalMoney</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">round</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; round; i++) &#123;<br>            res += helper(start++, end++);<br>        &#125;<br><br>        <span class="hljs-comment">// last round</span><br>        start = <span class="hljs-number">1</span> + round;<br>        end = remainder + round;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            res += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// first item, last item, round</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">return</span> (start + end) * (end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1688. Count of Matches in Tournament</title>
    <link href="/posts/695807852.html"/>
    <url>/posts/695807852.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer n, the number of teams in a tournament that has strange rules:<br>If the current number of teams is even, each team gets paired with another team. A total of n &#x2F; 2 matches are played, and n &#x2F; 2 teams advance to the next round.</p><p>If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) &#x2F; 2 matches are played, and (n - 1) &#x2F; 2 + 1 teams advance to the next round.</p><p>Return the number of matches played in the tournament until a winner is decided.</p><p>Example 1:<br>Input: n &#x3D; 7<br>Output: 6<br>Explanation: Details of the tournament: </p><ul><li>1st Round: Teams &#x3D; 7, Matches &#x3D; 3, and 4 teams advance.</li><li>2nd Round: Teams &#x3D; 4, Matches &#x3D; 2, and 2 teams advance.</li><li>3rd Round: Teams &#x3D; 2, Matches &#x3D; 1, and 1 team is declared the winner.<br>Total number of matches &#x3D; 3 + 2 + 1 &#x3D; 6.</li></ul><p>Example 2:<br>Input: n &#x3D; 14<br>Output: 13<br>Explanation: Details of the tournament:</p><ul><li>1st Round: Teams &#x3D; 14, Matches &#x3D; 7, and 7 teams advance.</li><li>2nd Round: Teams &#x3D; 7, Matches &#x3D; 3, and 4 teams advance.</li><li>3rd Round: Teams &#x3D; 4, Matches &#x3D; 2, and 2 teams advance.</li><li>4th Round: Teams &#x3D; 2, Matches &#x3D; 1, and 1 team is declared the winner.<br>Total number of matches &#x3D; 7 + 3 + 2 + 1 &#x3D; 13.</li></ul><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 200</p><p>比赛中的配对次数。</p><blockquote><p>给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：<br>如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n &#x2F; 2 场比赛，且产生 n &#x2F; 2 支队伍进入下一轮。<br>如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) &#x2F; 2 场比赛，且产生 (n - 1) &#x2F; 2 + 1 支队伍进入下一轮。<br>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当队伍个数 n 不等于 1 的时候，就需要一直配对来比较到底谁是最后的胜者。题目规定了当队伍个数为偶数的时候，就两两配对看谁是胜者；当队伍个数为偶数的时候，可以随机挑出一个胜者，让剩下的人再两两配对看谁是胜者，所以无论队伍个数是奇数还是偶数，配对次数永远都是<code>当前队伍个数 / 2</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n&#x2F;2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfMatches</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) &#123;<br>            count += n / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                n = n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                n /= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2264. Largest 3-Same-Digit Number in String</title>
    <link href="/posts/3666700503.html"/>
    <url>/posts/3666700503.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string num representing a large integer. An integer is good if it meets the following conditions:<br>It is a substring of num with length 3.<br>It consists of only one unique digit.<br>Return the maximum good integer as a string or an empty string “” if no such integer exists.</p><p>Note:<br>A substring is a contiguous sequence of characters within a string.<br>There may be leading zeroes in num or a good integer.</p><p>Example 1:<br>Input: num &#x3D; “6777133339”<br>Output: “777”<br>Explanation: There are two distinct good integers: “777” and “333”.<br>“777” is the largest, so we return “777”.</p><p>Example 2:<br>Input: num &#x3D; “2300019”<br>Output: “000”<br>Explanation: “000” is the only good integer.</p><p>Example 3:<br>Input: num &#x3D; “42352338”<br>Output: “”<br>Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.</p><p>Constraints:<br>3 &lt;&#x3D; num.length &lt;&#x3D; 1000<br>num only consists of digits.</p><p>字符串中最大的 3 位相同数字。</p><blockquote><p>给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：<br>该整数是 num 的一个长度为 3 的 子字符串 。<br>该整数由唯一一个数字重复 3 次组成。<br>以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 “” 。<br>注意：<br>子字符串 是字符串中的一个连续字符序列。<br>num 或优质整数中可能存在 前导零 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从 index &#x3D; 0 的位置开始截取一个长度为 3 的子串，看看这个子串是否满足三个字符都相同，不满足则接着往后看；如果是连续三个字符都相同，那么看一下这个子串形成的数字是否比之前记录的结果要大，以决定是否要更新结果。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestGoodInteger</span><span class="hljs-params">(String num)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> num.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (num.charAt(i) == num.charAt(i + <span class="hljs-number">1</span>) &amp;&amp; num.charAt(i) == num.charAt(i + <span class="hljs-number">2</span>)) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> helper(num.charAt(i));<br>                <span class="hljs-keyword">if</span> (str.compareTo(res) &gt; <span class="hljs-number">0</span>) &#123;<br>                    res = str;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span> cur)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(cur);<br>        sb.append(cur);<br>        sb.append(cur);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1266. Minimum Time Visiting All Points</title>
    <link href="/posts/1839430230.html"/>
    <url>/posts/1839430230.html</url>
    
    <content type="html"><![CDATA[<p>On a 2D plane, there are n points with integer coordinates points[i] &#x3D; [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.</p><p>You can move according to these rules:<br>In 1 second, you can either:<br>move vertically by one unit,<br>move horizontally by one unit, or<br>move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).<br>You have to visit the points in the same order as they appear in the array.<br>You are allowed to pass through points that appear later in the order, but these do not count as visits.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/11/14/1626_example_1.PNG" alt="Example 1"><br>Input: points &#x3D; [[1,1],[3,4],[-1,0]]<br>Output: 7<br>Explanation: One optimal path is [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]<br>Time from [1,1] to [3,4] &#x3D; 3 seconds<br>Time from [3,4] to [-1,0] &#x3D; 4 seconds<br>Total time &#x3D; 7 seconds</p><p>Example 2:<br>Input: points &#x3D; [[3,2],[-2,2]]<br>Output: 5</p><p>Constraints:<br>points.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>points[i].length &#x3D;&#x3D; 2<br>-1000 &lt;&#x3D; points[i][0], points[i][1] &lt;&#x3D; 1000</p><p>访问所有点的最小时间。</p><blockquote><p>平面上有 n 个点，点的位置用整数坐标表示 points[i] &#x3D; [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。<br>你需要按照下面的规则在平面上移动：<br>每一秒内，你可以：<br>沿水平方向移动一个单位长度，或者<br>沿竖直方向移动一个单位长度，或者<br>跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。<br>在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要我们求的是遍历 input 里所有的点所需要的<code>最小时间</code>，而且要按 input 数组里给的顺序。这道题问的<code>最小时间</code>有一点迷惑性，不是要我们求一个最优方案来得到这个<code>最小时间</code>，而是我们必须按照 input 数组里给的点的顺序来依次遍历，所以题目的<code>最小时间</code>其实是需要确保从某个点到下一个点的时间需要最小。</p><p>注意题目的定义，横坐标移动一格，纵坐标移动一格，以及对角线方向移动一格，代价都是 1，所以如果从某个点 A 移动到下一个点 B，这个最短距离是两者<code>横坐标的差值</code>和<code>纵坐标的差值</code>里较大的那个。在草稿纸上画一下就明白了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minTimeToVisitAllPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> points.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">int</span>[] prev = points[i - <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] cur = points[i];<br><span class="hljs-type">int</span> <span class="hljs-variable">xDiff</span> <span class="hljs-operator">=</span> Math.abs(cur[<span class="hljs-number">0</span>] - prev[<span class="hljs-number">0</span>]);<br><span class="hljs-type">int</span> <span class="hljs-variable">yDiff</span> <span class="hljs-operator">=</span> Math.abs(cur[<span class="hljs-number">1</span>] - prev[<span class="hljs-number">1</span>]);<br>res += Math.max(xDiff, yDiff);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1160. Find Words That Can Be Formed by Characters</title>
    <link href="/posts/439538790.html"/>
    <url>/posts/439538790.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array of strings words and a string chars.</p><p>A string is good if it can be formed by characters from chars (each character can only be used once).</p><p>Return the sum of lengths of all good strings in words.</p><p>Example 1:<br>Input: words &#x3D; [“cat”,”bt”,”hat”,”tree”], chars &#x3D; “atach”<br>Output: 6<br>Explanation: The strings that can be formed are “cat” and “hat” so the answer is 3 + 3 &#x3D; 6.</p><p>Example 2:<br>Input: words &#x3D; [“hello”,”world”,”leetcode”], chars &#x3D; “welldonehoneyr”<br>Output: 10<br>Explanation: The strings that can be formed are “hello” and “world” so the answer is 5 + 5 &#x3D; 10.</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; words[i].length, chars.length &lt;&#x3D; 100<br>words[i] and chars consist of lowercase English letters.</p><p>拼写单词。</p><blockquote><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。<br>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。<br>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。<br>返回词汇表 words 中你掌握的所有单词的 长度之和。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个长度为26的 int array 统计字母表中每个不同字母的出现次数，然后遍历词汇表中的每个单词，看看字母表中的字母是否足够组成当前的单词，如果能组成，则将当前单词的长度累加到结果。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn) - m 个单词，单词平均长度为 n<br>空间O(m) - 要将长度为26的 int array复制 m 次</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countCharacters</span><span class="hljs-params">(String[] words, String chars)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : chars.toCharArray()) &#123;<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            <span class="hljs-type">int</span>[] letters = map.clone();<br>            <span class="hljs-keyword">if</span> (helper(word, letters)) &#123;<br>                count += word.length();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String word, <span class="hljs-type">int</span>[] letters)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (letters[c - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                letters[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(word);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2661. First Completely Painted Row or Column</title>
    <link href="/posts/3543248498.html"/>
    <url>/posts/3543248498.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].</p><p>Go through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].</p><p>Return the smallest index i at which either a row or a column will be completely painted in mat.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg" alt="Example 1"><br>image explanation for example 1<br>Input: arr &#x3D; [1,3,4,2], mat &#x3D; [[1,4],[2,3]]<br>Output: 2<br>Explanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg" alt="Example 2"><br>image explanation for example 2<br>Input: arr &#x3D; [2,8,7,4,1,3,5,6,9], mat &#x3D; [[3,2,5],[1,4,6],[8,7,9]]<br>Output: 3<br>Explanation: The second column becomes fully painted at arr[3].</p><p>Constraints:<br>m &#x3D;&#x3D; mat.length<br>n &#x3D; mat[i].length<br>arr.length &#x3D;&#x3D; m * n<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>1 &lt;&#x3D; m * n &lt;&#x3D; 105<br>1 &lt;&#x3D; arr[i], mat[r][c] &lt;&#x3D; m * n<br>All the integers of arr are unique.<br>All the integers of mat are unique.</p><p>找出叠涂元素。</p><blockquote><p>给你一个下标从 0 开始的整数数组 arr 和一个 m x n 的整数 矩阵 mat 。arr 和 mat 都包含范围 [1，m * n] 内的 所有 整数。<br>从下标 0 开始遍历 arr 中的每个下标 i ，并将包含整数 arr[i] 的 mat 单元格涂色。<br>请你找出 arr 中在 mat 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 i 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我创建了三个hashmap，一个记录坐标值和坐标的关系<code>&lt;mat[i][j], num&gt;</code>，一个记录每一行 row 上已经被访问过的坐标的个数，一个记录每一列 col 上已经被访问过的坐标的个数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstCompleteIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span>[][] mat)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat[<span class="hljs-number">0</span>].length;<br>        HashMap&lt;Integer, <span class="hljs-type">int</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Integer, Integer&gt; rowMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Integer, Integer&gt; colMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> mat[i][j];<br>                map.put(num, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-type">int</span>[] pos = map.get(num);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> pos[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> pos[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (mat[x][y] == num) &#123;<br>                mat[x][y] = <span class="hljs-number">0</span>;<br>                rowMap.put(x, rowMap.getOrDefault(x, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                colMap.put(y, colMap.getOrDefault(y, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (rowMap.get(x) == n || colMap.get(y) == m) &#123;<br>                    <span class="hljs-keyword">return</span> i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1727. Largest Submatrix With Rearrangements</title>
    <link href="/posts/185281803.html"/>
    <url>/posts/185281803.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.</p><p>Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40536-pm.png" alt="Example 1"><br>Input: matrix &#x3D; [[0,0,1],[1,1,1],[1,0,1]]<br>Output: 4<br>Explanation: You can rearrange the columns as shown above.<br>The largest submatrix of 1s, in bold, has an area of 4.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40852-pm.png" alt="Example 1"><br>Input: matrix &#x3D; [[1,0,1,0,1]]<br>Output: 3<br>Explanation: You can rearrange the columns as shown above.<br>The largest submatrix of 1s, in bold, has an area of 3.</p><p>Example 3:<br>Input: matrix &#x3D; [[1,1,0],[1,0,1]]<br>Output: 2<br>Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m * n &lt;&#x3D; 105<br>matrix[i][j] is either 0 or 1.</p><p>重新排列后的最大子矩阵。</p><blockquote><p>给你一个二进制矩阵 matrix ，它的大小为 m x n ，你可以将 matrix 中的 列 按任意顺序重新排列。<br>请你返回最优方案下将 matrix 重新排列后，全是 1 的子矩阵面积。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>类似<a href="https://shurui91.github.io/posts/3456055979.html">85题</a>，我们先从上到下记录矩阵里每一列出现的连续的 1 的个数，比如第一个例子，matrix &#x3D; [[0,0,1],[1,1,1],[1,0,1]]，从上到下记录之后，矩阵变成<br>matrix &#x3D; [<br>[0,0,1],<br>[1,1,2],<br>[2,0,3]<br>]</p><p>然后我们对这个矩阵<code>逐行</code>扫描，看一下如果以当前行为结尾，能组成的最大子矩阵的面积是多少。这样一来这道题就跟85题很像了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestSubmatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    matrix[i][j] += matrix[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            Arrays.sort(matrix[i]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> matrix[i][j] * (n - j);<br>                res = Math.max(res, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">84. Largest Rectangle in Histogram<br>85. Maximal Rectangle<br>221. Maximal Square<br>1277. Count Square Submatrices with All Ones<br>1504. Count Submatrices With All Ones<br>1727. Largest Submatrix With Rearrangements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1685. Sum of Absolute Differences in a Sorted Array</title>
    <link href="/posts/4006849877.html"/>
    <url>/posts/4006849877.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums sorted in non-decreasing order.</p><p>Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.</p><p>In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 &lt;&#x3D; j &lt; nums.length and j !&#x3D; i (0-indexed).</p><p>Example 1:<br>Input: nums &#x3D; [2,3,5]<br>Output: [4,3,5]<br>Explanation: Assuming the arrays are 0-indexed, then<br>result[0] &#x3D; |2-2| + |2-3| + |2-5| &#x3D; 0 + 1 + 3 &#x3D; 4,<br>result[1] &#x3D; |3-2| + |3-3| + |3-5| &#x3D; 1 + 0 + 2 &#x3D; 3,<br>result[2] &#x3D; |5-2| + |5-3| + |5-5| &#x3D; 3 + 2 + 0 &#x3D; 5.</p><p>Example 2:<br>Input: nums &#x3D; [1,4,6,8,10]<br>Output: [24,15,13,15,21]</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums[i + 1] &lt;&#x3D; 104</p><p>有序数组中差绝对值之和。</p><blockquote><p>给你一个 非递减 有序整数数组 nums 。<br>请你建立并返回一个整数数组 result，它跟 nums 长度相同，且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。<br>换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，其中 0 &lt;&#x3D; j &lt; nums.length 且 j !&#x3D; i （下标从 0 开始）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我参考了<a href="https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/solutions/969535/java-python-3-prefix-sum-o-n-code-w-brief-explanation-and-analysis/?envType=daily-question&envId=2023-11-25">这个帖子</a>。注意题目给的 input 是一个非递减的数组，那么对于任何一个数字 <code>nums[i]</code> 而言，位于他左边的数字的累加和就很容易通过前缀和的方式计算出来，同理，位于 <code>nums[i]</code> 右边的数字也可以被求出来。那么当我们用 O(n) 的时间求出整个 input 数组的前缀和之后，我们就可以用 O(1) 的时间来求出每个位置上的数字与其他数字的差的绝对值之和。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getSumAbsoluteDifferences(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>presum[i + <span class="hljs-number">1</span>] = presum[i] + nums[i];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>res[i] = i * nums[i] - presum[i] + (presum[n] - presum[i] - (n - i) * nums[i]);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1424. Diagonal Traverse II</title>
    <link href="/posts/3710440472.html"/>
    <url>/posts/3710440472.html</url>
    
    <content type="html"><![CDATA[<p>Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/04/08/sample_1_1784.png" alt="Image"><br>Input: nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>Output: [1,4,2,7,5,3,8,6,9]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/04/08/sample_2_1784.png" alt="Image"><br>Input: nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]<br>Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i].length &lt;&#x3D; 105<br>1 &lt;&#x3D; sum(nums[i].length) &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i][j] &lt;&#x3D; 105</p><p>对角线遍历 II。</p><blockquote><p>给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题跟版本一类似，还是让我们以对角线分组输出矩阵中的值。我们可以把 <code>i + j</code> 当做 key 放入一个 hashmap，因为在同一条对角线上的元素的 <code>i + j</code> 的值是相同的，所以我们可以这样分组。注意因为我们对整个二维 list 是逐行扫描的所以当我们加入元素的时候，元素需要被加入他所在 hashmap 那条对角线的第一个，这样顺序才不会乱。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn) - output有这么多元素</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findDiagonalOrder(List&lt;List&lt;Integer&gt;&gt; nums) &#123;<br>        HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.get(i).size(); j++) &#123;<br>map.putIfAbsent(i + j, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>map.get(i + j).add(<span class="hljs-number">0</span>, nums.get(i).get(j));<br>count++;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[count];<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; key &lt;= map.size(); key++) &#123;<br><span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : map.get(key)) &#123;<br>res[index++] = val;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1630. Arithmetic Subarrays</title>
    <link href="/posts/1372923962.html"/>
    <url>/posts/1372923962.html</url>
    
    <content type="html"><![CDATA[<p>A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] &#x3D;&#x3D; s[1] - s[0] for all valid i.</p><p>For example, these are arithmetic sequences:<br>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9</p><p>The following sequence is not arithmetic:<br>1, 1, 2, 5, 7</p><p>You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.</p><p>Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], … , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.</p><p>Example 1:<br>Input: nums &#x3D; [4,6,5,9,3,7], l &#x3D; [0,0,2], r &#x3D; [2,3,5]<br>Output: [true,false,true]<br>Explanation:<br>In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.<br>In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.<br>In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.</p><p>Example 2:<br>Input: nums &#x3D; [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l &#x3D; [0,1,6,4,8,7], r &#x3D; [4,4,9,7,9,10]<br>Output: [false,true,false,false,true,true]</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>m &#x3D;&#x3D; l.length<br>m &#x3D;&#x3D; r.length<br>2 &lt;&#x3D; n &lt;&#x3D; 500<br>1 &lt;&#x3D; m &lt;&#x3D; 500<br>0 &lt;&#x3D; l[i] &lt; r[i] &lt; n<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><p>等差子数组。</p><blockquote>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] == s[1] - s[0] 都成立。<p>例如，下面这些都是 等差数列 ：<br>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9</p><p>下面的数列 不是等差数列 ：<br>1, 1, 2, 5, 7<br>给你一个由 n 个整数组成的数组 nums，和两个由 m 个整数组成的数组 l 和 r，后两个数组表示 m 组范围查询，其中第 i 个查询对应范围 [l[i], r[i]] 。所有数组的下标都是 从 0 开始 的。</p><p>返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], … , nums[r[i]] 可以 重新排列 形成 等差数列 ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题意，我们可以从 nums 中挑出范围在 [l, r] 的元素，对这部分元素排序，然后判断这部分元素是否为等差数列，如果是则往结果集放入True，否则放入False。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m^2 * logm) - 假设 [l, r] 这一段元素长度为 m，对这一段元素排序是O(mlogm)，判断这一段元素是否为等差数列最差可以到达O(m)，所以整体是O(m^2 * logm)<br>空间O(n) - output list</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title function_">checkArithmeticSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] l, <span class="hljs-type">int</span>[] r)</span> &#123;<br>        List&lt;Boolean&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> l.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> l[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> r[i];<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> start; j &lt;= end; j++) &#123;<br>                list.add(nums[j]);<br>            &#125;<br>            Collections.sort(list);<br>            <span class="hljs-keyword">if</span> (helper(list)) &#123;<br>                res.add(<span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(<span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) - list.get(i - <span class="hljs-number">1</span>) != list.get(i - <span class="hljs-number">1</span>) - list.get(i - <span class="hljs-number">2</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2563. Count the Number of Fair Pairs</title>
    <link href="/posts/1345396682.html"/>
    <url>/posts/1345396682.html</url>
    
    <content type="html"><![CDATA[<p>Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.</p><p>A pair (i, j) is fair if:<br>0 &lt;&#x3D; i &lt; j &lt; n, and<br>lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper</p><p>Example 1:<br>Input: nums &#x3D; [0,1,7,4,4,5], lower &#x3D; 3, upper &#x3D; 6<br>Output: 6<br>Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).</p><p>Example 2:<br>Input: nums &#x3D; [1,7,9,2,5], lower &#x3D; 11, upper &#x3D; 11<br>Output: 1<br>Explanation: There is a single fair pair: (2,3).</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; lower &lt;&#x3D; upper &lt;&#x3D; 109</p><p>统计公平数对的数目。</p><blockquote><p>给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。<br>如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：<br>0 &lt;&#x3D; i &lt; j &lt; n，且<br>lower &lt;&#x3D; nums[i] + nums[j] &lt;&#x3D; upper</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意我们要找的 i 和 j 满足<code>lower &lt;= nums[i] + nums[j] &lt;= upper</code> 的数对的个数，而且是闭区间。那么我们可以把这个条件改写为找到 i 和 j 满足 <code>nums[i] + nums[j] &lt;= upper</code> 的个数减去 <code>nums[i] + nums[j] &lt;= lower - 1</code>的个数。</p><p>这道题的思路跟 611 题，2824 题很像，可以先做这两题。做完这两题再做本题你就会发现我们还是可以对 input 数组排序，排序之后我们用一个 helper 函数分别去找 <code>nums[i] + nums[j] &lt;= upper</code> 的个数和<code>nums[i] + nums[j] &lt;= lower - 1</code>的个数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countFairPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> helper(nums, upper) - helper(nums, lower - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span> (sum &lt;= target) &#123;<br>                res += right - left;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">259. 3Sum Smaller<br>611. Valid Triangle Number<br>2563. Count the Number of Fair Pairs<br>2824. Count Pairs Whose Sum is Less than Target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2824. Count Pairs Whose Sum is Less than Target</title>
    <link href="/posts/1841508007.html"/>
    <url>/posts/1841508007.html</url>
    
    <content type="html"><![CDATA[<p>Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 &lt;&#x3D; i &lt; j &lt; n and nums[i] + nums[j] &lt; target.</p><p>Example 1:<br>Input: nums &#x3D; [-1,1,2,3,1], target &#x3D; 2<br>Output: 3<br>Explanation: There are 3 pairs of indices that satisfy the conditions in the statement:</p><ul><li>(0, 1) since 0 &lt; 1 and nums[0] + nums[1] &#x3D; 0 &lt; target</li><li>(0, 2) since 0 &lt; 2 and nums[0] + nums[2] &#x3D; 1 &lt; target </li><li>(0, 4) since 0 &lt; 4 and nums[0] + nums[4] &#x3D; 0 &lt; target<br>Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.</li></ul><p>Example 2:<br>Input: nums &#x3D; [-6,2,5,-2,-7,-1,3], target &#x3D; -2<br>Output: 10<br>Explanation: There are 10 pairs of indices that satisfy the conditions in the statement:</p><ul><li>(0, 1) since 0 &lt; 1 and nums[0] + nums[1] &#x3D; -4 &lt; target</li><li>(0, 3) since 0 &lt; 3 and nums[0] + nums[3] &#x3D; -8 &lt; target</li><li>(0, 4) since 0 &lt; 4 and nums[0] + nums[4] &#x3D; -13 &lt; target</li><li>(0, 5) since 0 &lt; 5 and nums[0] + nums[5] &#x3D; -7 &lt; target</li><li>(0, 6) since 0 &lt; 6 and nums[0] + nums[6] &#x3D; -3 &lt; target</li><li>(1, 4) since 1 &lt; 4 and nums[1] + nums[4] &#x3D; -5 &lt; target</li><li>(3, 4) since 3 &lt; 4 and nums[3] + nums[4] &#x3D; -9 &lt; target</li><li>(3, 5) since 3 &lt; 5 and nums[3] + nums[5] &#x3D; -3 &lt; target</li><li>(4, 5) since 4 &lt; 5 and nums[4] + nums[5] &#x3D; -8 &lt; target</li><li>(4, 6) since 4 &lt; 6 and nums[4] + nums[6] &#x3D; -4 &lt; target</li></ul><p>Constraints:<br>1 &lt;&#x3D; nums.length &#x3D;&#x3D; n &lt;&#x3D; 50<br>-50 &lt;&#x3D; nums[i], target &lt;&#x3D; 50</p><p>统计和小于目标的下标对数目。</p><blockquote><p>给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 target ，请你返回满足 0 &lt;&#x3D; i &lt; j &lt; n 且 nums[i] + nums[j] &lt; target 的下标对 (i, j) 的数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对 input list 排序，然后用类似611题那种找三角形有效边的方法找下标对。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - sort<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Collections.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (nums.get(left) + nums.get(right) &lt; target) &#123;<br>                res += right - left;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">259. 3Sum Smaller<br>611. Valid Triangle Number<br>2563. Count the Number of Fair Pairs<br>2824. Count Pairs Whose Sum is Less than Target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1410. HTML Entity Parser</title>
    <link href="/posts/2208021994.html"/>
    <url>/posts/2208021994.html</url>
    
    <content type="html"><![CDATA[<p>HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.</p><p>The special characters and their entities for HTML are:<br>Quotation Mark: the entity is &quot; and symbol character is “.<br>Single Quote Mark: the entity is &apos; and symbol character is ‘.<br>Ampersand: the entity is &amp; and symbol character is &amp;.<br>Greater Than Sign: the entity is &gt; and symbol character is &gt;.<br>Less Than Sign: the entity is &lt; and symbol character is &lt;.<br>Slash: the entity is &frasl; and symbol character is &#x2F;.<br>Given the input text string to the HTML parser, you have to implement the entity parser.</p><p>Return the text after replacing the entities by the special characters.</p><p>Example 1:<br>Input: text &#x3D; “&amp; is an HTML entity but &ambassador; is not.”<br>Output: “&amp; is an HTML entity but &ambassador; is not.”<br>Explanation: The parser will replace the &amp; entity by &amp;</p><p>Example 2:<br>Input: text &#x3D; “and I quote: &quot;…&quot;”<br>Output: “and I quote: &quot;…&quot;“</p><p>Constraints:<br>1 &lt;&#x3D; text.length &lt;&#x3D; 105<br>The string may contain any possible characters out of all the 256 ASCII characters.</p><p>HTML 实体解析器。</p><blockquote>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。<p>HTML 里这些特殊字符和它们对应的字符实体包括：<br>双引号：字符实体为 &quot; ，对应的字符是 “ 。<br>单引号：字符实体为 &apos; ，对应的字符是 ‘ 。<br>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。<br>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。<br>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。<br>斜线号：字符实体为 &frasl; ，对应的字符是 &#x2F; 。<br>给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用java自带的string.replace()函数做，记得把对<code>&amp;</code>符号的判断放在最后。否则如下这个 case 会有错。<br>Input &#x3D;&gt; “&amp;gt;”<br>如果不把 <code>&amp;amp;</code> 放到最后判断，这个 input 会被判定成 <code>&amp;gt;</code>，即<code>&gt;</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">entityParser</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-keyword">return</span> text.replace(<span class="hljs-string">&quot;&amp;quot;&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>).replace(<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>).replace(<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>).replace(<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>).replace(<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1647. Minimum Deletions to Make Character Frequencies Unique</title>
    <link href="/posts/3172184168.html"/>
    <url>/posts/3172184168.html</url>
    
    <content type="html"><![CDATA[<p>A string s is called good if there are no two different characters in s that have the same frequency.</p><p>Given a string s, return the minimum number of characters you need to delete to make s good.</p><p>The frequency of a character in a string is the number of times it appears in the string. For example, in the string “aab”, the frequency of ‘a’ is 2, while the frequency of ‘b’ is 1.</p><p>Example 1:<br>Input: s &#x3D; “aab”<br>Output: 0<br>Explanation: s is already good.</p><p>Example 2:<br>Input: s &#x3D; “aaabbbcc”<br>Output: 2<br>Explanation: You can delete two ‘b’s resulting in the good string “aaabcc”.<br>Another way it to delete one ‘b’ and one ‘c’ resulting in the good string “aaabbc”.</p><p>Example 3:<br>Input: s &#x3D; “ceabaacb”<br>Output: 2<br>Explanation: You can delete both ‘c’s resulting in the good string “eabaab”.<br>Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s contains only lowercase English letters.</p><p>字符频次唯一的最小删除次数。</p><blockquote><p>如果字符串 s 中 不存在 两个不同字符 频次 相同的情况，就称 s 是 优质字符串 。<br>给你一个字符串 s，返回使 s 成为 优质字符串 需要删除的 最小 字符数。<br>字符串中字符的 频次 是该字符在字符串中的出现次数。例如，在字符串 “aab” 中，’a’ 的频次是 2，而 ‘b’ 的频次是 1 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历数组的时候，用一个长度为26的 <code>int[] map</code> 数组记录 input 字符串中每个不同字母的出现次数。</p><p>接着我们再创建一个 hashset，去遍历这个长度为 26 的 int 数组，对于当前字母的出现次数 map[i]，如果他在 hashset 中出现过，那么他就不是一个 unique 的出现次数，那么我们就把这个出现次数减一，直到他变成一个 unique 的出现次数，再加入 hashset。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDeletions</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            map[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (map[i] &gt; <span class="hljs-number">0</span> &amp;&amp; set.contains(map[i])) &#123;<br>                map[i]--;<br>                count++;<br>            &#125;<br>            set.add(map[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2216. Minimum Deletions to Make Array Beautiful</title>
    <link href="/posts/1449407836.html"/>
    <url>/posts/1449407836.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums. The array nums is beautiful if:<br>nums.length is even.<br>nums[i] !&#x3D; nums[i + 1] for all i % 2 &#x3D;&#x3D; 0.<br>Note that an empty array is considered beautiful.</p><p>You can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created and all the elements to the left of the deleted element will remain unchanged.</p><p>Return the minimum number of elements to delete from nums to make it beautiful.</p><p>Example 1:<br>Input: nums &#x3D; [1,1,2,3,5]<br>Output: 1<br>Explanation: You can delete either nums[0] or nums[1] to make nums &#x3D; [1,2,3,5] which is beautiful. It can be proven you need at least 1 deletion to make nums beautiful.</p><p>Example 2:<br>Input: nums &#x3D; [1,1,2,2,3,3]<br>Output: 2<br>Explanation: You can delete nums[0] and nums[5] to make nums &#x3D; [1,2,2,3] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><p>美化数组的最少删除数。</p><blockquote><p>给你一个下标从 0 开始的整数数组 nums ，如果满足下述条件，则认为数组 nums 是一个 美丽数组 ：<br>nums.length 为偶数<br>对所有满足 i % 2 &#x3D;&#x3D; 0 的下标 i ，nums[i] !&#x3D; nums[i + 1] 均成立<br>注意，空数组同样认为是美丽数组。<br>你可以从 nums 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 不变 。<br>返回使 nums 变为美丽数组所需删除的 最少 元素数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我参考了<a href="https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/solutions/2530304/mei-hua-shu-zu-de-zui-shao-shan-chu-shu-qx4af/?envType=daily-question&envId=2023-11-21">这个帖子</a>。<br>对应题目的要求</p><ul><li><p>对所有满足 i % 2 &#x3D;&#x3D; 0 的下标 i ，nums[i] !&#x3D; nums[i + 1] 均成立<br>这里我需要一个 boolean 变量 <code>even</code> 记录目前遍历到的下标是奇数还是偶数。如果当前的 i 是奇数，可以不处理；如果当前的 i 是偶数且 nums[i] &#x3D;&#x3D; nums[i + 1]，我们一定要删除一个，但是无所谓删除 nums[i] 还是 nums[i + 1]，这里我们只要记录删除了一个，即 count++ 就好。因为无论删除哪个，之后的所有元素的下标都往左移动一步，比如 i + 2 变成 i + 1，i + 3 变成 i + 2 等等。<br>所以在遍历的过程中我们一直需要去追踪当前的 i 到底是奇数还是偶数以判断当 nums[i] &#x3D;&#x3D; nums[i + 1] 的时候要不要删除元素。</p></li><li><p>nums.length 为偶数<br>满足第一个条件之后我们最后判断数组长度 n - 要删除的元素个数 count 的奇偶性，如果是奇数，则再删除一个元素即可</p></li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDeletion</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>] &amp;&amp; even) &#123;<br>count++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>even = !even;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> ((n - count) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>count++;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2785. Sort Vowels in a String</title>
    <link href="/posts/3042380718.html"/>
    <url>/posts/3042380718.html</url>
    
    <content type="html"><![CDATA[<p>Given a 0-indexed string s, permute s to get a new string t such that:<br>All consonants remain in their original places. More formally, if there is an index i with 0 &lt;&#x3D; i &lt; s.length such that s[i] is a consonant, then t[i] &#x3D; s[i].<br>The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 &lt;&#x3D; i &lt; j &lt; s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].<br>Return the resulting string.</p><p>The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.</p><p>Example 1:<br>Input: s &#x3D; “lEetcOde”<br>Output: “lEOtcede”<br>Explanation: ‘E’, ‘O’, and ‘e’ are the vowels in s; ‘l’, ‘t’, ‘c’, and ‘d’ are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.</p><p>Example 2:<br>Input: s &#x3D; “lYmpH”<br>Output: “lYmpH”<br>Explanation: There are no vowels in s (all characters in s are consonants), so we return “lYmpH”.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists only of letters of the English alphabet in uppercase and lowercase.</p><p>将字符串中的元音字母排序。</p><blockquote><p>给你一个下标从 0 开始的字符串 s ，将 s 中的元素重新 排列 得到新的字符串 t ，它满足：<br>所有辅音字母都在原来的位置上。更正式的，如果满足 0 &lt;&#x3D; i &lt; s.length 的下标 i 处的 s[i] 是个辅音字母，那么 t[i] &#x3D; s[i] 。<br>元音字母都必须以他们的 ASCII 值按 非递减 顺序排列。更正式的，对于满足 0 &lt;&#x3D; i &lt; j &lt; s.length 的下标 i 和 j  ，如果 s[i] 和 s[j] 都是元音字母，那么 t[i] 的 ASCII 值不能大于 t[j] 的 ASCII 值。<br>请你返回结果字母串。<br>元音字母为 ‘a’ ，’e’ ，’i’ ，’o’ 和 ‘u’ ，它们可能是小写字母也可能是大写字母，辅音字母是除了这 5 个字母以外的所有字母。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路就是排序，但是这道题我们只对元音字母排序。具体做法我们需要遍历 input 字符串两次。第一次遍历，我们可以用一个 list 把所有的元音字母记下来，然后对这个 list 按字典序排序，这样 list 中字典序较大的字母在前。第二次遍历，如果遇到的 index 原本是一个辅音字母，则直接加入 stringbuilder，如果遇到的 index 原本是元音字母，则去 list 中拿一个字母出来放到这个位置上。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sortVowels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// 把元音字母的index记录下来</span><br>        List&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aeiouAEIOU&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (str.indexOf(letter) != -<span class="hljs-number">1</span>) &#123;<br>                list.add(letter);<br>            &#125;<br>        &#125;<br><br>        Collections.sort(list, (a, b) -&gt; a.compareTo(b));<br>        <span class="hljs-comment">// System.out.println(list);</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (str.indexOf(letter) == -<span class="hljs-number">1</span>) &#123;<br>                sb.append(letter);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(list.get(j++));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>counting sort</tag>
      
      <tag>sort</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</title>
    <link href="/posts/3321093076.html"/>
    <url>/posts/3321093076.html</url>
    
    <content type="html"><![CDATA[<p>There are n cities numbered from 0 to n-1. Given the array edges where edges[i] &#x3D; [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.</p><p>Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.</p><p>Notice that the distance of a path connecting cities i and j is equal to the sum of the edges’ weights along that path.</p><p>Example 1:<br>Input: n &#x3D; 4, edges &#x3D; [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold &#x3D; 4<br>Output: 3<br>Explanation: The figure above describes the graph.<br>The neighboring cities at a distanceThreshold &#x3D; 4 for each city are:<br>City 0 -&gt; [City 1, City 2]<br>City 1 -&gt; [City 0, City 2, City 3]<br>City 2 -&gt; [City 0, City 1, City 3]<br>City 3 -&gt; [City 1, City 2]<br>Cities 0 and 3 have 2 neighboring cities at a distanceThreshold &#x3D; 4, but we have to return city 3 since it has the greatest number.</p><p>Example 2:<br>Input: n &#x3D; 5, edges &#x3D; [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold &#x3D; 2<br>Output: 0<br>Explanation: The figure above describes the graph.<br>The neighboring cities at a distanceThreshold &#x3D; 2 for each city are:<br>City 0 -&gt; [City 1]<br>City 1 -&gt; [City 0, City 4]<br>City 2 -&gt; [City 3, City 4]<br>City 3 -&gt; [City 2, City 4]<br>City 4 -&gt; [City 1, City 2, City 3]<br>The city 0 has 1 neighboring city at a distanceThreshold &#x3D; 2.</p><p>Constraints:<br>2 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; edges.length &lt;&#x3D; n * (n - 1) &#x2F; 2<br>edges[i].length &#x3D;&#x3D; 3<br>0 &lt;&#x3D; fromi &lt; toi &lt; n<br>1 &lt;&#x3D; weighti, distanceThreshold &lt;&#x3D; 10^4<br>All pairs (fromi, toi) are distinct.</p><p>阈值距离内邻居最少的城市。</p><blockquote><p>有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] &#x3D; [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。<br>返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。<br>注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题有多种思路，这里我提供一个最经典的，Floyd算法。这个算法就是为了解决类似本题这种问题的。如果了解这个算法，你就可以直接套用代码解决，如果不了解，建议先学一下这个算法是怎么回事再来看这道题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^3)<br>空间O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><span class="hljs-comment">// 对角线上赋值为0，因为(i, i)的距离就是0</span><br><span class="hljs-comment">// 其他点对点的距离还未知</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>Arrays.fill(graph[i], Integer.MAX_VALUE);<br>graph[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 更新其他点对点的距离，注意是双向的</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">2</span>];<br>graph[u][v] = weight;<br>graph[v][u] = weight;<br>&#125;<br><br><span class="hljs-comment">// 使用Floyd-Warshall算法来计算最短路径</span><br><span class="hljs-comment">// k代表中间某个i和j都能到达的点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (graph[i][k] != Integer.MAX_VALUE &amp;&amp; graph[k][j] != Integer.MAX_VALUE) &#123;<br>graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">minCount</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (i != j &amp;&amp; graph[i][j] &lt;= distanceThreshold) &#123;<br>count++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (count &lt;= minCount) &#123;<br>minCount = count;<br>res = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>graph</tag>
      
      <tag>dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2849. Determine if a Cell Is Reachable at a Given Time</title>
    <link href="/posts/2034047703.html"/>
    <url>/posts/2034047703.html</url>
    
    <content type="html"><![CDATA[<p>You are given four integers sx, sy, fx, fy, and a non-negative integer t.</p><p>In an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.</p><p>Return true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.</p><p>A cell’s adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2023/08/05/example2.svg" alt="image"><br>Input: sx &#x3D; 2, sy &#x3D; 4, fx &#x3D; 7, fy &#x3D; 7, t &#x3D; 6<br>Output: true<br>Explanation: Starting at cell (2, 4), we can reach cell (7, 7) in exactly 6 seconds by going through the cells depicted in the picture above. </p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2023/08/05/example1.svg" alt="image"><br>Input: sx &#x3D; 3, sy &#x3D; 1, fx &#x3D; 7, fy &#x3D; 3, t &#x3D; 3<br>Output: false<br>Explanation: Starting at cell (3, 1), it takes at least 4 seconds to reach cell (7, 3) by going through the cells depicted in the picture above. Hence, we cannot reach cell (7, 3) at the third second.</p><p>Constraints:<br>1 &lt;&#x3D; sx, sy, fx, fy &lt;&#x3D; 109<br>0 &lt;&#x3D; t &lt;&#x3D; 109</p><p>判断能否在给定时间到达单元格。</p><blockquote><p>给你四个整数 sx、sy、fx、fy  以及一个 非负整数 t 。<br>在一个无限的二维网格中，你从单元格 (sx, sy) 开始出发。每一秒，你 必须 移动到任一与之前所处单元格相邻的单元格中。<br>如果你能在 恰好 t 秒 后到达单元格 (fx, fy) ，返回 true ；否则，返回  false 。<br>单元格的 相邻单元格 是指该单元格周围与其至少共享一个角的 8 个单元格。你可以多次访问同一个单元格。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题乍一看用 BFS 或者 DFS 做，但是注意题目规定相同单元格是可以访问多次的，如果 t 非常大，那么一定会超时。此时我们需要考虑别的做法。<br>正确的思路是判断起点到终点的<code>绝对距离</code>是否小于等于 t。注意这里<code>绝对距离</code>的意思是起点和终点的<code>横坐标的绝对值的差</code>和<code>纵坐标的绝对值的差</code>的较大值。如果这个<code>绝对距离</code>小于等于 t，说明在 t 时间内，一定能从起点走到终点，无非是需要在哪里绕圈圈以把时间消耗完。同时注意这道题允许我们往八个方向走，如果斜着往右上方走一步，其实是可以被拆解成往右一步和往上一步的，所以这里只要时间足够，步数总是可以被合法拆解的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReachableAtTime</span><span class="hljs-params">(<span class="hljs-type">int</span> sx, <span class="hljs-type">int</span> sy, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sx == fx &amp;&amp; sy == fy) &#123;<br>            <span class="hljs-keyword">return</span> t != <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(Math.abs(sx - fx), Math.abs(sy - fy)) &lt;= t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2609. Find the Longest Balanced Substring of a Binary String</title>
    <link href="/posts/3416691000.html"/>
    <url>/posts/3416691000.html</url>
    
    <content type="html"><![CDATA[<p>You are given a binary string s consisting only of zeroes and ones.</p><p>A substring of s is considered balanced if all zeroes are before ones and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.</p><p>Return the length of the longest balanced substring of s.</p><p>A substring is a contiguous sequence of characters within a string.</p><p>Example 1:<br>Input: s &#x3D; “01000111”<br>Output: 6<br>Explanation: The longest balanced substring is “000111”, which has length 6.</p><p>Example 2:<br>Input: s &#x3D; “00111”<br>Output: 4<br>Explanation: The longest balanced substring is “0011”, which has length 4. </p><p>Example 3:<br>Input: s &#x3D; “111”<br>Output: 0<br>Explanation: There is no balanced substring except the empty substring, so the answer is 0.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 50<br>‘0’ &lt;&#x3D; s[i] &lt;&#x3D; ‘1’</p><p>最长平衡子字符串。</p><blockquote><p>给你一个仅由 0 和 1 组成的二进制字符串 s 。<br>如果子字符串中 所有的 0 都在 1 之前 且其中 0 的数量等于 1 的数量，则认为 s 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。<br>返回  s 中最长的平衡子字符串长度。<br>子字符串是字符串中的一个连续字符序列。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我提供一个双指针的做法。对于每个 index (i, i + 1)，我们把位置 i 上的字母当做 0，把位置 i + 1 上的字母当做 1，看看往左往右能同时延伸多长。这个思路借鉴了从中间往两边找最长回文子串的思路。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2) - worst case<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheLongestBalancedSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                helper(s, i, i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">char</span> charLeft, <span class="hljs-type">char</span> charRight)</span> &#123;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == charLeft &amp;&amp; s.charAt(right) == charRight) &#123;<br>            left--;<br>            right++;<br>        &#125;<br>        res = Math.max(res, right - left - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2265. Count Nodes Equal to Average of Subtree</title>
    <link href="/posts/763011099.html"/>
    <url>/posts/763011099.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.</p><p>Note:<br>The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.<br>A subtree of root is a tree consisting of root and all of its descendants.</p><p>Example 1:<br>Input: root &#x3D; [4,8,5,0,1,null,6]<br>Output: 5<br>Explanation:<br>For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) &#x2F; 6 &#x3D; 24 &#x2F; 6 &#x3D; 4.<br>For the node with value 5: The average of its subtree is (5 + 6) &#x2F; 2 &#x3D; 11 &#x2F; 2 &#x3D; 5.<br>For the node with value 0: The average of its subtree is 0 &#x2F; 1 &#x3D; 0.<br>For the node with value 1: The average of its subtree is 1 &#x2F; 1 &#x3D; 1.<br>For the node with value 6: The average of its subtree is 6 &#x2F; 1 &#x3D; 6.</p><p>Example 2:<br>Input: root &#x3D; [1]<br>Output: 1<br>Explanation: For the node with value 1: The average of its subtree is 1 &#x2F; 1 &#x3D; 1.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 1000].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>统计值等于子树平均值的节点数。</p><blockquote><p>给你一棵二叉树的根节点 root ，找出并返回满足要求的节点数，要求节点的值等于其 子树 中值的 平均值 。<br>注意：<br>n 个元素的平均值可以由 n 个元素 求和 然后再除以 n ，并 向下舍入 到最近的整数。<br>root 的 子树 由 root 和它的所有后代组成。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是后序遍历。因为题目让我们找的节点需要让其子树满足一些条件，这也就意味着对于任何一个节点，他需要从他的子节点获取一些信息，由此我们想到大致的思路是后序遍历。</p><p>那么具体一点，子节点需要往父节点传什么信息呢？因为要求的是子树中所有节点 val 的平均值，那么我们需要收集所有子节点的 node.val 和子节点的个数这两个信息。这里我用一个数组保存。其他部分就比较直观了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">averageOfSubtree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">// [sum, count of nodes]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] helper(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        &#125;<br>        <span class="hljs-type">int</span>[] left = helper(root.left);<br>        <span class="hljs-type">int</span>[] right = helper(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>] + root.val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nodeCount</span> <span class="hljs-operator">=</span> left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (root.val == sum / nodeCount) &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; sum, nodeCount &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1535. Find the Winner of an Array Game</title>
    <link href="/posts/1740553697.html"/>
    <url>/posts/1740553697.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array arr of distinct integers and an integer k.</p><p>A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.</p><p>Return the integer which will win the game.</p><p>It is guaranteed that there will be a winner of the game.</p><p>Example 1:<br>Input: arr &#x3D; [2,1,3,5,4,6,7], k &#x3D; 2<br>Output: 5<br>Explanation: Let’s see the rounds of the game:<br>Round |       arr       | winner | win_count<br>  1   | [2,1,3,5,4,6,7] | 2      | 1<br>  2   | [2,3,5,4,6,7,1] | 3      | 1<br>  3   | [3,5,4,6,7,1,2] | 5      | 1<br>  4   | [5,4,6,7,1,2,3] | 5      | 2<br>So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.</p><p>Example 2:<br>Input: arr &#x3D; [3,2,1], k &#x3D; 10<br>Output: 3<br>Explanation: 3 will win the first 10 rounds consecutively.</p><p>Constraints:<br>2 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 106<br>arr contains distinct integers.<br>1 &lt;&#x3D; k &lt;&#x3D; 109</p><p>按符号重排数组。</p><blockquote><p>给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。<br>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。<br>返回赢得比赛的整数。<br>题目数据 保证 游戏存在赢家。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是模拟。这里有两个 corner case 需要处理，如果 input 数组只有两个数字，那么赢家就是这两个值中间较大的那一个。另一个 case 是如果遍历一次之后，整个数组中未出现赢得 k 次游戏的数字，那么全局最大的数字是赢家，因为这个数字有可能排在 input 数组很后面的位置导致 index 比他大的数字的个数不足 k 个。</p><p>一般的情况是，我们比较了头两个元素之后，从第三个元素开始，就只和第一个元素（赢家）比较并记录连续赢得比赛的回合数，如果有任何一个数字连续赢得比赛的回合数 &#x3D;&#x3D; k 则返回这个数字。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWinner</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> Math.max(arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> prev;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> prev;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-keyword">if</span> (prev &gt; cur) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                prev = cur;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == k) &#123;<br>                <span class="hljs-keyword">return</span> prev;<br>            &#125;<br>            max = Math.max(max, arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2149. Rearrange Array Elements by Sign</title>
    <link href="/posts/2455330241.html"/>
    <url>/posts/2455330241.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.</p><p>You should rearrange the elements of nums such that the modified array follows the given conditions:<br>Every consecutive pair of integers have opposite signs.<br>For all integers with the same sign, the order in which they were present in nums is preserved.<br>The rearranged array begins with a positive integer.<br>Return the modified array after rearranging the elements to satisfy the aforementioned conditions.</p><p>Example 1:<br>Input: nums &#x3D; [3,1,-2,-5,2,-4]<br>Output: [3,-2,1,-5,2,-4]<br>Explanation:<br>The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].<br>The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].<br>Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  </p><p>Example 2:<br>Input: nums &#x3D; [-1,1]<br>Output: [1,-1]<br>Explanation:<br>1 is the only positive integer and -1 the only negative integer in nums.<br>So nums is rearranged to [1,-1].</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 105<br>nums.length is even<br>1 &lt;&#x3D; |nums[i]| &lt;&#x3D; 105<br>nums consists of equal number of positive and negative integers.</p><p>按符号重排数组。</p><blockquote>给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。你需要 重排 nums 中的元素，使修改后的数组满足下述条件：1. 任意 连续 的两个整数 符号相反2. 对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。3. 重排后数组以正整数开头。重排元素满足上述条件后，返回修改后的数组。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是双指针。这里我们需要两个指针 a 和 b 分别去找 input 数组里出现的正数和负数，然后按照规则放入结果里。因为最后要求输出的数组要求正负数交替出现且先出现正数，所以代码里就可以直接先找正数，再找负数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] rearrangeArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-keyword">while</span> (p &lt; nums.length) &#123;<br>            <span class="hljs-keyword">while</span> (nums[a] &lt; <span class="hljs-number">0</span>) &#123;<br>                a++;<br>            &#125;<br>            res[p++] = nums[a++];<br>            <span class="hljs-keyword">while</span> (nums[b] &gt; <span class="hljs-number">0</span>) &#123;<br>                b++;<br>            &#125;<br>            res[p++] = nums[b++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2558. Take Gifts From the Richest Pile</title>
    <link href="/posts/3117302007.html"/>
    <url>/posts/3117302007.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:</p><p>Choose the pile with the maximum number of gifts.<br>If there is more than one pile with the maximum number of gifts, choose any.<br>Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.<br>Return the number of gifts remaining after k seconds.</p><p>Example 1:<br>Input: gifts &#x3D; [25,64,9,4,100], k &#x3D; 4<br>Output: 29<br>Explanation:<br>The gifts are taken in the following way:</p><ul><li>In the first second, the last pile is chosen and 10 gifts are left behind.</li><li>Then the second pile is chosen and 8 gifts are left behind.</li><li>After that the first pile is chosen and 5 gifts are left behind.</li><li>Finally, the last pile is chosen again and 3 gifts are left behind.<br>The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.</li></ul><p>Example 2:<br>Input: gifts &#x3D; [1,1,1,1], k &#x3D; 4<br>Output: 4<br>Explanation:<br>In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile.<br>That is, you can’t take any pile with you.<br>So, the total gifts remaining are 4.</p><p>Constraints:<br>1 &lt;&#x3D; gifts.length &lt;&#x3D; 103<br>1 &lt;&#x3D; gifts[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; k &lt;&#x3D; 103</p><p>Follow-up: Can you come up with an algorithm that is less than <code>O(n2)</code> time complexity?</p><p>从数量最多的堆取走礼物。</p><blockquote><p>给你一个整数数组 gifts ，表示各堆礼物的数量。每一秒，你需要执行以下操作：<br>选择礼物数量最多的那一堆。<br>如果不止一堆都符合礼物数量最多，从中选择任一堆即可。<br>选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。<br>返回在 k 秒后剩下的礼物数量。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是最大堆。首先创建一个最大堆将每一堆礼物放进去，放进去的同时累加一下礼物的个数，记为 res。<br>接着开始从最大堆中弹出元素 top。弹出堆顶元素的时候记得要从 res 中减去 top 的平方根，然后将剩余的部分再放回最大堆，同时记得 k–。<br>注意如果遇到一堆礼物的个数 &#x3D; 1的时候，说明这一堆礼物无法再分割了，此时即可跳出 while 循环返回 res。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pickGifts</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gifts, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> g : gifts) &#123;<br>            queue.offer(g);<br>            res += g;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">kk</span> <span class="hljs-operator">=</span> k;<br>        <span class="hljs-keyword">while</span> (kk &gt; <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (top == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">taken</span> <span class="hljs-operator">=</span> top - (<span class="hljs-type">int</span>) Math.sqrt(top);<br>            res -= taken;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rest</span> <span class="hljs-operator">=</span> top - taken;<br>            queue.offer(rest);<br>            kk--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>heap</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2530. Maximal Score After Applying K Operations</title>
    <link href="/posts/417783291.html"/>
    <url>/posts/417783291.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.</p><p>In one operation:<br>choose an index i such that 0 &lt;&#x3D; i &lt; nums.length,<br>increase your score by nums[i], and<br>replace nums[i] with ceil(nums[i] &#x2F; 3).<br>Return the maximum possible score you can attain after applying exactly k operations.</p><p>The ceiling function ceil(val) is the least integer greater than or equal to val.</p><p>Example 1:<br>Input: nums &#x3D; [10,10,10,10,10], k &#x3D; 5<br>Output: 50<br>Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 &#x3D; 50.</p><p>Example 2:<br>Input: nums &#x3D; [1,10,3,3,3], k &#x3D; 3<br>Output: 17<br>Explanation: You can do the following operations:<br>Operation 1: Select i &#x3D; 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.<br>Operation 2: Select i &#x3D; 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.<br>Operation 3: Select i &#x3D; 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.<br>The final score is 10 + 4 + 3 &#x3D; 17.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length, k &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>执行 K 次操作后的最大分数。</p><blockquote>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。<p>在一步 操作 中：<br>选出一个满足 0 &lt;&#x3D; i &lt; nums.length 的下标 i ，<br>将你的 分数 增加 nums[i] ，并且<br>将 nums[i] 替换为 ceil(nums[i] &#x2F; 3) 。<br>返回在 恰好 执行 k 次操作后，你可能获得的最大分数。</p><p>向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心，具体做法会用到一个最大堆。初始化的时候将 input 数组里的所有元素都放入最大堆，然后每次弹出堆顶元素 top，将这个元素的值累加到结果 res，然后再把 top 除以 3 再放回最大堆，如此一套流程执行 k 次之后停止。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - 也可以是O(nlogk)，取决于你怎么创建这个最大堆<br>空间O(n) - 也可以是O(k)，取决于你怎么创建这个最大堆</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxKelements</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Double&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; Double.compare(b, a));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            queue.offer((<span class="hljs-type">double</span>) num);<br>        &#125;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> queue.poll();<br>            res += top;<br>            queue.offer(Math.ceil(top / <span class="hljs-number">3</span>));<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1921. Eliminate Maximum Number of Monsters</title>
    <link href="/posts/1880376029.html"/>
    <url>/posts/1880376029.html</url>
    
    <content type="html"><![CDATA[<p>You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.</p><p>The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.</p><p>You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.The weapon is fully charged at the very start.</p><p>You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.</p><p>Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.</p><p>Example 1:<br>Input: dist &#x3D; [1,3,4], speed &#x3D; [1,1,1]<br>Output: 3<br>Explanation:<br>In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.<br>After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.<br>After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.<br>All 3 monsters can be eliminated.</p><p>Example 2:<br>Input: dist &#x3D; [1,1,2,3], speed &#x3D; [1,1,1,1]<br>Output: 1<br>Explanation:<br>In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.<br>After a minute, the distances of the monsters are [X,0,1,2], so you lose.<br>You can only eliminate 1 monster.</p><p>Example 3:<br>Input: dist &#x3D; [3,2,4], speed &#x3D; [5,3,2]<br>Output: 1<br>Explanation:<br>In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.<br>After a minute, the distances of the monsters are [X,0,2], so you lose.<br>You can only eliminate 1 monster.</p><p>Constraints:<br>n &#x3D;&#x3D; dist.length &#x3D;&#x3D; speed.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; dist[i], speed[i] &lt;&#x3D; 105</p><p>消灭怪物的最大数量。</p><blockquote><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 0 开始 且长度为 n 的整数数组 dist ，其中 dist[i] 是第 i 个怪物与城市的 初始距离（单位：米）。<br>怪物以 恒定 的速度走向城市。给你一个长度为 n 的整数数组 speed 表示每个怪物的速度，其中 speed[i] 是第 i 个怪物的速度（单位：米&#x2F;分）。<br>怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。<br>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。<br>返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心，具体做法是排序。因为有了怪物的距离和速度，那么我们可以得到一个 <code>double[] time</code> 数组，记录每个怪物到达城市所需要的时间。这里注意需要用 double 型记录。time 数组创建好了之后我们将他排序，时间较早的排在前面。然后遍历 time 数组，我们用下标模拟时间的流逝，如果 time[i] &gt; i （下标），说明我们可以在这个怪物未到达之间就消灭他；反之就不行，就可以立即 break 了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eliminateMaximum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dist, <span class="hljs-type">int</span>[] speed)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> dist.length;<br>        <span class="hljs-type">double</span>[] time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>time[i] = (<span class="hljs-type">double</span>) dist[i] / speed[i];<br>&#125;<br><br>Arrays.sort(time);<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (i &lt; time[i]) &#123;<br>count++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count == n ? n : count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2337. Move Pieces to Obtain a String</title>
    <link href="/posts/2721484664.html"/>
    <url>/posts/2721484664.html</url>
    
    <content type="html"><![CDATA[<p>You are given two strings start and target, both of length n. Each string consists only of the characters ‘L’, ‘R’, and ‘_’ where:</p><p>The characters ‘L’ and ‘R’ represent pieces, where a piece ‘L’ can move to the left only if there is a blank space directly to its left, and a piece ‘R’ can move to the right only if there is a blank space directly to its right.<br>The character ‘_’ represents a blank space that can be occupied by any of the ‘L’ or ‘R’ pieces.<br>Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.</p><p>Example 1:<br>Input: start &#x3D; “<em>L__R__R</em>“, target &#x3D; “L______RR”<br>Output: true<br>Explanation: We can obtain the string target from start by doing the following moves:</p><ul><li>Move the first piece one step to the left, start becomes equal to “L___R__R_”.</li><li>Move the last piece one step to the right, start becomes equal to “L___R___R”.</li><li>Move the second piece three steps to the right, start becomes equal to “L______RR”.<br>Since it is possible to get the string target from start, we return true.</li></ul><p>Example 2:<br>Input: start &#x3D; “R_L_”, target &#x3D; “__LR”<br>Output: false<br>Explanation: The ‘R’ piece in the string start can move one step to the right to obtain “<em>RL</em>“.<br>After that, no pieces can move anymore, so it is impossible to obtain the string target from start.</p><p>Example 3:<br>Input: start &#x3D; “<em>R”, target &#x3D; “R</em>“<br>Output: false<br>Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.</p><p>Constraints:<br>n &#x3D;&#x3D; start.length &#x3D;&#x3D; target.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>start and target consist of the characters ‘L’, ‘R’, and ‘_’.</p><p>移动片段得到字符串。</p><blockquote>给你两个字符串 start 和 target ，长度均为 n 。每个字符串 仅 由字符 'L'、'R' 和 '_' 组成，其中：<p>字符 ‘L’ 和 ‘R’ 表示片段，其中片段 ‘L’ 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 ‘R’ 只有在其右侧直接存在一个 空位 时才能向 右 移动。</p><p>字符 ‘_’ 表示可以被 任意 ‘L’ 或 ‘R’ 片段占据的空位。</p><p>如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是双指针。</p><p>注意 L 只能往左移动，R 只能往右移动，而且不能让任何的 L 跨过 R，也不能让任何的 R 跨过 L，所以本质上如果去掉所有的下划线，start 和 target 最后剩下的部分应该是一样的。所以这里我们用两个指针 i, j 分别指向 start 和 target，如果遇到下划线就跳过，如果两边都不是下划线，则比较两边的字母是否一样，如果不一样就返回 false；还有一种情形是两个指针都指向了字母，但是因为题目只允许 start 中 L 左移，R 右移，那么如下这两种情形就需要返回 false</p><p>如果 start 中遇到的 L 的下标比 target 中遇到的 L 的下标小，那么这个 L 是不能通过左移移动到 target 中对应位置的，所以返回 false<br>如果 start 中遇到的 R 的下标比 target 中遇到的 R 的下标大，那么这个 R 是不能通过右移移动到 target 中对应位置的，所以返回 false</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canChange</span><span class="hljs-params">(String start, String target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> target.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n || j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;_&#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; target.charAt(j) == <span class="hljs-string">&#x27;_&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == n || j == n) &#123;<br>                <span class="hljs-keyword">return</span> i == n &amp;&amp; j == n;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) != target.charAt(j)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; i &lt; j) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) == <span class="hljs-string">&#x27;R&#x27;</span> &amp;&amp; i &gt; j) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == n &amp;&amp; j == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1870. Minimum Speed to Arrive on Time</title>
    <link href="/posts/2192711178.html"/>
    <url>/posts/2192711178.html</url>
    
    <content type="html"><![CDATA[<p>You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.</p><p>Each train can only depart at an integer hour, so you may need to wait in between each train ride.</p><p>For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.<br>Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.</p><p>Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.</p><p>Example 1:<br>Input: dist &#x3D; [1,3,2], hour &#x3D; 6<br>Output: 1<br>Explanation: At speed 1:</p><ul><li>The first train ride takes 1&#x2F;1 &#x3D; 1 hour.</li><li>Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3&#x2F;1 &#x3D; 3 hours.</li><li>Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2&#x2F;1 &#x3D; 2 hours.</li><li>You will arrive at exactly the 6 hour mark.</li></ul><p>Example 2:<br>Input: dist &#x3D; [1,3,2], hour &#x3D; 2.7<br>Output: 3<br>Explanation: At speed 3:</p><ul><li>The first train ride takes 1&#x2F;3 &#x3D; 0.33333 hours.</li><li>Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3&#x2F;3 &#x3D; 1 hour.</li><li>Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2&#x2F;3 &#x3D; 0.66667 hours.</li><li>You will arrive at the 2.66667 hour mark.</li></ul><p>Example 3:<br>Input: dist &#x3D; [1,3,2], hour &#x3D; 1.9<br>Output: -1<br>Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.</p><p>Constraints:<br>n &#x3D;&#x3D; dist.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; dist[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; hour &lt;&#x3D; 109<br>There will be at most two digits after the decimal point in hour.</p><p>准时到达的列车最小时速。</p><blockquote>给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p><p>例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。<br>返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。</p><p>生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time">https://leetcode.cn/problems/minimum-speed-to-arrive-on-time</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分，而且是在答案上二分。题目最后让我们求的就是最小的时速，那么我们就以时速的上界和下界作为左右边界来进行二分。</p><p>在答案上二分的经典题可以参考 875 题，但是这道题有一个坑，就是我们在得到某一个速度，然后去计算用时的时候，for 循环不能直接走到 n，而要走到 n - 1。因为对于 dist 数组里的最后一个元素来说，因为他无需再等下一班车，所以对于最后一趟列车的用时，就是距离 &#x2F; 速度的结果，无需再进位了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n * logn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSpeedOnTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dist, <span class="hljs-type">double</span> hour)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> helper(dist, mid);<br>            <span class="hljs-keyword">if</span> (time &lt;= hour) &#123;<br>                res = mid;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dist, <span class="hljs-type">int</span> speed)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> dist.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            res += Math.ceil((<span class="hljs-type">double</span>) dist[i] / speed);<br>        &#125;<br>        res += (<span class="hljs-type">double</span>) dist[n - <span class="hljs-number">1</span>] / speed;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">410. Split Array Largest Sum<br>774. Minimize Max Distance to Gas Station<br>875. Koko Eating Bananas<br>1011. Capacity To Ship Packages In N Days<br>1060. Missing Element in Sorted Array<br>1231. Divide Chocolate<br>1283. Find the Smallest Divisor Given a Threshold<br>1482. Minimum Number of Days to Make m Bouquets<br>1539. Kth Missing Positive Number<br>1870. Minimum Speed to Arrive on Time<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2486. Append Characters to String to Make Subsequence</title>
    <link href="/posts/4051463354.html"/>
    <url>/posts/4051463354.html</url>
    
    <content type="html"><![CDATA[<p>You are given two strings s and t consisting of only lowercase English letters.</p><p>Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.</p><p>A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</p><p>Example 1:<br>Input: s &#x3D; “coaching”, t &#x3D; “coding”<br>Output: 4<br>Explanation: Append the characters “ding” to the end of s so that s &#x3D; “coachingding”.<br>Now, t is a subsequence of s (“coachingding”).<br>It can be shown that appending any 3 characters to the end of s will never make t a subsequence.</p><p>Example 2:<br>Input: s &#x3D; “abcde”, t &#x3D; “a”<br>Output: 0<br>Explanation: t is already a subsequence of s (“abcde”).</p><p>Example 3:<br>Input: s &#x3D; “z”, t &#x3D; “abcde”<br>Output: 5<br>Explanation: Append the characters “abcde” to the end of s so that s &#x3D; “zabcde”.<br>Now, t is a subsequence of s (“zabcde”).<br>It can be shown that appending any 4 characters to the end of s will never make t a subsequence.</p><p>Constraints:<br>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 105<br>s and t consist only of lowercase English letters.</p><p>追加字符以获得子序列。</p><blockquote>给你两个仅由小写英文字母组成的字符串 s 和 t 。<p>现在需要通过向 s 末尾追加字符的方式使 t 变成 s 的一个 子序列 ，返回需要追加的最少字符数。</p><p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence">https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是双指针。这是判断子序列的基本题，我们用两个指针 i, j 分别指向 s 和 t （长度分别为 m 和 n）并同时开始遍历。如果 t 先遍历完，说明 t 本身就是 s 的子序列；如果 s 遍历完之后发现 t 还未遍历完，那么 s 需要补足的字符个数 &#x3D; n - j，即 t 中还未遍历到的字符个数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m) - s 的长度<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">appendCharacters</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;<br>                j++;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2461. Maximum Sum of Distinct Subarrays With Length K</title>
    <link href="/posts/1885109088.html"/>
    <url>/posts/1885109088.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:<br>The length of the subarray is k, and<br>All the elements of the subarray are distinct.<br>Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.</p><p>A subarray is a contiguous non-empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,5,4,2,9,9,9], k &#x3D; 3<br>Output: 15<br>Explanation: The subarrays of nums with length 3 are:</p><ul><li>[1,5,4] which meets the requirements and has a sum of 10.</li><li>[5,4,2] which meets the requirements and has a sum of 11.</li><li>[4,2,9] which meets the requirements and has a sum of 15.</li><li>[2,9,9] which does not meet the requirements because the element 9 is repeated.</li><li>[9,9,9] which does not meet the requirements because the element 9 is repeated.<br>We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions</li></ul><p>Example 2:<br>Input: nums &#x3D; [4,4,4], k &#x3D; 3<br>Output: 0<br>Explanation: The subarrays of nums with length 3 are:</p><ul><li>[4,4,4] which does not meet the requirements because the element 4 is repeated.<br>We return 0 because no subarrays meet the conditions.</li></ul><p>Constraints:<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><p>长度为 K 子数组中的最大和。</p><blockquote>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：<p>子数组的长度是 k，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k">https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口。这一题是滑动窗口，窗口尺寸固定为 K。这里我用 hashmap 记录每个不同元素及其出现次数。如果你是用 for 循环来维护窗口的尺寸的话（意思是右指针往前走一步，左指针立马也往前走一步），只能用 hashmap 做。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            sum += nums[i];<br>            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">if</span> (map.size() == k) &#123;<br>            res = sum;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            map.put(nums[i], map.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            sum += nums[i];<br>            sum -= nums[i - k];<br>            map.put(nums[i - k], map.get(nums[i - k]) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (map.get(nums[i - k]) == <span class="hljs-number">0</span>) &#123;<br>                map.remove(nums[i - k]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.size() == k) &#123;<br>                res = Math.max(res, sum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2024. Maximize the Confusion of an Exam</title>
    <link href="/posts/2026269232.html"/>
    <url>/posts/2026269232.html</url>
    
    <content type="html"><![CDATA[<p>A teacher is writing a test with n true&#x2F;false questions, with ‘T’ denoting true and ‘F’ denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).</p><p>You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:</p><p>Change the answer key for any question to ‘T’ or ‘F’ (i.e., set answerKey[i] to ‘T’ or ‘F’).<br>Return the maximum number of consecutive ‘T’s or ‘F’s in the answer key after performing the operation at most k times.</p><p>Example 1:<br>Input: answerKey &#x3D; “TTFF”, k &#x3D; 2<br>Output: 4<br>Explanation: We can replace both the ‘F’s with ‘T’s to make answerKey &#x3D; “TTTT”.<br>There are four consecutive ‘T’s.</p><p>Example 2:<br>Input: answerKey &#x3D; “TFFT”, k &#x3D; 1<br>Output: 3<br>Explanation: We can replace the first ‘T’ with an ‘F’ to make answerKey &#x3D; “FFFT”.<br>Alternatively, we can replace the second ‘T’ with an ‘F’ to make answerKey &#x3D; “TFFF”.<br>In both cases, there are three consecutive ‘F’s.</p><p>Example 3:<br>Input: answerKey &#x3D; “TTFTTFTT”, k &#x3D; 1<br>Output: 5<br>Explanation: We can replace the first ‘F’ to make answerKey &#x3D; “TTTTTFTT”<br>Alternatively, we can replace the second ‘F’ to make answerKey &#x3D; “TTFTTTTT”.<br>In both cases, there are five consecutive ‘T’s.</p><p>Constraints:<br>n &#x3D;&#x3D; answerKey.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104<br>answerKey[i] is either ‘T’ or ‘F’<br>1 &lt;&#x3D; k &lt;&#x3D; n</p><p>考试的最大困扰度。</p><blockquote><p>一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 ‘T’ 表示）或者 false （用 ‘F’ 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p><p>给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：</p><p>每次操作中，将问题的正确答案改为 ‘T’ 或者 ‘F’ （也就是将 answerKey[i] 改为 ‘T’ 或者 ‘F’ ）。<br>请你返回在不超过 k 次操作的情况下，最大 连续 ‘T’ 或者 ‘F’ 的数目。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam">https://leetcode.cn/problems/maximize-the-confusion-of-an-exam</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口。题意是老师想把题目的答案出成一串 TRUE 或者一串 FALSE 让学生增加对自己的答案的不确定性，同时给了一个变量 K，允许你修改原答案里的 K 个答案以得到一串全局最长的 T 或者 F。这道题转译一下就是在 input 字符串里面找一段最长的 T 或者最长的 F，其中允许你修改其中的 K 处字母，请你求全局最长的连续子串的长度。这道题我们需要用两次滑动窗口，一次看最长的由 T 组成的子串的长度，一次看最长的由 F 组成的子串的长度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxConsecutiveAnswers</span><span class="hljs-params">(String answerKey, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfTrue</span> <span class="hljs-operator">=</span> helper(answerKey, k, <span class="hljs-string">&#x27;T&#x27;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numOfFalse</span> <span class="hljs-operator">=</span> helper(answerKey, k, <span class="hljs-string">&#x27;F&#x27;</span>);<br>        <span class="hljs-keyword">return</span> Math.max(numOfTrue, numOfFalse);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">char</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(end) != target) &#123;<br>                k--;<br>            &#125;<br>            end++;<br>            <span class="hljs-keyword">while</span> (k &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(start) != target) &#123;<br>                    k++;<br>                &#125;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1071. Greatest Common Divisor of Strings</title>
    <link href="/posts/3566414224.html"/>
    <url>/posts/3566414224.html</url>
    
    <content type="html"><![CDATA[<p>For two strings s and t, we say “t divides s” if and only if s &#x3D; t + … + t (i.e., t is concatenated with itself one or more times).</p><p>Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.</p><p>Example 1:<br>Input: str1 &#x3D; “ABCABC”, str2 &#x3D; “ABC”<br>Output: “ABC”</p><p>Example 2:<br>Input: str1 &#x3D; “ABABAB”, str2 &#x3D; “ABAB”<br>Output: “AB”</p><p>Example 3:<br>Input: str1 &#x3D; “LEET”, str2 &#x3D; “CODE”<br>Output: “”</p><p>Constraints:<br>1 &lt;&#x3D; str1.length, str2.length &lt;&#x3D; 1000<br>str1 and str2 consist of English uppercase letters.</p><p>字符串的最大公因子。</p><blockquote><p>对于字符串 s 和 t，只有在 s &#x3D; t + … + t（t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。<br>给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 x 能除尽 str2 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings">https://leetcode.cn/problems/greatest-common-divisor-of-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道数学题，说是求字符串的最大公因子，其实是需要先求出两个字符串长度的最大公约数然后得到子串。其中求最大公约数 gcd 的函数需要背下来。</p><p>注意题目的 corner case，如果两个字符串 A + B !&#x3D; B + A 的话，说明两者是没有公共子串的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(log min(a, b))<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">gcdOfStrings</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (!str1.concat(str2).equals(str2.concat(str1))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">gcdLength</span> <span class="hljs-operator">=</span> helper(str1.length(), str2.length());<br>        <span class="hljs-keyword">return</span> str1.substring(<span class="hljs-number">0</span>, gcdLength);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> b;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a == b) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            <span class="hljs-keyword">return</span> helper(a % b, b);<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(b, a % b);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// gcd, 辗转相除法</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>gcd</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2090. K Radius Subarray Averages</title>
    <link href="/posts/61639368.html"/>
    <url>/posts/61639368.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array nums of n integers, and an integer k.</p><p>The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.</p><p>Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.</p><p>The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.</p><p>For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) &#x2F; 4 &#x3D; 11 &#x2F; 4 &#x3D; 2.75, which truncates to 2.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/11/07/eg1.png" alt="Example 1"><br>Input: nums &#x3D; [7,4,3,9,1,8,5,2,6], k &#x3D; 3<br>Output: [-1,-1,-1,5,4,4,-1,-1,-1]<br>Explanation:</p><ul><li>avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.</li><li>The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 &#x3D; 37.<br>Using integer division, avg[3] &#x3D; 37 &#x2F; 7 &#x3D; 5.</li><li>For the subarray centered at index 4, avg[4] &#x3D; (4 + 3 + 9 + 1 + 8 + 5 + 2) &#x2F; 7 &#x3D; 4.</li><li>For the subarray centered at index 5, avg[5] &#x3D; (3 + 9 + 1 + 8 + 5 + 2 + 6) &#x2F; 7 &#x3D; 4.</li><li>avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.</li></ul><p>Example 2:<br>Input: nums &#x3D; [100000], k &#x3D; 0<br>Output: [100000]<br>Explanation:</p><ul><li>The sum of the subarray centered at index 0 with radius 0 is: 100000.<br>avg[0] &#x3D; 100000 &#x2F; 1 &#x3D; 100000.</li></ul><p>Example 3:<br>Input: nums &#x3D; [8], k &#x3D; 100000<br>Output: [-1]<br>Explanation: </p><ul><li>avg[0] is -1 because there are less than k elements before and after index 0.</li></ul><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i], k &lt;&#x3D; 105</p><p>半径为 k 的子数组平均值。</p><blockquote>给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。<p>半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p><p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p><p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p><p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) &#x2F; 4 &#x3D; 11 &#x2F; 4 &#x3D; 2.75，截断后得到 2 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/k-radius-subarray-averages">https://leetcode.cn/problems/k-radius-subarray-averages</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。<span style="color:red"><b>求一段子数组的和的做法是前缀和，这应该成为刷题的本能反应。</b></span></p><p>我们首先用一个额外数组记录整个数组的前缀和，然后再次遍历数组，根据条件计算以每一个下标 i 为中心，半径为 k 的子数组的和。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getAverages(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 要用long型，不然超出范围</span><br>        <span class="hljs-type">long</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(res, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i - k &gt;= <span class="hljs-number">0</span> &amp;&amp; i + k &lt; n) &#123;<br>                res[i] = (<span class="hljs-type">int</span>)((presum[i + k + <span class="hljs-number">1</span>] - presum[i - k]) / (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2460. Apply Operations to an Array</title>
    <link href="/posts/3837729252.html"/>
    <url>/posts/3837729252.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array nums of size n consisting of non-negative integers.</p><p>You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:</p><p>If nums[i] &#x3D;&#x3D; nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.<br>After performing all the operations, shift all the 0’s to the end of the array.</p><p>For example, the array [1,0,2,0,0,1] after shifting all its 0’s to the end, is [1,2,1,0,0,0].<br>Return the resulting array.</p><p>Note that the operations are applied sequentially, not all at once.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,2,1,1,0]<br>Output: [1,4,2,0,0,0]<br>Explanation: We do the following operations:</p><ul><li>i &#x3D; 0: nums[0] and nums[1] are not equal, so we skip this operation.</li><li>i &#x3D; 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].</li><li>i &#x3D; 2: nums[2] and nums[3] are not equal, so we skip this operation.</li><li>i &#x3D; 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].</li><li>i &#x3D; 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].<br>After that, we shift the 0’s to the end, which gives the array [1,4,2,0,0,0].</li></ul><p>Example 2:<br>Input: nums &#x3D; [0,1]<br>Output: [1,0]<br>Explanation: No operation can be applied, we just shift the 0 to the end.</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><p>对数组执行操作。</p><blockquote><p>给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。<br>你需要对数组执行 n - 1 步操作，其中第 i 步操作（从 0 开始计数）要求对 nums 中第 i 个元素执行下述指令：<br>如果 nums[i] &#x3D;&#x3D; nums[i + 1] ，则 nums[i] 的值变成原来的 2 倍，nums[i + 1] 的值变成 0 。否则，跳过这步操作。<br>在执行完 全部 操作后，将所有 0 移动 到数组的 末尾 。<br>例如，数组 [1,0,2,0,0,1] 将所有 0 移动到末尾后变为 [1,2,1,0,0,0] 。<br>返回结果数组。<br>注意 操作应当 依次有序 执行，而不是一次性全部执行。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/apply-operations-to-an-array">https://leetcode.cn/problems/apply-operations-to-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是追击型双指针，如果没有做过283题，建议先做一下，本题跟283题几乎一样。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] applyOperations(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                nums[i] = nums[i] * <span class="hljs-number">2</span>;<br>                nums[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[cur] = nums[i];<br>                cur++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (cur &lt; n) &#123;<br>            nums[cur] = <span class="hljs-number">0</span>;<br>            cur++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">283. Move Zeroes<br>2460. Apply Operations to an Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2559. Count Vowel Strings in Ranges</title>
    <link href="/posts/4288558704.html"/>
    <url>/posts/4288558704.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed array of strings words and a 2D array of integers queries.</p><p>Each query queries[i] &#x3D; [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.</p><p>Return an array ans of size queries.length, where ans[i] is the answer to the ith query.</p><p>Note that the vowel letters are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’.</p><p>Example 1:<br>Input: words &#x3D; [“aba”,”bcb”,”ece”,”aa”,”e”], queries &#x3D; [[0,2],[1,4],[1,1]]<br>Output: [2,3,0]<br>Explanation: The strings starting and ending with a vowel are “aba”, “ece”, “aa” and “e”.<br>The answer to the query [0,2] is 2 (strings “aba” and “ece”).<br>to query [1,4] is 3 (strings “ece”, “aa”, “e”).<br>to query [1,1] is 0.<br>We return [2,3,0].</p><p>Example 2:<br>Input: words &#x3D; [“a”,”e”,”i”], queries &#x3D; [[0,2],[0,1],[2,2]]<br>Output: [3,2,1]<br>Explanation: Every string satisfies the conditions, so we return [3,2,1].</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 105<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 40<br>words[i] consists only of lowercase English letters.<br>sum(words[i].length) &lt;&#x3D; 3 * 105<br>1 &lt;&#x3D; queries.length &lt;&#x3D; 105<br>0 &lt;&#x3D; li &lt;&#x3D; ri &lt; words.length</p><p>统计范围内的元音字符串数。</p><blockquote>给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。<p>每个查询 queries[i] &#x3D; [li, ri] 会要求我们统计在 words 中下标在 li 到 ri 范围内（包含 这两个值）并且以元音开头和结尾的字符串的数目。</p><p>返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。</p><p>注意：元音字母是 ‘a’、’e’、’i’、’o’ 和 ‘u’ 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges">https://leetcode.cn/problems/count-vowel-strings-in-ranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。这是前缀和的基础应用。如果 input 数组的长度是 n，那么我们需要一个长度为 n + 1 的数组记录前 n 个单词里面有多少个单词是以元音开头和结尾的。然后我们就可以以<code>O(1)</code>的时间找到下标在 li 到 ri 范围内（包含 这两个值）并且以元音开头和结尾的字符串的数目。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] vowelStrings(String[] words, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        presum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> helper(words[i]) == <span class="hljs-literal">true</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + cur;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">1</span>];<br>            res[i] = presum[right + <span class="hljs-number">1</span>] - presum[left];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> str.charAt(str.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> isVowel(first) &amp;&amp; isVowel(last);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVowel</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2441. Largest Positive Integer That Exists With Its Negative</title>
    <link href="/posts/1697121728.html"/>
    <url>/posts/1697121728.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.</p><p>Return the positive integer k. If there is no such integer, return -1.</p><p>Example 1:<br>Input: nums &#x3D; [-1,2,-3,3]<br>Output: 3<br>Explanation: 3 is the only valid k we can find in the array.</p><p>Example 2:<br>Input: nums &#x3D; [-1,10,6,7,-7,1]<br>Output: 7<br>Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.</p><p>Example 3:<br>Input: nums &#x3D; [-10,8,6,7,-2,-3]<br>Output: -1<br>Explanation: There is no a single valid k, we return -1.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>nums[i] !&#x3D; 0</p><p>与对应负数同时存在的最大正整数。</p><blockquote>给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 。<p>返回正整数 k ，如果不存在这样的整数，返回 -1 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative">https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路-扫描一遍"><a href="#思路-扫描一遍" class="headerlink" title="思路 - 扫描一遍"></a>思路 - 扫描一遍</h2><p>思路是 hashset。我们需要创建一个变量 res，初始值为 -1。然后遍历 input 数组，在遍历的过程中，将每个数字放入 hashset 并判断当前数字对应的负数是否已经存在于 hashset 了，如果存在，则当前数字的绝对值可以用来更新 res。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            set.add(num);<br>            <span class="hljs-keyword">if</span> (set.contains(-num) &amp;&amp; Math.abs(num) &gt; max) &#123;<br>                res = Math.abs(num);<br>                max = Math.abs(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1031. Maximum Sum of Two Non-Overlapping Subarrays</title>
    <link href="/posts/2255635013.html"/>
    <url>/posts/2255635013.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.</p><p>The array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.</p><p>A subarray is a contiguous part of an array.</p><p>Example 1:<br>Input: nums &#x3D; [0,6,5,2,2,5,1,9,4], firstLen &#x3D; 1, secondLen &#x3D; 2<br>Output: 20<br>Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.</p><p>Example 2:<br>Input: nums &#x3D; [3,8,1,3,2,1,8,9,0], firstLen &#x3D; 3, secondLen &#x3D; 2<br>Output: 29<br>Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.</p><p>Example 3:<br>Input: nums &#x3D; [2,1,5,6,0,9,5,0,3,8], firstLen &#x3D; 4, secondLen &#x3D; 3<br>Output: 31<br>Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3.</p><p>Constraints:<br>1 &lt;&#x3D; firstLen, secondLen &lt;&#x3D; 1000<br>2 &lt;&#x3D; firstLen + secondLen &lt;&#x3D; 1000<br>firstLen + secondLen &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><p>两个非重叠子数组的最大和。</p><blockquote>给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。<p>长度为 firstLen 的子数组可以出现在长为 secondLen 的子数组之前或之后，但二者必须是不重叠的。</p><p>子数组是数组的一个 连续 部分。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays">https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是<code>前缀和</code>。我参考了<a href="https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/solution/tu-jie-mei-you-si-lu-yi-zhang-tu-miao-do-3lli/">这个帖子</a>。因为要快速地找到子数组的和，所以容易想到用<code>前缀和</code>。注意这道题因为涉及到两个长度不同的子数组 A 和 B，长度分别为 firstLen 和 secondLen，所以需要考虑 <code>A+B</code> 和 <code>B+A</code> 两种情况，谁在前都可以。</p><p>具体做法是首先我们把整个数组的前缀和计算好，用一个数组 presum 存储，这样当我们需要得到一段子数组的和的时候，我们就可以用 O(1) 的时间拿到。接着我们遍历原数组，在遍历过程中，我们用一个变量 i 表示当前遍历到哪个下标，两个子数组 A 和 B 都在下标 i 的左侧。所以当我们在某个下标 i 的时候，子数组 A 的值 &#x3D; presum[i - secondLen] - presum[i - secondLen - firstLen]，子数组 B 的值 &#x3D; presum[i] - presum[i - secondLen]。找到两者的最大值再相加，就是最后的结果。下面这个图可以帮助理解。</p><p><img src="https://assets.leetcode.com/users/images/2eafddf3-c5d9-4fa3-8145-966f0a2cd63e_1605434988.6631174.png" alt="image.png"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSumTwoNoOverlap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> firstLen, <span class="hljs-type">int</span> secondLen)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max1</span> <span class="hljs-operator">=</span> getMax(presum, firstLen, secondLen);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max2</span> <span class="hljs-operator">=</span> getMax(presum, secondLen, firstLen);<br>        <span class="hljs-keyword">return</span> Math.max(max1, max2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] presum, <span class="hljs-type">int</span> firstLen, <span class="hljs-type">int</span> secondLen)</span> &#123;<br><span class="hljs-comment">// 找到firstLen的最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxFirst</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstLen + secondLen; i &lt; presum.length; i++) &#123;<br>            maxFirst = Math.max(maxFirst, presum[i - secondLen] - presum[i - secondLen - firstLen]);<br><span class="hljs-comment">// 找到整体的最大值</span><br>            max = Math.max(max, maxFirst + presum[i] - presum[i - secondLen]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2336. Smallest Number in Infinite Set</title>
    <link href="/posts/676651753.html"/>
    <url>/posts/676651753.html</url>
    
    <content type="html"><![CDATA[<p>You have a set which contains all positive integers [1, 2, 3, 4, 5, …].</p><p>Implement the SmallestInfiniteSet class:<br>SmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.<br>int popSmallest() Removes and returns the smallest integer contained in the infinite set.<br>void addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.</p><p>Example 1:<br>Input<br>[“SmallestInfiniteSet”, “addBack”, “popSmallest”, “popSmallest”, “popSmallest”, “addBack”, “popSmallest”, “popSmallest”, “popSmallest”]<br>[[], [2], [], [], [], [1], [], [], []]<br>Output<br>[null, null, 1, 2, 3, null, 1, 4, 5]</p><p>Explanation<br>SmallestInfiniteSet smallestInfiniteSet &#x3D; new SmallestInfiniteSet();<br>smallestInfiniteSet.addBack(2);    &#x2F;&#x2F; 2 is already in the set, so no change is made.<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; return 1, since 1 is the smallest number, and remove it from the set.<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; return 2, and remove it from the set.<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; return 3, and remove it from the set.<br>smallestInfiniteSet.addBack(1);    &#x2F;&#x2F; 1 is added back to the set.<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; return 1, since 1 was added back to the set and<br>                                   &#x2F;&#x2F; is the smallest number, and remove it from the set.<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; return 4, and remove it from the set.<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; return 5, and remove it from the set.<br>Constraints:</p><p>1 &lt;&#x3D; num &lt;&#x3D; 1000<br>At most 1000 calls will be made in total to popSmallest and addBack.</p><p>无限集中的最小数字。</p><blockquote><p>现有一个包含所有正整数的集合 [1, 2, 3, 4, 5, …] 。<br>实现 SmallestInfiniteSet 类：<br>SmallestInfiniteSet() 初始化 SmallestInfiniteSet 对象以包含 所有 正整数。<br>int popSmallest() 移除 并返回该无限集中的最小整数。<br>void addBack(int num) 如果正整数 num 不 存在于无限集中，则将一个 num 添加 到该无限集中。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/smallest-number-in-infinite-set">https://leetcode.cn/problems/smallest-number-in-infinite-set</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是最小堆 + hashset。初始化的时候，我们将 1 - 1000 这些数字都分别放入最小堆和 hashset 中。<br>pop() 很好判断，就是从最小堆中弹出一个元素即可，同时在 hashset 中也移除这个元素。<br>addBack() 需要判断最小堆中是否已经存在这个数字了，如果不存在才加回去。注意 testcase 中对于 add 操作，给的数字不一定是已经弹出的元素。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallestInfiniteSet</span> &#123;<br>    PriorityQueue&lt;Integer&gt; queue;<br>    Set&lt;Integer&gt; set;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmallestInfiniteSet</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>            queue.offer(i);<br>            set.add(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">popSmallest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!queue.isEmpty()) &#123;<br>            set.remove(queue.peek());<br>            <span class="hljs-keyword">return</span> queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBack</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!set.contains(num)) &#123;<br>            set.add(num);<br>            queue.offer(num);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * SmallestInfiniteSet obj = new SmallestInfiniteSet();</span><br><span class="hljs-comment"> * int param_1 = obj.popSmallest();</span><br><span class="hljs-comment"> * obj.addBack(num);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>design</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2418. Sort the People</title>
    <link href="/posts/1676590272.html"/>
    <url>/posts/1676590272.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.</p><p>For each index i, names[i] and heights[i] denote the name and height of the ith person.</p><p>Return names sorted in descending order by the people’s heights.</p><p>Example 1:<br>Input: names &#x3D; [“Mary”,”John”,”Emma”], heights &#x3D; [180,165,170]<br>Output: [“Mary”,”Emma”,”John”]<br>Explanation: Mary is the tallest, followed by Emma and John.</p><p>Example 2:<br>Input: names &#x3D; [“Alice”,”Bob”,”Bob”], heights &#x3D; [155,185,150]<br>Output: [“Bob”,”Alice”,”Bob”]<br>Explanation: The first Bob is the tallest, followed by Alice and the second Bob.</p><p>Constraints:<br>n &#x3D;&#x3D; names.length &#x3D;&#x3D; heights.length<br>1 &lt;&#x3D; n &lt;&#x3D; 103<br>1 &lt;&#x3D; names[i].length &lt;&#x3D; 20<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; 105<br>names[i] consists of lower and upper case English letters.<br>All the values of heights are distinct.</p><p>按身高排序。</p><blockquote>给你一个字符串数组 names ，和一个由 互不相同 的正整数组成的数组 heights 。两个数组的长度均为 n 。<p>对于每个下标 i，names[i] 和 heights[i] 表示第 i 个人的名字和身高。</p><p>请按身高 降序 顺序返回对应的名字数组 names 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sort-the-people">https://leetcode.cn/problems/sort-the-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是排序。注意题目说了每个人的身高是独一无二的，所以这里我们可以用一个 hashmap 存每个人的&lt;身高，名字&gt;。然后我们对 heights 数组进行排序并从大到小遍历。遍历的时候将每个身高在 hashmap 中对应的名字放入结果集。</p><p>这道题如果难一点，可以把条件改为如果身高不是独一无二的话该怎么做。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] sortPeople(String[] names, <span class="hljs-type">int</span>[] heights) &#123;<br>        HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            map.put(heights[i], names[i]);<br>        &#125;<br><br>        Arrays.sort(heights);<br>        String[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> heights.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            res[index++] = map.get(heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>sort</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2300. Successful Pairs of Spells and Potions</title>
    <link href="/posts/2633094956.html"/>
    <url>/posts/2633094956.html</url>
    
    <content type="html"><![CDATA[<p>You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.</p><p>You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.</p><p>Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.</p><p>Example 1:<br>Input: spells &#x3D; [5,1,3], potions &#x3D; [1,2,3,4,5], success &#x3D; 7<br>Output: [4,0,3]<br>Explanation:</p><ul><li>0th spell: 5 * [1,2,3,4,5] &#x3D; [5,10,15,20,25]. 4 pairs are successful.</li><li>1st spell: 1 * [1,2,3,4,5] &#x3D; [1,2,3,4,5]. 0 pairs are successful.</li><li>2nd spell: 3 * [1,2,3,4,5] &#x3D; [3,6,9,12,15]. 3 pairs are successful.<br>Thus, [4,0,3] is returned.</li></ul><p>Example 2:<br>Input: spells &#x3D; [3,1,2], potions &#x3D; [8,5,8], success &#x3D; 16<br>Output: [2,0,2]<br>Explanation:</p><ul><li>0th spell: 3 * [8,5,8] &#x3D; [24,15,24]. 2 pairs are successful.</li><li>1st spell: 1 * [8,5,8] &#x3D; [8,5,8]. 0 pairs are successful. </li><li>2nd spell: 2 * [8,5,8] &#x3D; [16,10,16]. 2 pairs are successful.<br>Thus, [2,0,2] is returned.</li></ul><p>Constraints:<br>n &#x3D;&#x3D; spells.length<br>m &#x3D;&#x3D; potions.length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 105<br>1 &lt;&#x3D; spells[i], potions[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; success &lt;&#x3D; 1010</p><p>咒语和药水的成功对数。</p><blockquote>给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。<p>同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。</p><p>请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions">https://leetcode.cn/problems/successful-pairs-of-spells-and-potions</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是排序 + 二分。题意不难理解，注意看第一个例子，当发现 5 * 2 &#x3D; 10 &gt; 4 的时候，包括 2 在内后面所有的乘积都可以被判为 success，所以这里考虑对 potion 数组排序。这道题属于在答案上二分的题。</p><p>第一次做的时候用了两层 for 循环，发现最后有几个很长的 case 超时。优化的思路只能往二分上靠。这道题能用二分优化的前提是被二分的数据是有序的，因为我们对 potion 数组已经排过序，所以可以用二分。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogm)<br>空间O(n) - output array</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] successfulPairs(<span class="hljs-type">int</span>[] spells, <span class="hljs-type">int</span>[] potions, <span class="hljs-type">long</span> success) &#123;<br>        Arrays.sort(potions);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> spells.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> potions.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">spell</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) spells[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> m;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (spell * potions[mid] &lt; success) &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            res[i] = m - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2348. Number of Zero-Filled Subarrays</title>
    <link href="/posts/16359.html"/>
    <url>/posts/16359.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return the number of subarrays filled with 0.</p><p>A subarray is a contiguous non-empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,0,0,2,0,0,4]<br>Output: 6<br>Explanation:<br>There are 4 occurrences of [0] as a subarray.<br>There are 2 occurrences of [0,0] as a subarray.<br>There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.</p><p>Example 2:<br>Input: nums &#x3D; [0,0,0,2,0,0]<br>Output: 9<br>Explanation:<br>There are 5 occurrences of [0] as a subarray.<br>There are 3 occurrences of [0,0] as a subarray.<br>There is 1 occurrence of [0,0,0] as a subarray.<br>There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.</p><p>Example 3:<br>Input: nums &#x3D; [2,10,2019]<br>Output: 0<br>Explanation: There is no subarray filled with 0. Therefore, we return 0.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>全 0 子数组的数目。</p><blockquote>给你一个整数数组 nums ，返回全部为 0 的 子数组 数目。<p>子数组 是一个数组中一段连续非空元素组成的序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/number-of-zero-filled-subarrays">https://leetcode.cn/problems/number-of-zero-filled-subarrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道数学题，也可以用动态规划做。我参考了<a href="https://leetcode.cn/problems/number-of-zero-filled-subarrays/solution/by-endlesscheng-men8/">这个帖子</a>。</p><p>具体的思路是如果我们当前位置上遇到的是一个 0，我们就把当前这个 0 当做子数组的结尾，来统计以当前这个 0 为结尾的符合题意的子数组有多少。举个例子，比如 [0, 0, 0, 0]，我们设一个变量 count 记录当前遇到的连续的 0 的个数</p><p>当我们遇到第一个 0 的时候，count &#x3D; 1, res +&#x3D; count</p><p>当我们遇到第二个 0 的时候，count &#x3D; 2, res +&#x3D; count</p><p>这里 count 其实暗含了子数组的个数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">zeroFilledSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>                res += count;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1590. Make Sum Divisible by P</title>
    <link href="/posts/1110332484.html"/>
    <url>/posts/1110332484.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.</p><p>Return the length of the smallest subarray that you need to remove, or -1 if it’s impossible.</p><p>A subarray is defined as a contiguous block of elements in the array.</p><p>Example 1:<br>Input: nums &#x3D; [3,1,4,2], p &#x3D; 6<br>Output: 1<br>Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.</p><p>Example 2:<br>Input: nums &#x3D; [6,3,5,2], p &#x3D; 9<br>Output: 2<br>Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.</p><p>Example 3:<br>Input: nums &#x3D; [1,2,3], p &#x3D; 3<br>Output: 0<br>Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; p &lt;&#x3D; 109</p><p>使数组和能被 P 整除。</p><blockquote>给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。<p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。</p><p>子数组 定义为原数组中连续的一组元素。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/make-sum-divisible-by-p">https://leetcode.cn/problems/make-sum-divisible-by-p</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和。这算是前缀和类型的题目里比较麻烦的一道题，思路不难看出来但是里面有一些细节的实现需要注意。</p><p>题目问的是能否找到一个最短的子数组满足移除这个子数组之后，剩下的部分能被 P 整除。一个容易想到的 corner case 是如果整个数组的前缀和就能被 P 整除，那么直接返回 0 即可。</p><p>一般的 case 是，假设整个数组的前缀和 &#x3D; sum，sum % p &#x3D; remainder。我们需要找的是一个最短的子数组，他的和 sum2 &#x3D; remainder，这样 sum - sum2 就能被 P 整除了。如下图，我们找一个最短的黄色的部分，然后黄色的部分 % P &#x3D; remainder 即可。</p><p>[x, x, x, x, &#x3D;&#x3D;x, x, x, x, x&#x3D;&#x3D;, x, x, x, x, x, x, x]</p><p>注意我们在累加前缀和的时候，每次加一个数字，都要 % P，这样使得 sum2 总是落在 [0, p) 这个范围内。包括代码内怎么找 j 的方法，需要确保模运算的两个数字都是正数。这是模运算的一些常用技巧。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (sum % p == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (sum % p);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> n;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum2 = (sum2 + nums[i]) % p;<br>            map.put(sum2, i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> (sum2 - remainder + p) % p;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> map.getOrDefault(target, -n);<br>            res = Math.min(res, i - j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &lt; n ? res : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>MOD</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2187. Minimum Time to Complete Trips</title>
    <link href="/posts/2220153078.html"/>
    <url>/posts/2220153078.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.</p><p>Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.</p><p>You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.</p><p>Example 1:<br>Input: time &#x3D; [1,2,3], totalTrips &#x3D; 5<br>Output: 3<br>Explanation:</p><ul><li>At time t &#x3D; 1, the number of trips completed by each bus are [1,0,0].<br>The total number of trips completed is 1 + 0 + 0 &#x3D; 1.</li><li>At time t &#x3D; 2, the number of trips completed by each bus are [2,1,0].<br>The total number of trips completed is 2 + 1 + 0 &#x3D; 3.</li><li>At time t &#x3D; 3, the number of trips completed by each bus are [3,1,1].<br>The total number of trips completed is 3 + 1 + 1 &#x3D; 5.<br>So the minimum time needed for all buses to complete at least 5 trips is 3.</li></ul><p>Example 2:<br>Input: time &#x3D; [2], totalTrips &#x3D; 1<br>Output: 2<br>Explanation:<br>There is only one bus, and it will complete its first trip at t &#x3D; 2.<br>So the minimum time needed to complete 1 trip is 2.</p><p>Constraints:<br>1 &lt;&#x3D; time.length &lt;&#x3D; 105<br>1 &lt;&#x3D; time[i], totalTrips &lt;&#x3D; 107</p><p>完成旅途的最少时间。</p><blockquote>给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。<p>每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。</p><p>给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-time-to-complete-trips">https://leetcode.cn/problems/minimum-time-to-complete-trips</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分法，而且是在答案上二分。</p><p>题意很好理解，让你找一个最少完成 totalTrips 趟旅途所花的时间。因为时间是线性的，所以我们可以利用二分的性质快速找到一个合适的时间，二分的下界是 1，上界可以取一个足够大的数字，或者有的做法是找出速度最快的公交车，看他完成 totalTrips 趟旅途的所需时间。</p><p>因为我们二分法分的是最后的答案 - 完成 totalTrips 趟旅途所需的时间，所以我们判断 mid 到底往左还是往右是需要判断在 mid 时间内，所有公交车能完成的旅途是多少，如果大于 totalTrips，则说明当前速度太快，速度可以减少一些， right &#x3D; mid；反之 left &#x3D; mid + 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumTime</span><span class="hljs-params">(<span class="hljs-type">int</span>[] time, <span class="hljs-type">int</span> totalTrips)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) <span class="hljs-number">1e18</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (helper(time, mid, totalTrips) &gt;= totalTrips) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bus, <span class="hljs-type">long</span> time, <span class="hljs-type">int</span> totalTrips)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> bus.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res += time / bus[i];<br>            <span class="hljs-keyword">if</span> (res &gt;= totalTrips) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1792. Maximum Average Pass Ratio</title>
    <link href="/posts/3286329493.html"/>
    <url>/posts/3286329493.html</url>
    
    <content type="html"><![CDATA[<p>There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] &#x3D; [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.</p><p>You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.</p><p>The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.</p><p>Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.</p><p>Example 1:<br>Input: classes &#x3D; [[1,2],[3,5],[2,2]], extraStudents &#x3D; 2<br>Output: 0.78333<br>Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3&#x2F;4 + 3&#x2F;5 + 2&#x2F;2) &#x2F; 3 &#x3D; 0.78333.</p><p>Example 2:<br>Input: classes &#x3D; [[2,4],[3,9],[4,5],[2,10]], extraStudents &#x3D; 4<br>Output: 0.53485</p><p>Constraints:<br>1 &lt;&#x3D; classes.length &lt;&#x3D; 105<br>classes[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; passi &lt;&#x3D; totali &lt;&#x3D; 105<br>1 &lt;&#x3D; extraStudents &lt;&#x3D; 105</p><p>最大平均通过率。</p><blockquote>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。<p>给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p>请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-average-pass-ratio">https://leetcode.cn/problems/maximum-average-pass-ratio</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心，需要用到优先队列。</p><p>这个题的题意有点绕，需要细心。注意 code signature 最后要你返回的是 double 所以需要注意精度问题。同时注意题目的细节，因为 extraStudents 是一些一定会通过考试的学生，所以为了提高平均通过率，我们找的不应该是通过率最低的班级，而是找那些加入 extraStudents 之后，<code>通过率提升/变化最多</code>的班级。所以这里我们需要的是一个最大堆。我们将每个班的数据都放到堆中，按照通过率变化由大到小排序，这样，通过率提升最多的班级会在堆顶。</p><p>这里我解释一下为什么是找那些加入 extraStudents 之后，<code>通过率提升/变化最多</code>的班级。我参考了<a href="https://leetcode.cn/problems/maximum-average-pass-ratio/solutions/655148/zui-da-ping-jun-tong-guo-lu-by-zerotrac2-84br">这个帖子</a>。注意里面的提示三，<code>在不断地给同一个班级安排学生的过程中，增加的通过率是逐渐单调递减的</code>。</p><p>举个例子，如果 x &#x3D; 3, y &#x3D; 4，那么 x &#x2F; y &#x3D; 3&#x2F;4（四分之三）。<br>x + 1 &#x3D; 4, y + 1 &#x3D; 5, 那么 x + 1 &#x2F; y + 1 &#x3D; 4&#x2F;5（五分之四）。<br>x + 2 &#x3D; 5, y + 2 &#x3D; 6, 那么 x + 2 &#x2F; y + 2 &#x3D; 5&#x2F;6（六分之五）。<br>从 3&#x2F;4 到 4&#x2F;5 的差距是比 4&#x2F;5 到 5&#x2F;6 的差距要大的。这里可以拿笔算一下。所以这里我们把通过率变化最大的元素放在堆顶，每次拿出堆顶元素，从 extraStudents 中拿一个加到堆顶元素，这样一直做直到用完 extraStudents。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">maxAverageRatio</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] classes, <span class="hljs-type">int</span> extraStudents)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> classes.length;<br>        <span class="hljs-comment">// max heap</span><br>        PriorityQueue&lt;<span class="hljs-type">double</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (b[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) / (b[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) - b[<span class="hljs-number">0</span>] / b[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">double</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (a[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) / (a[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) - a[<span class="hljs-number">0</span>] / a[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] c : classes) &#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[] &#123; c[<span class="hljs-number">0</span>], c[<span class="hljs-number">1</span>] &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (extraStudents &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span>[] cur = queue.poll();<br>            cur[<span class="hljs-number">0</span>] += <span class="hljs-number">1.0</span>;<br>            cur[<span class="hljs-number">1</span>] += <span class="hljs-number">1.0</span>;<br>            queue.offer(cur);<br>            extraStudents--;<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">double</span>[] cur = queue.poll();<br>            res += cur[<span class="hljs-number">0</span>] / cur[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res / n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>math</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2331. Evaluate Boolean Binary Tree</title>
    <link href="/posts/1989222089.html"/>
    <url>/posts/1989222089.html</url>
    
    <content type="html"><![CDATA[<p>You are given the root of a full binary tree with the following properties:<br>Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.<br>Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.</p><p>The evaluation of a node is as follows:<br>If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.<br>Otherwise, evaluate the node’s two children and apply the boolean operation of its value with the children’s evaluations.</p><p>Return the boolean result of evaluating the root node.</p><p>A full binary tree is a binary tree where each node has either 0 or 2 children.</p><p>A leaf node is a node that has zero children.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png" alt="Example 1"><br>Input: root &#x3D; [2,1,3,null,null,0,1]<br>Output: true<br>Explanation: The above diagram illustrates the evaluation process.<br>The AND node evaluates to False AND True &#x3D; False.<br>The OR node evaluates to True OR False &#x3D; True.<br>The root node evaluates to True, so we return true.</p><p>Example 2:<br>Input: root &#x3D; [0]<br>Output: false<br>Explanation: The root node is a leaf node and it evaluates to false, so we return false.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 1000].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 3<br>Every node has either 0 or 2 children.<br>Leaf nodes have a value of 0 or 1.<br>Non-leaf nodes have a value of 2 or 3.</p><p>计算布尔二叉树的值。</p><blockquote>给你一棵 完整二叉树 的根，这棵树有以下特征：<p>叶子节点 要么值为 0 要么值为 1 ，其中 0 表示 False ，1 表示 True 。<br>非叶子节点 要么值为 2 要么值为 3 ，其中 2 表示逻辑或 OR ，3 表示逻辑与 AND 。<br>计算 一个节点的值方式如下：</p><p>如果节点是个叶子节点，那么节点的 值 为它本身，即 True 或者 False 。<br>否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算 。<br>返回根节点 root 的布尔运算值。</p><p>完整二叉树 是每个节点有 0 个或者 2 个孩子的二叉树。</p><p>叶子节点 是没有孩子的节点。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree">https://leetcode.cn/problems/evaluate-boolean-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-后序遍历"><a href="#思路一-后序遍历" class="headerlink" title="思路一 - 后序遍历"></a>思路一 - 后序遍历</h2><p>因为最后判断整个树的布尔值是看根节点的布尔值，而根节点的布尔值是由下面的孩子节点的布尔值得来的，所以一个不难想到的思路就是后序遍历，从这棵树的叶子节点开始往上统计布尔值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">evaluateTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> helper(root.left);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> helper(root.right);<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> left || right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-递归"><a href="#思路二-递归" class="headerlink" title="思路二 - 递归"></a>思路二 - 递归</h2><p>我直接给代码。时间空间复杂度同思路一。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">evaluateTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root.val == <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> evaluateTree(root.left) || evaluateTree(root.right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> evaluateTree(root.left) &amp;&amp; evaluateTree(root.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1254. Number of Closed Islands</title>
    <link href="/posts/1313054330.html"/>
    <url>/posts/1313054330.html</url>
    
    <content type="html"><![CDATA[<p>Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.</p><p>Return the number of closed islands.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png" alt="Example 1"><br>Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]<br>Output: 2<br>Explanation:<br>Islands in gray are closed because they are completely surrounded by water (group of 1s).</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/10/31/sample_4_1610.png" alt="Example 2"><br>Input: grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]<br>Output: 1</p><p>Example 3:<br>Input: grid &#x3D; [[1,1,1,1,1,1,1],<br>               [1,0,0,0,0,0,1],<br>               [1,0,1,1,1,0,1],<br>               [1,0,1,0,1,0,1],<br>               [1,0,1,1,1,0,1],<br>               [1,0,0,0,0,0,1],<br>               [1,1,1,1,1,1,1]]<br>Output: 2</p><p>Constraints:<br>1 &lt;&#x3D; grid.length, grid[0].length &lt;&#x3D; 100<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 1</p><p>统计封闭岛屿的数目。</p><blockquote>二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。<p>请返回 封闭岛屿 的数目。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/number-of-closed-islands">https://leetcode.cn/problems/number-of-closed-islands</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路还是跟岛屿类型的题一样，用 BFS 或者 DFS 做，需要遍历 input 矩阵两遍。BFS 或者 DFS 做时间空间复杂度相同。</p><p>注意这道题的规则，在 grid 边缘上的 0 是无法被完全包围的，所以我们第一轮遍历的时候先要把这些 0 变成 1。第二轮扫描的时候，剩下的 0 才是四面都被 1 包围的 0。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="DFS实现"><a href="#DFS实现" class="headerlink" title="DFS实现"></a>DFS实现</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closedIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// 处理边界上的0</span><br><span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == n - <span class="hljs-number">1</span>) &amp;&amp; grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>dfs(grid, i, j);<br>&#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>count++;<br>dfs(grid, i, j);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>        grid[i][j] = <span class="hljs-number">1</span>;<br>dfs(grid, i - <span class="hljs-number">1</span>, j);<br>dfs(grid, i + <span class="hljs-number">1</span>, j);<br>dfs(grid, i, j - <span class="hljs-number">1</span>);<br>dfs(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS实现"><a href="#BFS实现" class="headerlink" title="BFS实现"></a>BFS实现</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] dx = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>[] dy = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closedIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 把边界上所有的0变成1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == n - <span class="hljs-number">1</span>) &amp;&amp; grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    bfs(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    count++;<br>                    bfs(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            grid[x][y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dx[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> y + dy[k];<br>                <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; grid[newX][newY] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; newX, newY &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1814. Count Nice Pairs in an Array</title>
    <link href="/posts/861179681.html"/>
    <url>/posts/861179681.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) &#x3D; 321, and rev(120) &#x3D; 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:</p><p>0 &lt;&#x3D; i &lt; j &lt; nums.length<br>nums[i] + rev(nums[j]) &#x3D;&#x3D; nums[j] + rev(nums[i])<br>Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.</p><p>Example 1:<br>Input: nums &#x3D; [42,11,1,97]<br>Output: 2<br>Explanation: The two pairs are:</p><ul><li>(0,3) : 42 + rev(97) &#x3D; 42 + 79 &#x3D; 121, 97 + rev(42) &#x3D; 97 + 24 &#x3D; 121.</li><li>(1,2) : 11 + rev(1) &#x3D; 11 + 1 &#x3D; 12, 1 + rev(11) &#x3D; 1 + 11 &#x3D; 12.</li></ul><p>Example 2:<br>Input: nums &#x3D; [13,10,35,24,76]<br>Output: 4</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>统计一个数组中好对子的数目。</p><blockquote>给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) = 321 ， rev(120) = 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ：<p>0 &lt;&#x3D; i &lt; j &lt; nums.length<br>nums[i] + rev(nums[j]) &#x3D;&#x3D; nums[j] + rev(nums[i])<br>请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/count-nice-pairs-in-an-array">https://leetcode.cn/problems/count-nice-pairs-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题思路类似 two sum。注意题目描述，题目让你找的是有多少对下标（i, j）满足 nums[i] + rev(nums[j]) &#x3D;&#x3D; nums[j] + rev(nums[i])，其中 rev() 函数是把这个数字翻转过来。</p><p>这个题目很像 two sum，也是找两数之和，只不过等号右边也是两数之和。我们可以把这个等式转换成 nums[i] - rev(nums[i]) &#x3D;&#x3D; nums[j] - rev(nums[j])，这样我们找的就是是否存在两个不同的下标，对应的两个数字的 nums[i] - rev(nums[i]) 相等。这里为了保险起见，计算结果我用了 long 型避免溢出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n * logC) - rev()函数的复杂度是 logC<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNicePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rev</span> <span class="hljs-operator">=</span> helper(num);<br>            <span class="hljs-keyword">if</span> (map.containsKey(num - rev)) &#123;<br>                count += map.get(num - rev);<br>            &#125;<br>            map.put(num - rev, map.getOrDefault(num - rev, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (count % MOD);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            res = res * <span class="hljs-number">10</span> + num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1813. Sentence Similarity III</title>
    <link href="/posts/975606356.html"/>
    <url>/posts/975606356.html</url>
    
    <content type="html"><![CDATA[<p>You are given two strings sentence1 and sentence2, each representing a sentence composed of words. A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of only uppercase and lowercase English characters.</p><p>Two sentences s1 and s2 are considered similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. Note that the inserted sentence must be separated from existing words by spaces.</p><p>For example,<br>s1 &#x3D; “Hello Jane” and s2 &#x3D; “Hello my name is Jane” can be made equal by inserting “my name is” between “Hello” and “Jane” in s1.<br>s1 &#x3D; “Frog cool” and s2 &#x3D; “Frogs are cool” are not similar, since although there is a sentence “s are” inserted into s1, it is not separated from “Frog” by a space.<br>Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.</p><p>Example 1:<br>Input: sentence1 &#x3D; “My name is Haley”, sentence2 &#x3D; “My Haley”<br>Output: true</p><p>Explanation:<br>sentence2 can be turned to sentence1 by inserting “name is” between “My” and “Haley”.</p><p>Example 2:<br>Input: sentence1 &#x3D; “of”, sentence2 &#x3D; “A lot of words”<br>Output: false</p><p>Explanation:<br>No single sentence can be inserted inside one of the sentences to make it equal to the other.</p><p>Example 3:<br>Input: sentence1 &#x3D; “Eating right now”, sentence2 &#x3D; “Eating”<br>Output: true</p><p>Explanation:<br>sentence2 can be turned to sentence1 by inserting “right now” at the end of the sentence.</p><p>Constraints:<br>1 &lt;&#x3D; sentence1.length, sentence2.length &lt;&#x3D; 100<br>sentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.<br>The words in sentence1 and sentence2 are separated by a single space.</p><p>句子相似性 III。</p><blockquote>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，"Hello World" ，"HELLO" ，"hello world hello world" 都是句子。每个单词都 只 包含大写和小写英文字母。<p>如果两个句子 sentence1 和 sentence2 ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，sentence1 &#x3D; “Hello my name is Jane” 且 sentence2 &#x3D; “Hello Jane” ，我们可以往 sentence2 中 “Hello” 和 “Jane” 之间插入 “my name is” 得到 sentence1 。</p><p>给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是相似的，请你返回 true ，否则返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sentence-similarity-iii">https://leetcode.cn/problems/sentence-similarity-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-双端队列dequeue"><a href="#思路一-双端队列dequeue" class="headerlink" title="思路一 - 双端队列dequeue"></a>思路一 - 双端队列dequeue</h2><p>把两个句子 sentence1 和 sentence2 转化成 string array， 再把 array 中的每个 string 放到一个双端队列 dequeue 里。比较两个 dequeue 左边和右边相同的单词，如果单词一样，则弹出，统计两边一共弹出的单词数。如果一共弹出的单词数等于两个句子中较短的那个句子的单词数，则返回 true ，否则返回 false 。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areSentencesSimilar</span><span class="hljs-params">(String sentence1, String sentence2)</span> &#123;<br>        Deque&lt;String&gt; dq1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(Arrays.asList(sentence1.split(<span class="hljs-string">&quot; &quot;</span>)));<br>        Deque&lt;String&gt; dq2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(Arrays.asList(sentence2.split(<span class="hljs-string">&quot; &quot;</span>)));<br>        <span class="hljs-keyword">while</span> (!dq1.isEmpty() &amp;&amp; !dq2.isEmpty() &amp;&amp; dq1.peekFirst().equals(dq2.peekFirst())) &#123;<br>            dq1.pollFirst();<br>            dq2.pollFirst();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!dq1.isEmpty() &amp;&amp; !dq2.isEmpty() &amp;&amp; dq1.peekLast().equals(dq2.peekLast())) &#123;<br>            dq1.pollLast();<br>            dq2.pollLast();<br>        &#125;<br>        <span class="hljs-keyword">return</span> dq1.isEmpty() || dq2.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// deque</span><br></code></pre></td></tr></table></figure><h2 id="思路二-双指针"><a href="#思路二-双指针" class="headerlink" title="思路二 - 双指针"></a>思路二 - 双指针</h2><p>与思路一类似，分别从左边和右边比较两个 string array 的单词，只不过 dequeue 的做法是弹出相同的单词，统计的是弹出的单词数；双指针的做法是统计了指针移动的步数。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">areSentencesSimilar</span><span class="hljs-params">(String sentence1, String sentence2)</span> &#123;<br>String[] words1 = sentence1.split(<span class="hljs-string">&quot; &quot;</span>);<br>String[] words2 = sentence2.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (words1.length &gt; words2.length) &#123;<br>String[] temp = words1;<br>words1 = words2;<br>words2 = temp;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words1.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> words2.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// compare from left</span><br><span class="hljs-keyword">while</span> (i &lt; words1.length &amp;&amp; words1[i].equals(words2[i])) &#123;<br>i++;<br>&#125;<br><span class="hljs-comment">// compare from right</span><br><span class="hljs-keyword">while</span> (j &lt; words1.length &amp;&amp; words1[n - <span class="hljs-number">1</span> - j].equals(words2[m - <span class="hljs-number">1</span> - j])) &#123;<br>j++;<br>&#125;<br><span class="hljs-keyword">return</span> i + j &gt;= n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>string</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1833. Maximum Ice Cream Bars</title>
    <link href="/posts/1858468194.html"/>
    <url>/posts/1858468194.html</url>
    
    <content type="html"><![CDATA[<p>It is a sweltering summer day, and a boy wants to buy some ice cream bars.</p><p>At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. </p><p>Return the maximum number of ice cream bars the boy can buy with coins coins.</p><p>Note: The boy can buy the ice cream bars in any order.</p><p>Example 1:<br>Input: costs &#x3D; [1,3,2,4,1], coins &#x3D; 7<br>Output: 4<br>Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 &#x3D; 7.</p><p>Example 2:<br>Input: costs &#x3D; [10,6,8,7,7,8], coins &#x3D; 5<br>Output: 0<br>Explanation: The boy cannot afford any of the ice cream bars.</p><p>Example 3:<br>Input: costs &#x3D; [1,6,3,1,2,5], coins &#x3D; 20<br>Output: 6<br>Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 &#x3D; 18.</p><p>Constraints:<br>costs.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; costs[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; coins &lt;&#x3D; 108</p><p>雪糕的最大数量。</p><blockquote>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。<p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p><p>注意：Tony 可以按任意顺序购买雪糕。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-ice-cream-bars">https://leetcode.cn/problems/maximum-ice-cream-bars</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 counting sort 计数排序，这是题目要求。当然这道题也可以用排序做。</p><p>我们创建一个 map 数组，长度为 100001，这是 input data 给的最大值，然后开始遍历 input 数组，记录每个单价不同的雪糕分别有几个。再次遍历 map 数组，从单价最小的元素开始，如果当前雪糕的单价 map[i] 小于目前手里的 coins，意味着我们可以起码买一个当前单价的雪糕。对于当前单价的这种雪糕，我们能买的数量 &#x3D; Math.min(coins &#x2F; map[i], map[i])，意思是 coins 能买的数量和这个单价的雪糕的数量的最小值。这里容易忽略。举个例子，比如你有 400 块，单价 2 块的雪糕只有 1 个，你能买的单价 2 块的雪糕也有只有 1 个而不是 200 个。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxIceCream</span><span class="hljs-params">(<span class="hljs-type">int</span>[] costs, <span class="hljs-type">int</span> coins)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100001</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cost : costs) &#123;<br>            map[cost]++;<br>            max = Math.max(max, cost);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= max; i++) &#123;<br><span class="hljs-comment">// 如果钱花完了就直接退出</span><br>            <span class="hljs-keyword">if</span> (coins &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><span class="hljs-comment">// 如果当前单价的雪糕还有并且我手里还有钱</span><br>            <span class="hljs-keyword">if</span> (map[i] != <span class="hljs-number">0</span> &amp;&amp; coins &gt;= i) &#123;<br><span class="hljs-comment">// 可以购买的数量</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Math.min(coins / i, map[i]);<br>                map[i] -= count;<br>                res += count;<br>                coins -= i * count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>counting sort</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2244. Minimum Rounds to Complete All Tasks</title>
    <link href="/posts/3323451786.html"/>
    <url>/posts/3323451786.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.</p><p>Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.</p><p>Example 1:<br>Input: tasks &#x3D; [2,2,3,3,2,4,4,4,4,4]<br>Output: 4<br>Explanation: To complete all the tasks, a possible plan is:</p><ul><li>In the first round, you complete 3 tasks of difficulty level 2. </li><li>In the second round, you complete 2 tasks of difficulty level 3. </li><li>In the third round, you complete 3 tasks of difficulty level 4. </li><li>In the fourth round, you complete 2 tasks of difficulty level 4.<br>It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.</li></ul><p>Example 2:<br>Input: tasks &#x3D; [2,3,3]<br>Output: -1<br>Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.</p><p>Constraints:<br>1 &lt;&#x3D; tasks.length &lt;&#x3D; 105<br>1 &lt;&#x3D; tasks[i] &lt;&#x3D; 109</p><p>完成所有任务需要的最少轮数。</p><blockquote>给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。来源：力扣（LeetCode）链接：https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难想到是需要用 hashmap 先统计一下 每个不同难度级别的任务 分别出现了几次（key, c），然后再计算 每个不同难度级别的任务 需要几轮才能完成。计算轮数的时候，涉及到一些数学&#x2F;归纳。我这里提供一个分类讨论的办法，不是最优解，写的有点麻烦。</p><ul><li>c &#x3D; 1，直接返回 -1，因为不能处理</li><li>c &#x3D; 2，因为可以被 2 整除，所以次数 &#x3D; c &#x2F; 2</li><li>从 c &#x3D; 3 开始<ul><li>如果 c &#x3D; 3k，等同于 c % 3 &#x3D;&#x3D; 0，那么次数 &#x3D; k</li><li>如果 c &#x3D; 3k + 1，等同于 c % 3 &#x3D;&#x3D; 1，把他替换成 c &#x3D; 3k + 1 - 4 &#x3D; 3k - 3 &#x3D; 3(k - 1)，然后 4 还是要被 2 处理两次，所以最终次数 &#x3D; k - 1 + 2 &#x3D; k + 1</li><li>如果 c &#x3D; 3k + 2，等同于 c % 3 &#x3D;&#x3D; 2，那么次数 &#x3D; k + 1</li></ul></li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumRounds</span><span class="hljs-params">(<span class="hljs-type">int</span>[] tasks)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t : tasks) &#123;<br>            map.put(t, map.getOrDefault(t, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>) &#123;<br>res++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>res += count / <span class="hljs-number">3</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>res += (count - <span class="hljs-number">4</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;<br>res += (count - <span class="hljs-number">2</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>counting sort</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2389. Longest Subsequence With Limited Sum</title>
    <link href="/posts/1934906743.html"/>
    <url>/posts/1934906743.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums of length n, and an integer array queries of length m.</p><p>Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].</p><p>A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p><p>Example 1:<br>Input: nums &#x3D; [4,5,2,1], queries &#x3D; [3,10,21]<br>Output: [2,3,4]<br>Explanation: We answer the queries as follows:</p><ul><li>The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] &#x3D; 2.</li><li>The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] &#x3D; 3.</li><li>The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] &#x3D; 4.</li></ul><p>Example 2:<br>Input: nums &#x3D; [2,3,4,5], queries &#x3D; [1]<br>Output: [0]<br>Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] &#x3D; 0.</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>m &#x3D;&#x3D; queries.length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i], queries[i] &lt;&#x3D; 106</p><p>和有限的最长子序列。</p><blockquote>给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。<p>返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。</p><p>子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum">https://leetcode.cn/problems/longest-subsequence-with-limited-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题很好，虽然是简单题，但是考察了多个知识点，我这里提供一个排序 + 前缀和 + 二分的思路。</p><p>这道题问的满足条件的最长子序列的长度，但是这里的条件是子序列的和 &lt;&#x3D; target。因为找的是子序列 subsequence 的和，意味着满足条件的子序列中的元素可以<code>不连续</code>，既然不连续，那么也就意味着我们可以对 input 数组进行排序。排序的作用是为了之后我们可以开辟一个额外数组记录前缀和。所以这里我们先对 input 数组作排序和记录前缀和两项操作。</p><p>此时我们会得到一个前缀和数组 presum，注意这个数组中的元素是有序的，所以此时我们可以用二分法找到满足 &lt;&#x3D; queries[i] 的 index。</p><p><span style="color:red">以后记得看到子序列，也许是可以排序的，因为子序列不在意元素的相对顺序。</span></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - O(n) 扫描 queries 数组，O(logn) 用二分法找到每个 query 的位置<br>空间O(n) - prefix sum array</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] answerQueries(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] queries) &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> helper(presum, queries[i]);<br>            res[i] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                res = mid;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sort</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1760. Minimum Limit of Balls in a Bag</title>
    <link href="/posts/1251003120.html"/>
    <url>/posts/1251003120.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.</p><p>You can perform the following operation at most maxOperations times:</p><p>Take any bag of balls and divide it into two new bags with a positive number of balls.<br>For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.<br>Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.</p><p>Return the minimum possible penalty after performing the operations.</p><p>Example 1:<br>Input: nums &#x3D; [9], maxOperations &#x3D; 2<br>Output: 3<br>Explanation: </p><ul><li>Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -&gt; [6,3].</li><li>Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -&gt; [3,3,3].<br>The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.</li></ul><p>Example 2:<br>Input: nums &#x3D; [2,4,8,2], maxOperations &#x3D; 4<br>Output: 2<br>Explanation:</p><ul><li>Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -&gt; [2,4,4,4,2].</li><li>Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -&gt; [2,2,2,4,4,2].</li><li>Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2].</li><li>Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2].<br>The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.</li></ul><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; maxOperations, nums[i] &lt;&#x3D; 109</p><p>袋子里最少数目的球。</p><blockquote>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。<p>你可以进行如下操作至多 maxOperations 次：</p><p>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<br>比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br>你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。</p><p>请你返回进行上述操作后的最小开销。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag">https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分，而且是在答案上二分。因为题目给定了最多的操作次数，记为 maxOperations，所以我们的二分是在答案上二分 - 意思是用二分在 1 - Integer.MAX_VALUE 这个区间内尝试一个值，然后看看以这个值作为开销 penalty，所对应的操作次数是多少，如果这个操作次数超过了 maxOperations，就需要移动 left 指针，说明为了满足当前这个开销，操作次数超过上限了；反之移动 right 指针，说明开销可以试着更小一点。</p><p>这种题看似只能暴力解但是看数据范围一定过不去的，大概率要尝试二分，但是难点在于二分什么东西。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumSize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> maxOperations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> helper(mid, nums);<br><span class="hljs-keyword">if</span> (count &gt; maxOperations) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> op, <span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>count += (num - <span class="hljs-number">1</span>) / op;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1207. Unique Number of Occurrences</title>
    <link href="/posts/1634991093.html"/>
    <url>/posts/1634991093.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise.</p><p>Example 1:<br>Input: arr &#x3D; [1,2,2,1,1,3]<br>Output: true<br>Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</p><p>Example 2:<br>Input: arr &#x3D; [1,2]<br>Output: false</p><p>Example 3:<br>Input: arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]<br>Output: true</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; arr[i] &lt;&#x3D; 1000</p><p>独一无二的出现次数。</p><blockquote><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。<br>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/unique-number-of-occurrences">https://leetcode.cn/problems/unique-number-of-occurrences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目问的是独一无二的出现次数，那么我们首先需要用 hashmap 记录所有出现过的元素和他们各自的出现次数。然后我们需要用一个 hashset 去过滤 map.values()，看看哪个出现次数是唯一的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">uniqueOccurrences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br><br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map.get(key);<br><span class="hljs-keyword">if</span> (!set.add(val)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1758. Minimum Changes To Make Alternating Binary String</title>
    <link href="/posts/1170446735.html"/>
    <url>/posts/1170446735.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s consisting only of the characters ‘0’ and ‘1’. In one operation, you can change any ‘0’ to ‘1’ or vice versa.</p><p>The string is called alternating if no two adjacent characters are equal. For example, the string “010” is alternating, while the string “0100” is not.</p><p>Return the minimum number of operations needed to make s alternating.</p><p>Example 1:<br>Input: s &#x3D; “0100”<br>Output: 1<br>Explanation: If you change the last character to ‘1’, s will be “0101”, which is alternating.</p><p>Example 2:<br>Input: s &#x3D; “10”<br>Output: 0<br>Explanation: s is already alternating.</p><p>Example 3:<br>Input: s &#x3D; “1111”<br>Output: 2<br>Explanation: You need two operations to reach “0101” or “1010”.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s[i] is either ‘0’ or ‘1’.</p><p>生成交替二进制字符串的最少操作数.</p><blockquote><p>给你一个仅由字符 ‘0’ 和 ‘1’ 组成的字符串 s 。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。<br>交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 “010” 是交替字符串，而字符串 “0100” 不是。<br>返回使 s 变成 交替字符串 所需的 最少 操作数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string">https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>这道题算是字符串类型的题目。我自己做的时候一开始没有想到太简洁的方法，所以分别模拟了 0101 和 1010 两种字符串，然后和 input 字符串比较，看看 diff1 小还是 diff2 小，小的那个就是最少操作数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] inputArray = s.toCharArray();<br>        <span class="hljs-type">char</span>[] first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (zero) &#123;<br>                first[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                first[i] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125;<br>            zero = !zero;<br>        &#125;<br><br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span>[] second = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (one) &#123;<br>                second[i] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                second[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            one = !one;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inputArray[i] != first[i]) &#123;<br>                count1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (inputArray[i] != second[i]) &#123;<br>                count2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(count1, count2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>看了评论区的<a href="https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/solutions/1996808/by-ac_oier-gclh/">这个帖子</a>，感觉最近还是题刷少了。他的思路是，最理想情况下，字符串应该是类似 01010101 这样的排列。在这种排列中，每个位置上的字符串与其下标 index 有如下关系，</p><blockquote><p>index  &#x3D; 0, 1, 2, 3, 4 % 2<br>char   &#x3D; 0, 1, 0, 1, 0</p></blockquote><p>所以我们可以遍历一遍 input 字符串，看一下每个位置的下标 index % 2 之后是否等于同位置上的字符串，记录全局不同的个数 diff。注意因为字符串可以是 0101 类型，也可以是 1010 类型的，所以我们需要看两种情况哪一种情况最优。假如 0101 类型需要操作的次数是 diff 的话，那么 1010 类型需要操作的次数 &#x3D; 字符串长度 len - diff。比较这两者谁更小即可。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>diff++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> Math.min(diff, n - diff);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2225. Find Players With Zero or One Losses</title>
    <link href="/posts/2127834529.html"/>
    <url>/posts/2127834529.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array matches where matches[i] &#x3D; [winneri, loseri] indicates that the player winneri defeated player loseri in a match.</p><p>Return a list answer of size 2 where:<br>answer[0] is a list of all players that have not lost any matches.<br>answer[1] is a list of all players that have lost exactly one match.<br>The values in the two lists should be returned in increasing order.</p><p>Note:<br>You should only consider the players that have played at least one match.<br>The testcases will be generated such that no two matches will have the same outcome.</p><p>Example 1:<br>Input: matches &#x3D; [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]<br>Output: [[1,2,10],[4,5,7,8]]<br>Explanation:<br>Players 1, 2, and 10 have not lost any matches.<br>Players 4, 5, 7, and 8 each have lost one match.<br>Players 3, 6, and 9 each have lost two matches.<br>Thus, answer[0] &#x3D; [1,2,10] and answer[1] &#x3D; [4,5,7,8].</p><p>Example 2:<br>Input: matches &#x3D; [[2,3],[1,3],[5,4],[6,4]]<br>Output: [[1,2,5,6],[]]<br>Explanation:<br>Players 1, 2, 5, and 6 have not lost any matches.<br>Players 3 and 4 each have lost two matches.<br>Thus, answer[0] &#x3D; [1,2,5,6] and answer[1] &#x3D; [].</p><p>Constraints:<br>1 &lt;&#x3D; matches.length &lt;&#x3D; 105<br>matches[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; winneri, loseri &lt;&#x3D; 105<br>winneri !&#x3D; loseri<br>All matches[i] are unique.</p><p>找出输掉零场或一场比赛的玩家。</p><blockquote>给你一个整数数组 matches 其中 matches[i] = [winner, loser] 表示在一场比赛中 winner 击败了 loser 。<p>返回一个长度为 2 的列表 answer ：<br>answer[0] 是所有 没有 输掉任何比赛的玩家列表。<br>answer[1] 是所有恰好输掉 一场 比赛的玩家列表。<br>两个列表中的值都应该按 递增 顺序返回。</p><p>注意：<br>只考虑那些参与 至少一场 比赛的玩家。<br>生成的测试用例保证 不存在 两场比赛结果 相同 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-players-with-zero-or-one-losses">https://leetcode.cn/problems/find-players-with-zero-or-one-losses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不难，细心就行。思路是用哈希表存储所有出现过的玩家分别输了几场比赛，赢的场次不需要记录。注意返回之前需要把两个 sublist 分别排序。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findWinners</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matches)</span> &#123;<br>        HashMap&lt;Integer, <span class="hljs-type">int</span>[]&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] match : matches) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">winner</span> <span class="hljs-operator">=</span> match[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">loser</span> <span class="hljs-operator">=</span> match[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!map.containsKey(winner)) &#123;<br>                map.put(winner, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]);<br>            &#125;<br>            map.get(winner)[<span class="hljs-number">0</span>]++;<br>            <span class="hljs-keyword">if</span> (!map.containsKey(loser)) &#123;<br>                map.put(loser, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]);<br>            &#125;<br>            map.get(loser)[<span class="hljs-number">1</span>]++;<br>        &#125;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> player : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(player)[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>                list1.add(player);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.get(player)[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                list2.add(player);<br>            &#125;<br>        &#125;<br>        Collections.sort(list1);<br>        Collections.sort(list2);<br>        res.add(list1);<br>        res.add(list2);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2133. Check if Every Row and Column Contains All Numbers</title>
    <link href="/posts/1503042341.html"/>
    <url>/posts/1503042341.html</url>
    
    <content type="html"><![CDATA[<p>An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).</p><p>Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png" alt="Example 1"><br>Input: matrix &#x3D; [[1,2,3],[3,1,2],[2,3,1]]<br>Output: true<br>Explanation: In this case, n &#x3D; 3, and every row and column contains the numbers 1, 2, and 3.<br>Hence, we return true.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png" alt="Example 2"><br>Input: matrix &#x3D; [[1,1,1],[1,2,3],[1,2,3]]<br>Output: false<br>Explanation: In this case, n &#x3D; 3, but the first row and the first column do not contain the numbers 2 or 3.<br>Hence, we return false.</p><p>Constraints:<br>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; matrix[i][j] &lt;&#x3D; n</p><p>检查是否每一行每一列都包含全部整数。</p><blockquote><p>对一个大小为 n x n 的矩阵而言，如果其每一行和每一列都包含从 1 到 n 的 全部 整数（含 1 和 n），则认为该矩阵是一个 有效 矩阵。</p><p>给你一个大小为 n x n 的整数矩阵 matrix ，请你判断矩阵是否为一个有效矩阵：如果是，返回 true ；否则，返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers">https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题跟 Sudoku 几乎一样，但是简单一些，只需要检查同一行和同一列。这里我创建两个二维数组来记录每一行和每一列是否有重复元素。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkValid</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">boolean</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">boolean</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                <span class="hljs-keyword">if</span> (rows[i][num - <span class="hljs-number">1</span>] || cols[num - <span class="hljs-number">1</span>][j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    rows[i][num - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    cols[num - <span class="hljs-number">1</span>][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">36. Valid Sudoku<br>37. Sudoku Solver<br>2133. Check if Every Row and Column Contains All Numbers<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1768. Merge Strings Alternately</title>
    <link href="/posts/493219565.html"/>
    <url>/posts/493219565.html</url>
    
    <content type="html"><![CDATA[<p>You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.</p><p>Return the merged string.</p><p>Example 1:<br>Input: word1 &#x3D; “abc”, word2 &#x3D; “pqr”<br>Output: “apbqcr”<br>Explanation: The merged string will be merged as so:<br>word1:  a   b   c<br>word2:    p   q   r<br>merged: a p b q c r</p><p>Example 2:<br>Input: word1 &#x3D; “ab”, word2 &#x3D; “pqrs”<br>Output: “apbqrs”<br>Explanation: Notice that as word2 is longer, “rs” is appended to the end.<br>word1:  a   b<br>word2:    p   q   r   s<br>merged: a p b q   r   s</p><p>Example 3:<br>Input: word1 &#x3D; “abcd”, word2 &#x3D; “pq”<br>Output: “apbqcd”<br>Explanation: Notice that as word1 is longer, “cd” is appended to the end.<br>word1:  a   b   c   d<br>word2:    p   q<br>merged: a p b q c   d</p><p>Constraints:<br>1 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 100<br>word1 and word2 consist of lowercase English letters.</p><p>交替合并字符串。</p><blockquote>给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。<p>返回 合并后的字符串。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/merge-strings-alternately">https://leetcode.cn/problems/merge-strings-alternately</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题考察字符串的基本操作。我直接给代码。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m+n) - 需要合并两个字符串<br>空间O(m+n) - 最后返回的字符串长度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">mergeAlternately</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (word1 == <span class="hljs-literal">null</span> || word1.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> word2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (word2 == <span class="hljs-literal">null</span> || word2.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> word1;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m || j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; m) &#123;<br>                sb.append(word1.charAt(i++));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &lt; n) &#123;<br>                sb.append(word2.charAt(j++));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1700. Number of Students Unable to Eat Lunch</title>
    <link href="/posts/3320885080.html"/>
    <url>/posts/3320885080.html</url>
    
    <content type="html"><![CDATA[<p>The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.</p><p>The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:<br>If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.<br>Otherwise, they will leave it and go to the queue’s end.<br>This continues until none of the queue students want to take the top sandwich and are thus unable to eat.</p><p>You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i &#x3D; 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j &#x3D; 0 is the front of the queue). Return the number of students that are unable to eat.</p><p>Example 1:<br>Input: students &#x3D; [1,1,0,0], sandwiches &#x3D; [0,1,0,1]<br>Output: 0<br>Explanation:</p><ul><li>Front student leaves the top sandwich and returns to the end of the line making students &#x3D; [1,0,0,1].</li><li>Front student leaves the top sandwich and returns to the end of the line making students &#x3D; [0,0,1,1].</li><li>Front student takes the top sandwich and leaves the line making students &#x3D; [0,1,1] and sandwiches &#x3D; [1,0,1].</li><li>Front student leaves the top sandwich and returns to the end of the line making students &#x3D; [1,1,0].</li><li>Front student takes the top sandwich and leaves the line making students &#x3D; [1,0] and sandwiches &#x3D; [0,1].</li><li>Front student leaves the top sandwich and returns to the end of the line making students &#x3D; [0,1].</li><li>Front student takes the top sandwich and leaves the line making students &#x3D; [1] and sandwiches &#x3D; [1].</li><li>Front student takes the top sandwich and leaves the line making students &#x3D; [] and sandwiches &#x3D; [].<br>Hence all students are able to eat.</li></ul><p>Example 2:<br>Input: students &#x3D; [1,1,1,0,0,1], sandwiches &#x3D; [1,0,0,0,1,1]<br>Output: 3</p><p>Constraints:<br>1 &lt;&#x3D; students.length, sandwiches.length &lt;&#x3D; 100<br>students.length &#x3D;&#x3D; sandwiches.length<br>sandwiches[i] is 0 or 1.<br>students[i] is 0 or 1.</p><p>无法吃午餐的学生数量。</p><blockquote>学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：<p>如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。<br>否则，这名学生会 放弃这个三明治 并回到队列的尾部。<br>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p><p>给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i​​​​​​ 个三明治的类型（i &#x3D; 0 是栈的顶部）， students[j] 是初始队列里第 j​​​​​​ 名学生对三明治的喜好（j &#x3D; 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch">https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题 tag 是简单题，但是不小心就容易想复杂了，值得思考。</p><p>题意不难理解，students 数组给了每个学生的需求，sandwiches 数组也给了不同 sandwiches 的数量。如果按照题意的描述，可能我们需要一个队列来存储还未吃上饭的同学和一个栈来存储还未被分发出去的三明治。</p><p>这里我们做进一步思考，注意到如果栈顶的三明治没有被当前学生拿走，学生可以到队尾，但是三明治不能动，需要看下一个学生是否需要当前这个类型的三明治。我们可以用一个 count 数组统计一下需要圆形 0 和方形 1 的三明治各有几个人。接着我们遍历三明治数组，如果当前的三明治依然有人需要，那么我们就把对应的需求 - 1；如果当前这个三明治没有人要，我们直接就可以返回了，因为学生再绕多少圈，当前这个三明治都无法被拿走。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1) - 数组长度只有2，可以忽略不计</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countStudents</span><span class="hljs-params">(<span class="hljs-type">int</span>[] students, <span class="hljs-type">int</span>[] sandwiches)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">circular</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> student : students) &#123;<br>            <span class="hljs-keyword">if</span> (student == <span class="hljs-number">0</span>) &#123;<br>                circular++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">square</span> <span class="hljs-operator">=</span> students.length - circular;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sandwiches.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> sandwiches[i];<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span> &amp;&amp; circular &gt; <span class="hljs-number">0</span>) &#123;<br>                circular--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span> &amp;&amp; square &gt; <span class="hljs-number">0</span>) &#123;<br>                square--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> circular + square;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>stack</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1328. Break a Palindrome</title>
    <link href="/posts/4197245046.html"/>
    <url>/posts/4197245046.html</url>
    
    <content type="html"><![CDATA[<p>Given a palindromic string of lowercase English letters palindrome, replace exactly one character with any lowercase English letter so that the resulting string is not a palindrome and that it is the lexicographically smallest one possible.</p><p>Return the resulting string. If there is no way to replace a character to make it not a palindrome, return an empty string.</p><p>A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. For example, “abcc” is lexicographically smaller than “abcd” because the first position they differ is at the fourth character, and ‘c’ is smaller than ‘d’.</p><p>Example 1:<br>Input: palindrome &#x3D; “abccba”<br>Output: “aaccba”<br>Explanation: There are many ways to make “abccba” not a palindrome, such as “zbccba”, “aaccba”, and “abacba”.<br>Of all the ways, “aaccba” is the lexicographically smallest.</p><p>Example 2:<br>Input: palindrome &#x3D; “a”<br>Output: “”<br>Explanation: There is no way to replace a single character to make “a” not a palindrome, so return an empty string.</p><p>Constraints:<br>1 &lt;&#x3D; palindrome.length &lt;&#x3D; 1000<br>palindrome consists of only lowercase English letters.</p><p>破坏回文串。</p><blockquote><p>给你一个由小写英文字母组成的回文字符串 palindrome ，请你将其中 一个 字符用任意小写英文字母替换，使得结果字符串的 字典序最小 ，且 不是 回文串。</p><p>请你返回结果字符串。如果无法做到，则返回一个 空串 。</p><p>如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符严格小于 b 中的对应字符。例如，”abcc” 字典序比 “abcd” 小，因为不同的第一个位置是在第四个字符，显然 ‘c’ 比 ‘d’ 小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/break-a-palindrome">https://leetcode.cn/problems/break-a-palindrome</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的 input 给的是一个合法的回文串，我们要做的是修改其中的一个字母，从而使得修改过后的字符串不是回文串同时字典序最小。</p><p>我们回顾回文串的定义，发现回文串只有两种情况，一种是 abba，一种是 aba。同时既然需要做到修改之后字典序最小，那么我们只看字符串的左半边就好了，看右半边是无法做到修改后的结果是字典序最小的。这道题我们需要注意两个 corner case，一个是如果 input 中字母都是a，类似 aaaaaaa 的话，那么我们只能通过把最后一个 a 改成 b 来保证修改结果字典序最小。另外一个 case 是比如例子二，如果不能通过修改字母来破坏 input 字符串的回文，那么我们只能将他改成空字符串返回。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - char array</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">breakPalindrome</span><span class="hljs-params">(String palindrome)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> palindrome.length();<br>        <span class="hljs-type">char</span>[] letters = palindrome.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> letters[left];<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                letters[left] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(letters);<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br><br>        letters[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(letters);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2007. Find Original Array From Doubled Array</title>
    <link href="/posts/2604738238.html"/>
    <url>/posts/2604738238.html</url>
    
    <content type="html"><![CDATA[<p>An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.</p><p>Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.</p><p>Example 1:<br>Input: changed &#x3D; [1,3,4,2,6,8]<br>Output: [1,3,4]<br>Explanation: One possible original array could be [1,3,4]:</p><ul><li>Twice the value of 1 is 1 * 2 &#x3D; 2.</li><li>Twice the value of 3 is 3 * 2 &#x3D; 6.</li><li>Twice the value of 4 is 4 * 2 &#x3D; 8.<br>Other original arrays could be [4,3,1] or [3,1,4].</li></ul><p>Example 2:<br>Input: changed &#x3D; [6,3,0,1]<br>Output: []<br>Explanation: changed is not a doubled array.</p><p>Example 3:<br>Input: changed &#x3D; [1]<br>Output: []<br>Explanation: changed is not a doubled array. </p><p>Constraints:<br>1 &lt;&#x3D; changed.length &lt;&#x3D; 105<br>0 &lt;&#x3D; changed[i] &lt;&#x3D; 105</p><p>从双倍数组中还原原数组。</p><blockquote>一个整数数组 original 可以转变成一个 双倍 数组 changed ，转变方式为将 original 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。<p>给你一个数组 changed ，如果 change 是 双倍 数组，那么请你返回 original数组，否则请返回空数组。original 的元素可以以 任意 顺序返回。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-original-array-from-doubled-array">https://leetcode.cn/problems/find-original-array-from-doubled-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道贪心的题目，我参考了<a href="https://leetcode.com/problems/find-original-array-from-doubled-array/discuss/1470959/JavaC++Python-Match-from-the-Smallest-or-Biggest-100">这个帖子</a>，思路很清晰。题目给了一个 original 数组和一个 changed 数组，其中 changed 数组理应是 original 数组中每个元素乘以二的结果，请你判断 changed 数组是不是真的符合这个规则。</p><p>这道题一定要对 changed 数组排序，或者起码要对 changed 数组中涉及到的每个不同元素进行排序。举个例子，比如 [2, 4, 4, 8] 这个数组，我只有知道最小的元素是 2，我才能确定 4 到底是某个数字的两倍，还是说我需要去找 4 自身的两倍。按照这个例子，我们可以分别找到2和其自身的两倍（4）；同时我们遇到第二个 4 的时候，因为现在只剩下一个 4 了，所以他只能被当做那个小的数字，去找是否有一个 8 能与之对应。</p><p>具体做法上，这里我用一个 hashmap 记录所有不同元素的出现次数，然后对所有 unique 的 key 进行遍历，看看每个 key 是否能找到他自身的两倍（key + key），如果找不到，或者 key 出现的次数大于 key + key 的话，则返回空的数组。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n + klogk) - 需要对 input 数组排序<br>空间O(n) - hashmap</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findOriginalArray(<span class="hljs-type">int</span>[] changed) &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (changed == <span class="hljs-literal">null</span> || changed.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> changed.length;<br>        Arrays.sort(changed);<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : changed) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : changed) &#123;<br>            <span class="hljs-keyword">if</span> (map.get(num) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(num * <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br>            res.add(num);<br>            map.put(num, map.get(num) - <span class="hljs-number">1</span>);<br>map.put(num * <span class="hljs-number">2</span>, map.get(num * <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.stream().mapToInt(i -&gt; i).toArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1608. Special Array With X Elements Greater Than or Equal X</title>
    <link href="/posts/3793951166.html"/>
    <url>/posts/3793951166.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.</p><p>Notice that x does not have to be an element in nums.</p><p>Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.</p><p>Example 1:<br>Input: nums &#x3D; [3,5]<br>Output: 2<br>Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.</p><p>Example 2:<br>Input: nums &#x3D; [0,0]<br>Output: -1<br>Explanation: No numbers fit the criteria for x.<br>If x &#x3D; 0, there should be 0 numbers &gt;&#x3D; x, but there are 2.<br>If x &#x3D; 1, there should be 1 number &gt;&#x3D; x, but there are 0.<br>If x &#x3D; 2, there should be 2 numbers &gt;&#x3D; x, but there are 0.<br>x cannot be greater since there are only 2 numbers in nums.</p><p>Example 3:<br>Input: nums &#x3D; [0,4,3,0,4]<br>Output: 3<br>Explanation: There are 3 values that are greater than or equal to 3.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><p>特殊数组的特征值。</p><blockquote>给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。<p>注意： x 不必 是 nums 的中的元素。</p><p>如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x">https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-暴力解"><a href="#思路一-暴力解" class="headerlink" title="思路一 - 暴力解"></a>思路一 - 暴力解</h2><p>首先是暴力解，因为题目给定了 nums 数组里所有数字的范围，那么也就等同于告诉你了 X 的范围（0 - 1000）。所以我们从 0 到 1000 一个个去试探，看看当 X 等于某个数字 i 的时候，数组是否满足有 i 个数字大于等于 x。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">specialArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (candidate &lt;= <span class="hljs-number">1000</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (num &gt;= candidate) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == candidate) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            candidate++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">return</span> candidate;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-counting-sort"><a href="#思路二-counting-sort" class="headerlink" title="思路二 - counting sort"></a>思路二 - counting sort</h2><p>再来是 counting sort。用一个额外数组记录每个数字出现了多少次，然后从大到小扫描并开始累加已经出现的数字的个数，记为 sum，看看是否存在某个数字 i &#x3D; sum。从大到小扫描是因为我们需要记录有多少个大于等于 candidate 的数字。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">specialArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            map[num]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            sum += map[i];<br>            <span class="hljs-keyword">if</span> (sum == i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>counting sort</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1184. Distance Between Bus Stops</title>
    <link href="/posts/149749656.html"/>
    <url>/posts/149749656.html</url>
    
    <content type="html"><![CDATA[<p>A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.</p><p>The bus goes along both directions i.e. clockwise and counterclockwise.</p><p>Return the shortest distance between the given start and destination stops.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/09/03/untitled-diagram-1.jpg" alt="Example 1"><br>Input: distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 1<br>Output: 1<br>Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/09/03/untitled-diagram-1-1.jpg" alt="Example 2"><br>Input: distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 2<br>Output: 3<br>Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2019/09/03/untitled-diagram-1-2.jpg" alt="Example 3"><br>Input: distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 3<br>Output: 4<br>Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 10^4<br>distance.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; start, destination &lt; n<br>0 &lt;&#x3D; distance[i] &lt;&#x3D; 10^4</p><p>公交站间的距离。</p><blockquote>环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。<p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p><p>返回乘客从出发点 start 到目的地 destination 之间的最短距离。 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/distance-between-bus-stops">https://leetcode.cn/problems/distance-between-bus-stops</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目不难，但是做法很巧妙。题目要求计算的是两点之间的最短距离，最短距离的计算有两种方式，一种是顺时针，一种是逆时针。顺时针很好算，逆时针的算法是整圈的距离 - 顺时针的距离。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distanceBetweenBusStops</span><span class="hljs-params">(<span class="hljs-type">int</span>[] distance, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> destination)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dis : distance) &#123;<br>            total += dis;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (start &gt; destination) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> start;<br>            start = destination;<br>            destination = temp;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dis1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; destination; i++) &#123;<br>            dis1 += distance[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.min(dis1, total - dis1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 828. Count Unique Characters of All Substrings of a Given String</title>
    <link href="/posts/3993687843.html"/>
    <url>/posts/3993687843.html</url>
    
    <content type="html"><![CDATA[<p>Let’s define a function countUniqueChars(s) that returns the number of unique characters in s.</p><p>For example, calling countUniqueChars(s) if s &#x3D; “LEETCODE” then “L”, “T”, “C”, “O”, “D” are the unique characters since they appear only once in s, therefore countUniqueChars(s) &#x3D; 5.<br>Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer.</p><p>Notice that some substrings can be repeated so in this case you have to count the repeated ones too.</p><p>Example 1:<br>Input: s &#x3D; “ABC”<br>Output: 10<br>Explanation: All possible substrings are: “A”,”B”,”C”,”AB”,”BC” and “ABC”.<br>Every substring is composed with only unique letters.<br>Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 &#x3D; 10</p><p>Example 2:<br>Input: s &#x3D; “ABA”<br>Output: 8<br>Explanation: The same as example 1, except countUniqueChars(“ABA”) &#x3D; 1.</p><p>Example 3:<br>Input: s &#x3D; “LEETCODE”<br>Output: 92</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of uppercase English letters only.</p><p>统计子串中的唯一字符。</p><blockquote><p>我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。<br>例如：s &#x3D; “LEETCODE” ，则其中 “L”, “T”,”C”,”O”,”D” 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) &#x3D; 5 。<br>本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。<br>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们看一下暴力解。对于 input 字符串，我们需要找到他所有长度不同的子串，这个时间复杂度就是O(n^2)，我们还要看一下每个子串内只出现一次的字母有几个，这个复杂度是O(n)，总体复杂度是O(n^3)。</p><p>这里我提供一个很巧妙的做法，我参考了<a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/128952/JavaC++Python-One-pass-O(N)">这个帖子</a>。与其去找不同子串并计算不同子串里 unique 的字母个数是多少，我们可以反过来思考，对于每个字母而言，我们可以去计算包含这个字母且这个字母只出现一次的子串有多少。只有保证当前字母只出现一次，才满足题目中 countUniqueChars() 函数的定义。</p><p>对于任意一个字母，在 input 字符串中很可能是出现了多次的。假如对于我们当前遇到的字母 X，如果我们能找到 X 在 input 字符串中上一次出现的位置 j 和下一次出现的位置 k，那么包含当前位置 i 且满足题意的子串个数应该是 (i - j) * (k - i)。</p><p>具体做法如下。我创建了一个二维数组，需要记录每个字母前两次出现位置的 index。开始遍历 input 字符串，当遇到某个字母的时候，我们把当前位置当做 k，我们去二维数组里看一下是否存在 index i 和 j，如果存在，我们就按照上面那个公式去计算一下包含当前位置上字母的子串有多少。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniqueLetterString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            Arrays.fill(index[i], -<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;A&#x27;</span>;<br>            res = (res + (i - index[c][<span class="hljs-number">1</span>]) * (index[c][<span class="hljs-number">1</span>] - index[c][<span class="hljs-number">0</span>]) % MOD) % MOD;<br>            index[c] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;index[c][<span class="hljs-number">1</span>], i&#125;;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">26</span>; c++) &#123;<br>            res = (res + (len - index[c][<span class="hljs-number">1</span>]) * (index[c][<span class="hljs-number">1</span>] - index[c][<span class="hljs-number">0</span>]) % MOD) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 729. My Calendar I</title>
    <link href="/posts/1564004087.html"/>
    <url>/posts/1564004087.html</url>
    
    <content type="html"><![CDATA[<p>You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.</p><p>A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).</p><p>The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start &lt;&#x3D; x &lt; end.</p><p>Implement the MyCalendar class:<br>MyCalendar() Initializes the calendar object.<br>boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.</p><p>Example 1:<br>Input<br>[“MyCalendar”, “book”, “book”, “book”]<br>[[], [10, 20], [15, 25], [20, 30]]<br>Output<br>[null, true, false, true]</p><p>Explanation<br>MyCalendar myCalendar &#x3D; new MyCalendar();<br>myCalendar.book(10, 20); &#x2F;&#x2F; return True<br>myCalendar.book(15, 25); &#x2F;&#x2F; return False, It can not be booked because time 15 is already booked by another event.<br>myCalendar.book(20, 30); &#x2F;&#x2F; return True, The event can be booked, as the first event takes every time less than 20, but not including 20.</p><p>Constraints:<br>0 &lt;&#x3D; start &lt; end &lt;&#x3D; 109<br>At most 1000 calls will be made to book.</p><p>我的日程安排表 I。</p><blockquote>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。</p><p>日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;&#x3D; x &lt; end 。</p><p>实现 MyCalendar 类：</p><p>MyCalendar() 初始化日历对象。<br>boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/my-calendar-i">https://leetcode.cn/problems/my-calendar-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目给的是一些日程安排，以 start 和 end 表示，应该是按数据流给出的，请你判断是否有安排冲突。</p><p>这道题我提供一个 treemap 的解法。这道题有点像扫描线那一类的题目，但是注意题目给的是数据流，数据不是一次性给出的。这里我们创建一个treemap&lt;start, end&gt;，存每一个安排的开始时间和结束时间。每当进来一个新的日程安排的时候（我们设这个日程安排为 A），我们用 A 的 start 去找 treemap 是否存在一个 floorKey，且这个 floorKey 的 end 是大于 A 的 start 的，如果有，就说明之前有一个安排的结束时间大于目前这个安排 A 的开始时间，冲突。</p><p>我们再用 A 的 start 去找 treemap 是否存在一个 ceilingKey，这个 ceilingKey 是另外一个安排 B 的开始时间，如果 B 存在且 B 的结束时间小于 A 的结束时间，也说明是冲突。</p><p>这两种冲突都不存在，我们才可以将 A 放入 treemap。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendar</span> &#123;<br>    TreeMap&lt;Integer, Integer&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendar</span><span class="hljs-params">()</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">floorKey</span> <span class="hljs-operator">=</span> map.floorKey(start);<br>        <span class="hljs-keyword">if</span> (floorKey != <span class="hljs-literal">null</span> &amp;&amp; map.get(floorKey) &gt; start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">ceilingKey</span> <span class="hljs-operator">=</span> map.ceilingKey(start);<br>        <span class="hljs-keyword">if</span> (ceilingKey != <span class="hljs-literal">null</span> &amp;&amp; ceilingKey &lt; end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        map.put(start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCalendar object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCalendar obj = new MyCalendar();</span><br><span class="hljs-comment"> * boolean param_1 = obj.book(start,end);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>treemap</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2116. Check if a Parentheses String Can Be Valid</title>
    <link href="/posts/1409866939.html"/>
    <url>/posts/1409866939.html</url>
    
    <content type="html"><![CDATA[<p>A parentheses string is a non-empty string consisting only of ‘(‘ and ‘)’. It is valid if any of the following conditions is true:<br>It is ().<br>It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.<br>It can be written as (A), where A is a valid parentheses string.<br>You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of ‘0’s and ‘1’s. For each index i of locked,</p><p>If locked[i] is ‘1’, you cannot change s[i].<br>But if locked[i] is ‘0’, you can change s[i] to either ‘(‘ or ‘)’.<br>Return true if you can make s a valid parentheses string. Otherwise, return false.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/11/06/eg1.png" alt="Example 1"><br>Input: s &#x3D; “))()))”, locked &#x3D; “010100”<br>Output: true<br>Explanation: locked[1] &#x3D;&#x3D; ‘1’ and locked[3] &#x3D;&#x3D; ‘1’, so we cannot change s[1] or s[3].<br>We change s[0] and s[4] to ‘(‘ while leaving s[2] and s[5] unchanged to make s valid.</p><p>Example 2:<br>Input: s &#x3D; “()()”, locked &#x3D; “0000”<br>Output: true<br>Explanation: We do not need to make any changes because s is already valid.</p><p>Example 3:<br>Input: s &#x3D; “)”, locked &#x3D; “0”<br>Output: false<br>Explanation: locked permits us to change s[0].<br>Changing s[0] to either ‘(‘ or ‘)’ will not make s valid.</p><p>Constraints:<br>n &#x3D;&#x3D; s.length &#x3D;&#x3D; locked.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>s[i] is either ‘(‘ or ‘)’.<br>locked[i] is either ‘0’ or ‘1’.</p><p>判断一个括号字符串是否有效。</p><blockquote>一个括号字符串是只由 '(' 和 ')' 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：<p>字符串为 ().<br>它可以表示为 AB（A 与 B 连接），其中A 和 B 都是有效括号字符串。<br>它可以表示为 (A) ，其中 A 是一个有效括号字符串。<br>给你一个括号字符串 s 和一个字符串 locked ，两者长度都为 n 。locked 是一个二进制字符串，只包含 ‘0’ 和 ‘1’ 。对于 locked 中 每一个 下标 i ：</p><p>如果 locked[i] 是 ‘1’ ，你 不能 改变 s[i] 。<br>如果 locked[i] 是 ‘0’ ，你 可以 将 s[i] 变为 ‘(‘ 或者 ‘)’ 。<br>如果你可以将 s 变为有效括号字符串，请你返回 true ，否则返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid">https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遇到括号配对的题，大概率会涉及到 stack，以及需要从左往右 + 从右往左扫两遍。这么做的目的是抓到多余的左括号和多余的右括号。这道题的思路也很接近，不过这道题多给了一个数组 locked，表示可以改动的括号的方向。我们的做法依然还是扫两遍，第一遍我们从左往右扫描，扫描的时候我们用一个变量 count 统计左括号和可以改动的括号（locked.charAt(i) &#x3D;&#x3D; 0）的数量，这样当我们遇到右括号的时候，我们可以把左括号抵消。当左括号被抵消完毕之后，我们可以再用那些可以改动的括号来抵消更多的右括号，直到那些可以改动的括号被用完为止。</p><p>第二遍从右往左扫描的时候，我们用变量 count 统计右括号和可以改动的括号（locked.charAt(i) &#x3D;&#x3D; 0）的数量，这样当我们遇到左括号的时候，我们可以把右括号抵消。思路跟第一遍一样只是括号方向相反。</p><p>最后还有一个例外情况是如果统计到的半括号 + 可以改动的半括号的数量是奇数，就说明括号是无法成对的，就返回 false。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canBeValid</span><span class="hljs-params">(String s, String locked)</span> &#123;<br>        <span class="hljs-type">char</span>[] words = s.toCharArray();<br>        <span class="hljs-type">char</span>[] lock = locked.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-comment">// 遇到左括号或者当前位置是可以修改的，则count++</span><br><span class="hljs-comment">// 如果当前位置是右括号，则count--</span><br>            <span class="hljs-keyword">if</span> (words[i] == <span class="hljs-string">&#x27;(&#x27;</span> || lock[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (words[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-comment">// 遇到右括号或者当前位置是可以修改的，则count++</span><br><span class="hljs-comment">// 如果当前位置是左括号，则count--</span><br>            <span class="hljs-keyword">if</span> (words[i] == <span class="hljs-string">&#x27;)&#x27;</span> || lock[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (words[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 475. Heaters</title>
    <link href="/posts/3502958779.html"/>
    <url>/posts/3502958779.html</url>
    
    <content type="html"><![CDATA[<p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.</p><p>Every house can be warmed, as long as the house is within the heater’s warm radius range.</p><p>Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.</p><p>Notice that all the heaters follow your radius standard, and the warm radius will the same.</p><p>Example 1:<br>Input: houses &#x3D; [1,2,3], heaters &#x3D; [2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p><p>Example 2:<br>Input: houses &#x3D; [1,2,3,4], heaters &#x3D; [1,4]<br>Output: 1<br>Explanation: The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.</p><p>Example 3:<br>Input: houses &#x3D; [1,5], heaters &#x3D; [2]<br>Output: 3</p><p>Constraints:<br>1 &lt;&#x3D; houses.length, heaters.length &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; houses[i], heaters[i] &lt;&#x3D; 109</p><p>供暖器。</p><blockquote><p>冬季已经来临。你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p><p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p><p>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p><p>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/heaters">https://leetcode.cn/problems/heaters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-双指针"><a href="#思路一-双指针" class="headerlink" title="思路一 - 双指针"></a>思路一 - 双指针</h2><p>首先是双指针的思路，两个指针是同向的，都是从左往右走。对于双指针的做法，需要对两个 input 数组都进行排序，这样当我们用两个指针去分别遍历 houses 数组和 heaters 数组的时候，对于每一个 house，我们要看到底是当前这个 heater 离得近还是下一个 heater 离得近，如果一直是下一个 heater 离得近则 heater 的指针一直往前走。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn) - 极端情况<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRadius</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span>[] heaters)</span> &#123;<br>        Arrays.sort(houses);<br>        Arrays.sort(heaters);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> house : houses) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> Math.abs(house - heaters[i]);<br>            <span class="hljs-comment">// 如果下一个heater离得近，则i++</span><br>            <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; heaters.length &amp;&amp; Math.abs(house - heaters[i + <span class="hljs-number">1</span>]) &lt;= Math.abs(house - heaters[i])) &#123;<br>                i++;<br>                dist = Math.min(dist, Math.abs(house - heaters[i]));<br>            &#125;<br>            res = Math.max(res, dist);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-二分答案-双指针"><a href="#思路二-二分答案-双指针" class="headerlink" title="思路二 - 二分答案 + 双指针"></a>思路二 - 二分答案 + 双指针</h2><p>另一种思路是二分法。这里我们需要对 houses 和 heaters 分别排序。这里我们二分的是一个合理的半径。对于某个找到的半径，我们去试探，看是否这个半径能满足所有房屋的供暖。如果能满足，尽量移动右指针去缩小这个半径；如果不能满足，则移动左指针去增大这个半径。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRadius</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span>[] heaters)</span> &#123;<br>        Arrays.sort(houses);<br>        Arrays.sort(heaters);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (helper(houses, heaters, mid)) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span>[] heaters, <span class="hljs-type">int</span> dis)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> houses.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heaters.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; houses[i] &gt;= heaters[j] - dis &amp;&amp; houses[i] &lt;= heaters[j] + dis) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i == m) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2016. Maximum Difference Between Increasing Elements</title>
    <link href="/posts/3803496453.html"/>
    <url>/posts/3803496453.html</url>
    
    <content type="html"><![CDATA[<p>Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 &lt;&#x3D; i &lt; j &lt; n and nums[i] &lt; nums[j].</p><p>Return the maximum difference. If no such i and j exists, return -1.</p><p>Example 1:<br>Input: nums &#x3D; [7,1,5,4]<br>Output: 4<br>Explanation:<br>The maximum difference occurs with i &#x3D; 1 and j &#x3D; 2, nums[j] - nums[i] &#x3D; 5 - 1 &#x3D; 4.<br>Note that with i &#x3D; 1 and j &#x3D; 0, the difference nums[j] - nums[i] &#x3D; 7 - 1 &#x3D; 6, but i &gt; j, so it is not valid.</p><p>Example 2:<br>Input: nums &#x3D; [9,4,3,2]<br>Output: -1<br>Explanation:<br>There is no i and j such that i &lt; j and nums[i] &lt; nums[j].</p><p>Example 3:<br>Input: nums &#x3D; [1,5,2,10]<br>Output: 9<br>Explanation:<br>The maximum difference occurs with i &#x3D; 0 and j &#x3D; 3, nums[j] - nums[i] &#x3D; 10 - 1 &#x3D; 9.</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>2 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>增量元素之间的最大差值。</p><blockquote>给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 <= i < j < n 且 nums[i] < nums[j] 。<p>返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements">https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就是股票题版本一换了个说法。唯一需要注意的是如果不存在满足题意的差值，返回的是 -1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumDifference</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            res = Math.max(res, num - min);<br>            min = Math.min(min, num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &gt; <span class="hljs-number">0</span> ? res : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">121. Best Time to Buy and Sell Stock<br>2016. Maximum Difference Between Increasing Elements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1491. Average Salary Excluding the Minimum and Maximum Salary</title>
    <link href="/posts/576839838.html"/>
    <url>/posts/576839838.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array of unique integers salary where salary[i] is the salary of the ith employee.</p><p>Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.</p><p>Example 1:<br>Input: salary &#x3D; [4000,3000,1000,2000]<br>Output: 2500.00000<br>Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.<br>Average salary excluding minimum and maximum salary is (2000+3000) &#x2F; 2 &#x3D; 2500</p><p>Example 2:<br>Input: salary &#x3D; [1000,2000,3000]<br>Output: 2000.00000<br>Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.<br>Average salary excluding minimum and maximum salary is (2000) &#x2F; 1 &#x3D; 2000</p><p>Constraints:<br>3 &lt;&#x3D; salary.length &lt;&#x3D; 100<br>1000 &lt;&#x3D; salary[i] &lt;&#x3D; 106<br>All the integers of salary are unique.</p><p>去掉最低工资和最高工资后的工资平均值。</p><blockquote>给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。<p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary">https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题思路不难，扫描一遍即可。在扫描的过程中我们找到最大值和最小值，最后在计算平均值的时候记得把最大值和最小值减去即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span>[] salary)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> salary.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s : salary) &#123;<br>            min = Math.min(min, s);<br>            max = Math.max(max, s);<br>            sum += s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (sum - min - max) / (n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2000. Reverse Prefix of Word</title>
    <link href="/posts/2794589433.html"/>
    <url>/posts/2794589433.html</url>
    
    <content type="html"><![CDATA[<p>Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.</p><p>For example, if word &#x3D; “abcdefd” and ch &#x3D; “d”, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be “dcbaefd”.<br>Return the resulting string.</p><p>Example 1:<br>Input: word &#x3D; “abcdefd”, ch &#x3D; “d”<br>Output: “dcbaefd”<br>Explanation: The first occurrence of “d” is at index 3.<br>Reverse the part of word from 0 to 3 (inclusive), the resulting string is “dcbaefd”.</p><p>Example 2:<br>Input: word &#x3D; “xyxzxe”, ch &#x3D; “z”<br>Output: “zxyxxe”<br>Explanation: The first and only occurrence of “z” is at index 3.<br>Reverse the part of word from 0 to 3 (inclusive), the resulting string is “zxyxxe”.</p><p>Example 3:<br>Input: word &#x3D; “abcd”, ch &#x3D; “z”<br>Output: “abcd”<br>Explanation: “z” does not exist in word.<br>You should not do any reverse operation, the resulting string is “abcd”.</p><p>Constraints:<br>1 &lt;&#x3D; word.length &lt;&#x3D; 250<br>word consists of lowercase English letters.<br>ch is a lowercase English letter.</p><p>反转单词前缀。</p><blockquote>给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。<p>例如，如果 word &#x3D; “abcdefd” 且 ch &#x3D; “d” ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 “dcbaefd” 。<br>返回 结果字符串 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-prefix-of-word">https://leetcode-cn.com/problems/reverse-prefix-of-word</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，反转 input 字符串的某一个前缀，返回反转之后的结果。需要考虑的 corner case 是如果字符串中不存在目标字母，则返回原字符串。一般的 case 是如果找到了目标字母第一次出现的位置 i，则对这个前缀 (0, i) 进行反转，与字符串剩余的部分拼接好之后返回即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - StringBuilder</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reversePrefix</span><span class="hljs-params">(String word, <span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> word.indexOf(ch);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> reverse(word, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">reverse</span><span class="hljs-params">(String word, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">char</span>[] letters = word.toCharArray();<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> letters[start];<br>            letters[start] = letters[end];<br>            letters[end] = temp;<br>            start++;<br>            end--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(letters);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再提供一个第一次写的像X一样的代码<br>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reversePrefix</span><span class="hljs-params">(String word, <span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (!word.contains(ch + <span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> word;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; word.length()) &#123;<br>            <span class="hljs-keyword">if</span> (word.charAt(i) == ch) &#123;<br>                sb.append(helper(word, <span class="hljs-number">0</span>, i));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        i++;<br><br>        <span class="hljs-keyword">while</span> (i &lt; word.length()) &#123;<br>            sb.append(word.charAt(i));<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">helper</span><span class="hljs-params">(String word, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">char</span>[] w = word.substring(start, end + <span class="hljs-number">1</span>).toCharArray();<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> w[start];<br>            w[start] = w[end];<br>            w[end] = temp;<br>            start++;<br>            end--;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : w) &#123;<br>            sb.append(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1072. Flip Columns For Maximum Number of Equal Rows</title>
    <link href="/posts/1497371720.html"/>
    <url>/posts/1497371720.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n binary matrix matrix.</p><p>You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).</p><p>Return the maximum number of rows that have all values equal after some number of flips.</p><p>Example 1:<br>Input: matrix &#x3D; [[0,1],[1,1]]<br>Output: 1<br>Explanation: After flipping no values, 1 row has all values equal.</p><p>Example 2:<br>Input: matrix &#x3D; [[0,1],[1,0]]<br>Output: 2<br>Explanation: After flipping values in the first column, both rows have equal values.</p><p>Example 3:<br>Input: matrix &#x3D; [[0,0,0],[0,0,1],[1,1,0]]<br>Output: 2<br>Explanation: After flipping values in the first two columns, the last two rows have equal values.</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>matrix[i][j] is either 0 or 1.</p><p>按列翻转得到最大值等行数。</p><blockquote>给定由若干 0 和 1 组成的矩阵 matrix，从中选出任意数量的列并翻转其上的 每个 单元格。翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。<p>回经过一些翻转后，行与行之间所有值都相等的最大行数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flip-columns-for-maximum-number-of-equal-rows">https://leetcode-cn.com/problems/flip-columns-for-maximum-number-of-equal-rows</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>这道题的思路我参考了美版 discussion 的<a href="https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/discuss/303897/Java-easy-solution-+-explanation">最高票答案</a>。</p><p>题目给的是一个只有 0 和 1 的矩阵，问你能否通过翻转任意列（竖着从上到下）里所有的单元格（从 0 变 1 或者从 1 变 0），从而使得经过翻转操作后的矩阵里有尽可能多的行（横着从左到右）的值是一样的（全是 0 或者全是 1）。假设这样一种情况，如果在经过某次翻转操作后，使得第 i 行都为 0 了，那么我们可以得到如下结论</p><p>如果此时第 j 行上所有的值也为 0，说明第 j 行在翻转前跟第 i 行应该是一样的<br>如果此时有一个第 k 行上所有的值为 1，说明第 k 行在翻转前跟第 i 行应该是恰好相反的<br>所以这个问题可以转化为找到一个第 i 行使得与这个 row 完全相同的 row 或者完全相反的 row 最多。</p><p>具体的做法是我们需要扫描这个二维矩阵，对于当前要扫描的行 row 的所有值我们取反，记为 row2，比如 000110 我们找到 111001，然后去矩阵里找看有多少行是和 row 或者 row2 相同的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEqualRowsAfterFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span>[] flip = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                flip[j] = <span class="hljs-number">1</span> - matrix[i][j];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; m; k++) &#123;<br>                <span class="hljs-keyword">if</span> (Arrays.equals(matrix[k], matrix[i]) || Arrays.equals(matrix[k], flip)) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            res = Math.max(res, count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>二刷我参考了<a href="https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/discuss/1218248/C++-or-HashMap-or-Find-maximum-occuring-pattern-or-explanation">另一个思路</a>，我个人觉得这个思路更容易记住。他的具体做法是对于每一行，我们做一下转化，以每行第一个元素为准，记为 T，如果之后的元素跟第一个元素相同，也记为 T，否则记为 F。这样，对于如下的矩阵，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[[0,0,0],<br>[0,0,1],<br>[1,1,0]]<br></code></pre></td></tr></table></figure><p>他的模式其实是，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[[T,T,T],<br>[T,T,F],<br>[T,T,F]]<br></code></pre></td></tr></table></figure><p>对于这个例子而言，他最终返回的是 2，因为第二行和第三行可以通过将第三列反转过来变成</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[[0,0,1],<br>[0,0,0],<br>[1,1,1]]<br></code></pre></td></tr></table></figure><p>这样第二行和第三行所有值都相等。</p><p>具体的做法是我们需要用一个 hashmap 记录每一行是什么字符串。对于每一行，我们将第一个数字作为标准，记为 T，如果之后的元素跟第一个元素相同，也记为 T，否则记为 F。最后把这个字符串存入 hashmap。遍历 hashmap 的所有 key，找到出现次数最多的那个 key，他背后的出现次数就是我们最终能得到的最大行数。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEqualRowsAfterFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> matrix[i][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (matrix[i][j] == first) &#123;<br>sb.append(<span class="hljs-string">&#x27;T&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sb.append(<span class="hljs-string">&#x27;F&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>map.put(str, map.getOrDefault(str, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>max = Math.max(max, map.get(str));<br>&#125;<br><span class="hljs-keyword">return</span> max;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1436. Destination City</title>
    <link href="/posts/803566732.html"/>
    <url>/posts/803566732.html</url>
    
    <content type="html"><![CDATA[<p>You are given the array paths, where paths[i] &#x3D; [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.</p><p>It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.</p><p>Example 1:<br>Input: paths &#x3D; [[“London”,”New York”],[“New York”,”Lima”],[“Lima”,”Sao Paulo”]]<br>Output: “Sao Paulo”<br>Explanation: Starting at “London” city you will reach “Sao Paulo” city which is the destination city. Your trip consist of: “London” -&gt; “New York” -&gt; “Lima” -&gt; “Sao Paulo”.</p><p>Example 2:<br>Input: paths &#x3D; [[“B”,”C”],[“D”,”B”],[“C”,”A”]]<br>Output: “A”<br>Explanation: All possible trips are:<br>“D” -&gt; “B” -&gt; “C” -&gt; “A”.<br>“B” -&gt; “C” -&gt; “A”.<br>“C” -&gt; “A”.<br>“A”.<br>Clearly the destination city is “A”.</p><p>Example 3:<br>Input: paths &#x3D; [[“A”,”Z”]]<br>Output: “Z”</p><p>Constraints:<br>1 &lt;&#x3D; paths.length &lt;&#x3D; 100<br>paths[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; cityAi.length, cityBi.length &lt;&#x3D; 10<br>cityAi !&#x3D; cityBi<br>All strings consist of lowercase and uppercase English letters and the space character.</p><p>旅行终点站。</p><blockquote><p>给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] &#x3D; [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。<br>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/destination-city">https://leetcode-cn.com/problems/destination-city</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是哈希表。这里我们用一个哈希表把所有的 path 存下来，存的方式是hashmap&lt;key, value&gt; &#x3D; cityA, cityB。然后我们再从任意一个城市出发，看看最后到底终点站是哪个城市。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">destCity</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; paths)</span> &#123;<br>        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; path : paths) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> path.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> path.get(<span class="hljs-number">1</span>);<br>            map.put(from, to);<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> paths.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (map.containsKey(city)) &#123;<br>            city = map.get(city);<br>        &#125;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1963. Minimum Number of Swaps to Make the String Balanced</title>
    <link href="/posts/514074694.html"/>
    <url>/posts/514074694.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed string s of even length n. The string consists of exactly n &#x2F; 2 opening brackets ‘[‘ and n &#x2F; 2 closing brackets ‘]’.</p><p>A string is called balanced if and only if:<br>It is the empty string, or<br>It can be written as AB, where both A and B are balanced strings, or<br>It can be written as [C], where C is a balanced string.<br>You may swap the brackets at any two indices any number of times.</p><p>Return the minimum number of swaps to make s balanced.</p><p>Example 1:<br>Input: s &#x3D; “][][“<br>Output: 1<br>Explanation: You can make the string balanced by swapping index 0 with index 3.<br>The resulting string is “[[]]”.</p><p>Example 2:<br>Input: s &#x3D; “]]][[[“<br>Output: 2<br>Explanation: You can do the following to make the string balanced:</p><ul><li>Swap index 0 with index 4. s &#x3D; “[]][][“.</li><li>Swap index 1 with index 5. s &#x3D; “[[][]]”.<br>The resulting string is “[[][]]”.</li></ul><p>Example 3:<br>Input: s &#x3D; “[]”<br>Output: 0<br>Explanation: The string is already balanced.</p><p>Constraints:<br>n &#x3D;&#x3D; s.length<br>2 &lt;&#x3D; n &lt;&#x3D; 106<br>n is even.<br>s[i] is either ‘[‘ or ‘]’.<br>The number of opening brackets ‘[‘ equals n &#x2F; 2, and the number of closing brackets ‘]’ equals n &#x2F; 2.</p><p>使字符串平衡的最小交换次数。</p><blockquote>给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。<p>只有能满足下述所有条件的字符串才能称为 平衡字符串 ：</p><p>字符串是一个空字符串，或者<br>字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者<br>字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。<br>你可以交换 任意 两个下标所对应的括号 任意 次数。</p><p>返回使 s 变成 平衡字符串 所需要的 最小 交换次数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced">https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为是括号配对类型的题目，所以思路不难想到是 stack 这一类的。遇到左括号就入栈；遇到右括号，看看栈顶元素是否是左括号，如果是，就抵消左括号。注意这道题说了字符串 恰好 由 n &#x2F; 2 个开括号 ‘[‘ 和 n &#x2F; 2 个闭括号 ‘]’ 组成，所以无需处理左右括号数量不等的情况。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码一-stack"><a href="#代码一-stack" class="headerlink" title="代码一 - stack"></a>代码一 - stack</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                stack.push(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                    stack.pop();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (stack.size() + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码二，无需-stack，只统计匹配不上的括号数"><a href="#代码二，无需-stack，只统计匹配不上的括号数" class="headerlink" title="代码二，无需 stack，只统计匹配不上的括号数"></a>代码二，无需 stack，只统计匹配不上的括号数</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>size++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 必有左括号出现过了，可以抵消</span><br><span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>size--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (size + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1053. Previous Permutation With One Swap</title>
    <link href="/posts/2013378145.html"/>
    <url>/posts/2013378145.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of positive integers arr (not necessarily distinct), return the<br>lexicographically largest permutation that is smaller than arr, that can be made with exactly one swap. If it cannot be done, then return the same array.</p><p>Note that a swap exchanges the positions of two numbers arr[i] and arr[j]</p><p>Example 1:<br>Input: arr &#x3D; [3,2,1]<br>Output: [3,1,2]<br>Explanation: Swapping 2 and 1.</p><p>Example 2:<br>Input: arr &#x3D; [1,1,5]<br>Output: [1,1,5]<br>Explanation: This is already the smallest permutation.</p><p>Example 3:<br>Input: arr &#x3D; [1,9,4,6,7]<br>Output: [1,7,4,6,9]<br>Explanation: Swapping 9 and 7.</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 104<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 104</p><p>交换一次的先前排列。</p><blockquote><p>给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。<br>如果无法这么操作，就请返回原数组。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/previous-permutation-with-one-swap">https://leetcode.cn/problems/previous-permutation-with-one-swap</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一，treemap"><a href="#思路一，treemap" class="headerlink" title="思路一，treemap"></a>思路一，treemap</h2><p>这道题有两种思路，一种会利用到 treemap，一种是线性解法。这道题是在找比当前 input 给的 permutation 小的所有 permutation 里面最大的那个。</p><p>这道题的核心在于必须从右往左扫描 input 数组，从左往右是不行的。至于到底是哪两个数字 swap，其中一个一定是找一个下降的位置中较大的那个数字，另一个数字则视情况而定。这一类的题可以有多种变化。</p><p>首先 treemap 的做法，对于当前的 input 数组给的 permutation，如果我们要找一个比他小的 permutation，我们首先需要找到一个下降的地方，比如第一个例子里的3 - 2，然后我们将 2 替换成比 2 小的数字里最大的那个（如果有的话）。按照这个例子就是 1。</p><p>所以我们可以反过来思考，我们从右往左扫描，对于当前的数字，如果 treemap 里存在一个 lowerKey，那么就把当前数字和 lowerKey 进行 swap 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] prevPermOpt1(<span class="hljs-type">int</span>[] arr) &#123;<br>        TreeMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>        map.put(arr[len - <span class="hljs-number">1</span>], len - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> map.lowerKey(arr[i]);<br>            <span class="hljs-keyword">if</span> (lower != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> map.get(lower);<br>                swap(arr, i, j);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            map.put(arr[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二，类似next-permutation"><a href="#思路二，类似next-permutation" class="headerlink" title="思路二，类似next permutation"></a>思路二，类似next permutation</h2><p>treemap 的解法是利用到 treemap 自动排序的特点。这里我们线性的解法则可以省去这个排序的步骤。还是从右往左扫描，按照题意我们需要找一个拐点。如果从右往左扫描下去一直是下坡的话（arr[i - 1] &lt; arr[i]），则一直往左走；当我们找到一个拐点的时候，则停下，此时的 arr[i - 1] 是参与 swap 的元素之一。此时我们再次从右往左扫描，找到的第一个比 arr[i - 1] 小的元素是参与 swap 的另一个元素。把两者 swap 即可。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] prevPermOpt1(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>] &gt; arr[i]) &#123;<br>                a = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] == arr[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[a]) &#123;<br>                b = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        swap(arr, a, b);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>arr[i] = arr[j];<br>arr[j] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>treemap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1962. Remove Stones to Minimize the Total</title>
    <link href="/posts/3274119760.html"/>
    <url>/posts/3274119760.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:<br>Choose any piles[i] and remove floor(piles[i] &#x2F; 2) stones from it.<br>Notice that you can apply the operation on the same pile more than once.</p><p>Return the minimum possible total number of stones remaining after applying the k operations.</p><p>floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).</p><p>Example 1:<br>Input: piles &#x3D; [5,4,9], k &#x3D; 2<br>Output: 12<br>Explanation: Steps of a possible scenario are:</p><ul><li>Apply the operation on pile 2. The resulting piles are [5,4,5].</li><li>Apply the operation on pile 0. The resulting piles are [3,4,5].<br>The total number of stones in [3,4,5] is 12.</li></ul><p>Example 2:<br>Input: piles &#x3D; [4,3,6,7], k &#x3D; 3<br>Output: 12<br>Explanation: Steps of a possible scenario are:</p><ul><li>Apply the operation on pile 2. The resulting piles are [4,3,3,7].</li><li>Apply the operation on pile 3. The resulting piles are [4,3,3,4].</li><li>Apply the operation on pile 0. The resulting piles are [2,3,3,4].<br>The total number of stones in [2,3,3,4] is 12.</li></ul><p>Constraints:<br>1 &lt;&#x3D; piles.length &lt;&#x3D; 105<br>1 &lt;&#x3D; piles[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>移除石子使总数最小。</p><blockquote><p>给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：<br>选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] &#x2F; 2) 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。<br>返回执行 k 次操作后，剩下石子的 最小 总数。<br>floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-stones-to-minimize-the-total">https://leetcode-cn.com/problems/remove-stones-to-minimize-the-total</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。这里我们需要借助一个优先队列构建的最大堆，将每一堆的石子数加入最大堆，并同时记录石子的总数，记为 sum。每次弹出堆顶的元素并除以 2，同时记得把减去的部分从 sum 中减去。这样最后 sum 就是全局剩下的石子总数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minStoneSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : piles) &#123;<br>            sum += p;<br>            queue.offer(p);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> top / <span class="hljs-number">2</span>;<br>            res += remove;<br>            queue.offer(top - remove);<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum - res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1137. N-th Tribonacci Number</title>
    <link href="/posts/898136452.html"/>
    <url>/posts/898136452.html</url>
    
    <content type="html"><![CDATA[<p>The Tribonacci sequence Tn is defined as follows:<br>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, and Tn+3 &#x3D; Tn + Tn+1 + Tn+2 for n &gt;&#x3D; 0.<br>Given n, return the value of Tn.</p><p>Example 1:<br>Input: n &#x3D; 4<br>Output: 4<br>Explanation:<br>T_3 &#x3D; 0 + 1 + 1 &#x3D; 2<br>T_4 &#x3D; 1 + 1 + 2 &#x3D; 4</p><p>Example 2:<br>Input: n &#x3D; 25<br>Output: 1389537</p><p>Constraints:<br>0 &lt;&#x3D; n &lt;&#x3D; 37<br>The answer is guaranteed to fit within a 32-bit integer, ie. answer &lt;&#x3D; 2^31 - 1.</p><p>第 N 个泰波那契数。</p><blockquote>泰波那契序列 Tn 定义如下： <p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 &#x3D; Tn + Tn+1 + Tn+2</p><p>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-th-tribonacci-number">https://leetcode-cn.com/problems/n-th-tribonacci-number</a><br>著作权归领扣网络所有。商业转载只要理解请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-动态规划"><a href="#思路一-动态规划" class="headerlink" title="思路一 - 动态规划"></a>思路一 - 动态规划</h2><p>这道题几乎就是70题爬楼梯的翻版，只要理解泰波那契数的定义，就不难写出来，某一个数字是其前三个数字的加和。如果不理解，可以先做 70 题或 509 题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tribonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            d = a + b + c;<br>            a = b;<br>            b = c;<br>            c = d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-DFS-memo"><a href="#思路二-DFS-memo" class="headerlink" title="思路二 - DFS + memo"></a>思路二 - DFS + memo</h2><p>二刷再贡献一个 DFS + memo 的做法。这道题可以不用额外空间，但是 DFS + memo 是很多题你想不出 DP 的转换方程的时候可以救命的朴素解法。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - n 最大只到37<br>空间O(n) - 需要额外空间记录</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tribonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">38</span>];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        memo[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        memo[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        memo[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> helper(n);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (memo[n] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[n] = helper(n - <span class="hljs-number">1</span>) + helper(n - <span class="hljs-number">2</span>) + helper(n - <span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dfs + memo</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">70. Climbing Stairs<br>509. Fibonacci Number<br>746. Min Cost Climbing Stairs<br>1137. N-th Tribonacci Number<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>math</tag>
      
      <tag>memorization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 791. Custom Sort String</title>
    <link href="/posts/3866416197.html"/>
    <url>/posts/3866416197.html</url>
    
    <content type="html"><![CDATA[<p>order and str are strings composed of lowercase letters. In order, no letter occurs more than once.</p><p>order was sorted in some custom order previously. We want to permute the characters of str so that they match the order that order was sorted. More specifically, if x occurs before y in order, then x should occur before y in the returned string.</p><p>Return any permutation of str (as a string) that satisfies this property.</p><p>Example:<br>Input:<br>order &#x3D; “cba”<br>str &#x3D; “abcd”<br>Output: “cbad”<br>Explanation:<br>“a”, “b”, “c” appear in order, so the order of “a”, “b”, “c” should be “c”, “b”, and “a”.<br>Since “d” does not appear in order, it can be at any position in the returned string. “dcba”, “cdba”, “cbda” are also valid outputs.</p><p>Note:<br>order has length at most 26, and no character is repeated in order.<br>str has length at most 200.<br>order and str consist of lowercase letters only.</p><p>自定义字符串排序。</p><blockquote>给定两个字符串 order 和 s 。order 的所有字母都是 唯一 的，并且以前按照一些自定义的顺序排序。<p>对 s 的字符进行置换，使其与排序的 order 相匹配。更具体地说，如果在 order 中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x 也应该出现在 y 之前。</p><p>返回 满足这个性质的 s 的任意一种排列 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/custom-sort-string">https://leetcode.cn/problems/custom-sort-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 counting sort 计数排序。根据题意，order 是规则，s 是需要被排序的字符串。首先我们统计一下在 order 中，每个字母分别出现了几次。统计好了之后，我们按照规则的顺序，分别检查在规则中出现的字母，是否也出现在 s 中，如果有，则将 order 中所有的字母都写入 StringBuilder。最后对于 order 中出现但是 s 中未出现的字母，我们加到 StringBuilder 的最后即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">customSortString</span><span class="hljs-params">(String order, String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> order.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> order.charAt(i);<br>            <span class="hljs-keyword">while</span> (map[c - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.append(c);<br>                map[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++) &#123;<br>            <span class="hljs-keyword">while</span> (map[c - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                sb.append(c);<br>                map[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>counting sort</tag>
      
      <tag>sort</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1930. Unique Length-3 Palindromic Subsequences</title>
    <link href="/posts/603765547.html"/>
    <url>/posts/603765547.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s, return the number of unique palindromes of length three that are a subsequence of s.</p><p>Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.</p><p>A palindrome is a string that reads the same forwards and backwards.</p><p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p><p>For example, “ace” is a subsequence of “abcde”.</p><p>Example 1:<br>Input: s &#x3D; “aabca”<br>Output: 3<br>Explanation: The 3 palindromic subsequences of length 3 are:</p><ul><li>“aba” (subsequence of “aabca”)</li><li>“aaa” (subsequence of “aabca”)</li><li>“aca” (subsequence of “aabca”)</li></ul><p>Example 2:<br>Input: s &#x3D; “adc”<br>Output: 0<br>Explanation: There are no palindromic subsequences of length 3 in “adc”.</p><p>Example 3:<br>Input: s &#x3D; “bbcbaba”<br>Output: 4<br>Explanation: The 4 palindromic subsequences of length 3 are:</p><ul><li>“bbb” (subsequence of “bbcbaba”)</li><li>“bcb” (subsequence of “bbcbaba”)</li><li>“bab” (subsequence of “bbcbaba”)</li><li>“aba” (subsequence of “bbcbaba”)</li></ul><p>Constraints:<br>3 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of only lowercase English letters.</p><p>长度为 3 的不同回文子序列。</p><blockquote><p>给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，”ace” 是 “abcde” 的一个子序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>这道题是对回文串的考察。题目问的是有多少个 unique 的，由三个字母组成的回文串的子序列。因为题目要求找的回文串只能是由三个字母组成，为了确定到底哪些回文串是合法的，我这里需要先统计一下每个字母的出现次数。只有出现次数大于等于 2 的字母，才有可能作为回文串两边的字母。</p><p>我们需要记录 input 字符串中每个不同字母第一次和最后一次出现位置的下标，这里我用一个二维数组 int[][] indexes 记录。同时我还用另外一个一维数组 count 记录每个字母的出现次数。记录完毕之后，再次扫描 indexes 数组。对于其中的每一个字母，分如下几种情况</p><ul><li>如果当前字母出现次数 &lt;&#x3D; 1，那么他无法作为回文串两边的字母，直接就跳过了</li><li>如果当前字母出现次数 &gt; 1，他可以作为回文串两边的字母</li></ul><p>对于第二种情况，我们需要统计在中间到底有哪些其他的不同字母。这里我们只能再写一个 for 循环然后用 hashset 去记录。最后 hashset 的大小就是以当前字母作为回文串两边的字母能形成的合法的回文串的个数了。将这个结果累加到结果集里。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromicSubsequence</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 每个字母出现的次数</span><br>        <span class="hljs-type">int</span>[][] indexes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 每个字母第一次和最后一次出现的index</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (count[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                indexes[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] = i; <span class="hljs-comment">// 第一次出现的index</span><br>            &#125;<br>            count[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] count2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (count2[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                indexes[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = i; <span class="hljs-comment">// 最后一次出现的index</span><br>                count2[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-comment">// 当前字母无法成为左右两侧的字母</span><br>            <span class="hljs-keyword">if</span> (count[i] &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">firstIndex</span> <span class="hljs-operator">=</span> indexes[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> indexes[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// System.out.println(firstIndex + &quot;, &quot; + lastIndex + &quot;, &quot; + count[i]);</span><br>            <span class="hljs-keyword">if</span> (lastIndex - firstIndex &gt; <span class="hljs-number">1</span>) &#123;<br>                set.clear();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> firstIndex + <span class="hljs-number">1</span>; j &lt; lastIndex; j++) &#123;<br>                    set.add(s.charAt(j));<br>                &#125;<br>                res += set.size();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>另外一种思路是我们遍历 26 个字母，找到他们在 input 字符串里最左边出现的下标 i 和最右边出现的下标 j。如果 j - i &lt; 2，则说明中间无法放入别的字母组成回文。如果 j - i &gt;&#x3D; 2，则用一个 hashset 去统计中间到底有多少个不同的字母。假设有 x 个不同字母，那么就有 x 种回文，把这个结果累加到 res 里。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPalindromicSubsequence</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; s.charAt(i) != c) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != c) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            set.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br>                set.add(s.charAt(k));<br>            &#125;<br>            res += set.size();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 枚举两边的字母，然后看中间有几个不同的字母</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1905. Count Sub Islands</title>
    <link href="/posts/3030506753.html"/>
    <url>/posts/3030506753.html</url>
    
    <content type="html"><![CDATA[<p>You are given two m x n binary matrices grid1 and grid2 containing only 0’s (representing water) and 1’s (representing land). An island is a group of 1’s connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.</p><p>An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.</p><p>Return the number of islands in grid2 that are considered sub-islands.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/06/10/test1.png" alt="Example 1"><br>Input: grid1 &#x3D; [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 &#x3D; [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]<br>Output: 3<br>Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.<br>The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png" alt="Example 2"><br>Input: grid1 &#x3D; [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 &#x3D; [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]<br>Output: 2<br>Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.<br>The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.</p><p>Constraints:<br>m &#x3D;&#x3D; grid1.length &#x3D;&#x3D; grid2.length<br>n &#x3D;&#x3D; grid1[i].length &#x3D;&#x3D; grid2[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 500<br>grid1[i][j] and grid2[i][j] are either 0 or 1.</p><p>统计子岛屿。</p><blockquote>给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。<p>如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。</p><p>请你返回 grid2 中 子岛屿 的 数目 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/count-sub-islands">https://leetcode.cn/problems/count-sub-islands</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道典型的 flood fill 类型的题，做法也类似于 200 题。我给出 DFS 和 BFS 的做法。</p><p>题目问的是两个尺寸相同的矩阵 grid1 和 grid2，在 grid2 中出现的岛屿是否能被 grid1 中的岛屿完全包含。按照这个题意，我们先去 grid2 里找一个岛屿的起点，在将当前这个岛的尺寸扩张的同时，我们需要判断所有在 grid2 里是岛屿的坐标，在 grid1 里是否也是岛屿，如果不是则返回 false。只有 grid2 遍历到的所有的 1 可以完全被 grid1 覆盖，才是子岛屿。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="BFS实现"><a href="#BFS实现" class="headerlink" title="BFS实现"></a>BFS实现</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] grid1;<br>    <span class="hljs-type">int</span>[][] grid2;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] dx = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>[] dy = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubIslands</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid1, <span class="hljs-type">int</span>[][] grid2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid1 = grid1;<br>        <span class="hljs-built_in">this</span>.grid2 = grid2;<br>        m = grid1.length;<br>        n = grid1[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid2[i][j] == <span class="hljs-number">1</span> &amp;&amp; bfs(i, j)) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>        grid2[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (grid1[i][j] == <span class="hljs-number">0</span>) &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dx[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> y + dy[k];<br>                <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; grid2[newX][newY] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; newX, newY &#125;);<br>                    grid2[newX][newY] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span> (grid1[newX][newY] == <span class="hljs-number">0</span>) &#123;<br>                        flag = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS实现"><a href="#DFS实现" class="headerlink" title="DFS实现"></a>DFS实现</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubIslands</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid1, <span class="hljs-type">int</span>[][] grid2)</span> &#123;<br>        m = grid2.length;<br>        n = grid2[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid2[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (dfs(grid1, grid2, i, j)) &#123;<br>                        count++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid1, <span class="hljs-type">int</span>[][] grid2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-comment">// 如果没越界且这个坐标不是没访问过的陆地，则返回true</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || grid2[i][j] != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (grid1[i][j] != grid2[i][j]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><span class="hljs-comment">// 标记一下，表示访问过这个点了</span><br>        grid2[i][j] = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> dfs(grid1, grid2, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> dfs(grid1, grid2, i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(grid1, grid2, i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(grid1, grid2, i, j + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> up &amp;&amp; down &amp;&amp; left &amp;&amp; right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1886. Determine Whether Matrix Can Be Obtained By Rotation</title>
    <link href="/posts/1631282000.html"/>
    <url>/posts/1631282000.html</url>
    
    <content type="html"><![CDATA[<p>Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.</p><p>Example 1:</p><p>Input: mat &#x3D; [[0,1],[1,0]], target &#x3D; [[1,0],[0,1]]<br>Output: true<br>Explanation: We can rotate mat 90 degrees clockwise to make mat equal target.</p><p>Example 2:</p><p>Input: mat &#x3D; [[0,1],[1,1]], target &#x3D; [[1,0],[0,1]]<br>Output: false<br>Explanation: It is impossible to make mat equal to target by rotating mat.</p><p>Example 3:</p><p>Input: mat &#x3D; [[0,0,0],[0,1,0],[1,1,1]], target &#x3D; [[1,1,1],[0,1,0],[0,0,0]]<br>Output: true<br>Explanation: We can rotate mat 90 degrees clockwise two times to make mat equal target.</p><p>Constraints:<br>n &#x3D;&#x3D; mat.length &#x3D;&#x3D; target.length<br>n &#x3D;&#x3D; mat[i].length &#x3D;&#x3D; target[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 10<br>mat[i][j] and target[i][j] are either 0 or 1.</p><p>判断矩阵经轮转后是否一致。</p><blockquote>给你两个大小为 n x n 的二进制矩阵 mat 和 target 。现 以 90 度顺时针轮转 矩阵 mat 中的元素 若干次 ，如果能够使 mat 与 target 一致，返回 true ；否则，返回 false 。<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation">https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题给了一个小小的提示顺时针旋转90度，可惜我第一次做的时候没有意识到。其实这道题跟 48 题很像。48 题只是请你把 input matrix 顺时针旋转90度；这道题是请你判断 target 是否有可能是通过将 input matrix 顺时针旋转了若干次而得来的。既然48题我们都可以不用额外空间实现，这道题也可以。我们需要把48题的方法照搬过来，只是每次旋转90度之后都要判断一次，一共判断四次即可。同时注意 target matrix 有可能跟原来的 mat 一样，不需要 rotate。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findRotation</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span>[][] target)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span>[][] rotated = helper(mat);<br>            <span class="hljs-keyword">if</span> (isSame(rotated, target)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] helper(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-comment">// 按左上 - 右下对角线交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; m; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 左右对折</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[i][m - <span class="hljs-number">1</span> - j];<br>                matrix[i][m - <span class="hljs-number">1</span> - j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[i][j] != b[i][j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时我也分享一下第一次做的代码，我是把 rotate 过后的结果 matrix 模拟出来了才判断的。细节很不好想，而且容易错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findRotation</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span>[][] target)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (helper(target, mat)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span>[][] first = rotateOnce(mat);<br>        <span class="hljs-type">int</span>[][] second = rotateTwice(mat);<br>        <span class="hljs-type">int</span>[][] third = rotateThird(mat);<br>        <span class="hljs-keyword">if</span> (helper(target, first) || helper(target, second) || helper(target, third)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix1, <span class="hljs-type">int</span>[][] matrix2)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix1.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; matrix1[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix1[i][j] != matrix2[i][j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// rotate 90</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] rotateOnce(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span>[][] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                A[j][len - <span class="hljs-number">1</span> - i] = mat[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br><br>    <span class="hljs-comment">// rotate 180</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] rotateTwice(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span>[][] B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                B[i][j] = mat[len - <span class="hljs-number">1</span> - i][len - <span class="hljs-number">1</span> - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> B;<br>    &#125;<br><br>    <span class="hljs-comment">// rotate 270</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] rotateThird(<span class="hljs-type">int</span>[][] mat) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span>[][] C = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mat.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; mat[<span class="hljs-number">0</span>].length; j++) &#123;<br>                C[len - <span class="hljs-number">1</span> - j][i] = mat[i][j];<br>                <span class="hljs-comment">// System.out.println(&quot;old, i &quot; + i + &quot; j &quot; + j);</span><br>                <span class="hljs-comment">// System.out.println(&quot;new, i &quot; + (len - 1 - i) + &quot; j &quot; + (len - 1 - j));</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// for (int i = 0; i &lt; C.length; i++) &#123;</span><br>        <span class="hljs-comment">//     System.out.println(Arrays.toString(C[i]));</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> C;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">48. Rotate Image<br>1886. Determine Whether Matrix Can Be Obtained By Rotation<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1400. Construct K Palindrome Strings</title>
    <link href="/posts/1352006407.html"/>
    <url>/posts/1352006407.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.</p><p>Example 1:<br>Input: s &#x3D; “annabelle”, k &#x3D; 2<br>Output: true<br>Explanation: You can construct two palindromes using all characters in s.<br>Some possible constructions “anna” + “elble”, “anbna” + “elle”, “anellena” + “b”</p><p>Example 2:<br>Input: s &#x3D; “leetcode”, k &#x3D; 3<br>Output: false<br>Explanation: It is impossible to construct 3 palindromes using all the characters of s.</p><p>Example 3:<br>Input: s &#x3D; “true”, k &#x3D; 4<br>Output: true<br>Explanation: The only possible solution is to put each character in a separate string.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of lowercase English letters.<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>构造 K 个回文字符串。</p><blockquote><p>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。</p><p>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings">https://leetcode-cn.com/problems/construct-k-palindrome-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。题意是试图把 input 字符串 s 分割，请你判断是否有可能把 input 字符串分割成 k 份，同时每份子串都是一个回文串。这里贪心的思想是，如果我可以把 s 分成 k 个回文串的话，那么出现次数为奇数的字母个数一定不能超过 k 个，否则就不行。出现次数为 3 次或者 5 次的字母的确可以自成一个回文，但是他不能再和其他出现次数为奇数的字母合并成另一个回文了，所以出现次数为奇数的字母有多少，就会产生多少个子串。如果这个数字大于 k，就不能满足题意。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                single++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single &lt;= k &amp;&amp; n &gt;= k;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 出现次数为奇数的字母只能作为回文中间的字母，那么如果这样的字母出现个数超过k个的话就一定不能构造k个回文串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1331. Rank Transform of an Array</title>
    <link href="/posts/3836537705.html"/>
    <url>/posts/3836537705.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers arr, replace each element with its rank.</p><p>The rank represents how large the element is. The rank has the following rules:</p><ul><li>Rank is an integer starting from 1.</li><li>The larger the element, the larger the rank. If two elements are equal, their rank must be the same.</li><li>Rank should be as small as possible.</li></ul><p>Example 1:<br>Input: arr &#x3D; [40,10,20,30]<br>Output: [4,1,2,3]<br>Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.</p><p>Example 2:<br>Input: arr &#x3D; [100,100,100]<br>Output: [1,1,1]<br>Explanation: Same elements share the same rank.</p><p>Example 3:<br>Input: arr &#x3D; [37,12,28,9,100,56,80,5,12]<br>Output: [5,3,4,2,8,6,7,1,3]</p><p>Constraints:<br>0 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; arr[i] &lt;&#x3D; 109</p><p>数组序号转换。</p><blockquote>给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。<p>序号代表了一个元素有多大。序号编号的规则如下：<br>序号从 1 开始编号。<br>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。<br>每个数字的序号都应该尽可能地小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rank-transform-of-an-array">https://leetcode-cn.com/problems/rank-transform-of-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>克隆一下原数组并排序，这样一来，value 小的元素排在前面，value 大的元素排在后面。<br>此时我们还需要一个 hashmap 和一个变量 index &#x3D; 1。开始遍历这个克隆的数组，当遇到某个不存在于 hashmap 的数字的时候，这个数字的 rank 就是当前的 index，然后将这个数字和 index 放入 hashmap 中，index 自增 1。</p><p>最后，我们遍历原数组，对于每个数字，我们在 hashmap 中查找它的 rank，然后替换为这个 rank。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] arrayRankTransform(<span class="hljs-type">int</span>[] arr) &#123;<br>        <span class="hljs-type">int</span>[] sorted = arr.clone();<br>        Arrays.sort(sorted);<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : sorted) &#123;<br>            <span class="hljs-keyword">if</span> (!map.containsKey(num)) &#123;<br>                map.put(num, index++);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;<br>            res[i] = map.get(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1642. Furthest Building You Can Reach</title>
    <link href="/posts/13153578.html"/>
    <url>/posts/13153578.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.</p><p>You start your journey from building 0 and move to the next building by possibly using bricks or ladders.</p><p>While moving from building i to building i+1 (0-indexed),</p><p>If the current building’s height is greater than or equal to the next building’s height, you do not need a ladder or bricks.<br>If the current building’s height is less than the next building’s height, you can either use one ladder or (h[i+1] - h[i]) bricks.<br>Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/27/q4.gif" alt="Example 1"><br>Input: heights &#x3D; [4,2,7,6,9,14,12], bricks &#x3D; 5, ladders &#x3D; 1<br>Output: 4<br>Explanation: Starting at building 0, you can follow these steps:</p><ul><li>Go to building 1 without using ladders nor bricks since 4 &gt;&#x3D; 2.</li><li>Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7.</li><li>Go to building 3 without using ladders nor bricks since 7 &gt;&#x3D; 6.</li><li>Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9.<br>It is impossible to go beyond building 4 because you do not have any more bricks or ladders.</li></ul><p>Example 2:<br>Input: heights &#x3D; [4,12,2,7,3,18,20,3,19], bricks &#x3D; 10, ladders &#x3D; 2<br>Output: 7</p><p>Example 3:<br>Input: heights &#x3D; [14,3,19,3], bricks &#x3D; 17, ladders &#x3D; 0<br>Output: 3</p><p>Constraints:<br>1 &lt;&#x3D; heights.length &lt;&#x3D; 105<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; 106<br>0 &lt;&#x3D; bricks &lt;&#x3D; 109<br>0 &lt;&#x3D; ladders &lt;&#x3D; heights.length</p><p>可以到达的最远建筑。</p><blockquote><p>给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 bricks 和梯子 ladders 。<br>你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。<br>当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时：<br>如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块<br>如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块<br>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach">https://leetcode-cn.com/problems/furthest-building-you-can-reach</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心，具体做法如下。对于每一个位置 i 而言，如果他的下一个位置 i + 1 的高度比自己要矮，那么我们不需要消耗梯子或者砖头；反之如果他的下一个位置 i + 1 的高度比自己要高，我们就需要消耗梯子或者砖头。由于梯子的高度是任意的同时砖头的数量是有限的，所以这里我们先用梯子，当梯子用完之后，我们看看用过梯子的地方是否有可能被砖头替换掉，这样我们就可以利用省下的梯子再去走更远的距离。</p><p>所以这里我们需要一个最小堆，堆中记录的是每一个需要梯子&#x2F;砖头的高度差 diff，高度差最小的在堆顶。这样当梯子用完的时候，我们可以优先去用砖头替换高度差最小的，这样可以尽可能地把砖头利用完。当砖头用完的时候，当前这个 index 就是能去到的最远的地方。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">furthestBuilding</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights, <span class="hljs-type">int</span> bricks, <span class="hljs-type">int</span> ladders)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> heights[i + <span class="hljs-number">1</span>] - heights[i];<br>            <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) &#123;<br>                queue.offer(diff);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; ladders) &#123;<br>                bricks -= queue.poll();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bricks &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> heights.length - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1720. Decode XORed Array</title>
    <link href="/posts/1853229639.html"/>
    <url>/posts/1853229639.html</url>
    
    <content type="html"><![CDATA[<p>There is a hidden integer array arr that consists of n non-negative integers.</p><p>It was encoded into another integer array encoded of length n - 1, such that encoded[i] &#x3D; arr[i] XOR arr[i + 1]. For example, if arr &#x3D; [1,0,2,1], then encoded &#x3D; [1,2,3].</p><p>You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].</p><p>Return the original array arr. It can be proved that the answer exists and is unique.</p><p>Example 1:<br>Input: encoded &#x3D; [1,2,3], first &#x3D; 1<br>Output: [1,0,2,1]<br>Explanation: If arr &#x3D; [1,0,2,1], then first &#x3D; 1 and encoded &#x3D; [1 XOR 0, 0 XOR 2, 2 XOR 1] &#x3D; [1,2,3]</p><p>Example 2:<br>Input: encoded &#x3D; [6,2,7,3], first &#x3D; 4<br>Output: [4,2,0,7,4]</p><p>Constraints:<br>2 &lt;&#x3D; n &lt;&#x3D; 104<br>encoded.length &#x3D;&#x3D; n - 1<br>0 &lt;&#x3D; encoded[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; first &lt;&#x3D; 105</p><p>解码异或后的数组。</p><blockquote>未知 整数数组 arr 由 n 个非负整数组成。<p>经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] &#x3D; arr[i] XOR arr[i + 1] 。例如，arr &#x3D; [1,0,2,1] 经编码后得到 encoded &#x3D; [1,2,3] 。</p><p>给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。</p><p>请解码返回原数组 arr 。可以证明答案存在并且是唯一的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/decode-xored-array">https://leetcode-cn.com/problems/decode-xored-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是位运算，跟题目提到的XOR异或运算有关。学习位运算的时候，我们学过位运算的如下几条规律</p><ul><li>相同的数字互相做XOR运算等于0 - <code>N XOR N = 0</code></li><li>任何非零数字与0做异或运算等于这个数字本身 - <code>N XOR 0 = N</code></li><li>异或满足交换律，比如如果 <code>a XOR b = c</code>, 那么 <code>b XOR c = a</code></li></ul><p>复习过如上这几条规律之后，这道题就好做了。因为题目给的 encoded 数组是由原数组数字之间通过 XOR 运算的来的（encoded[i - 1] &#x3D; arr[i - 1] XOR arr[i]），那么对于原数组里的每个数字 arr[i]而言，我们把这个式子变一下，就得到了：<br><code>arr[i] = encoded[i - 1] XOR arr[i - 1]</code></p><p>对于这道题，因为 encoded 数组里的每一个元素 encoded[i] &#x3D; encoded[i - 1] ^ arr[i]，那么当我们得到原数组的第一个元素 nums[0]，我们可以计算 <code>encoded[1] ^ nums[0]</code> 来得到 <code>nums[1]</code>。这个方法推广到后面所有的元素就是 <code>nums[i] = encoded[i - 1] ^ nums[i - 1]</code>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1) - 不包含output数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] decode(<span class="hljs-type">int</span>[] encoded, <span class="hljs-type">int</span> first) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> encoded.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        res[<span class="hljs-number">0</span>] = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; res.length; i++) &#123;<br>            res[i] = first ^ encoded[i - <span class="hljs-number">1</span>];<br>            first = res[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 930. Binary Subarrays With Sum</title>
    <link href="/posts/4050545082.html"/>
    <url>/posts/4050545082.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.</p><p>A subarray is a contiguous part of the array.</p><p>Example 1:<br>Input: nums &#x3D; [1,0,1,0,1], goal &#x3D; 2<br>Output: 4<br>Explanation: The 4 subarrays are bolded and underlined below:<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]</p><p>Example 2:<br>Input: nums &#x3D; [0,0,0,0,0], goal &#x3D; 0<br>Output: 15</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>nums[i] is either 0 or 1.<br>0 &lt;&#x3D; goal &lt;&#x3D; nums.length</p><p>和相同的二元子数组。</p><blockquote>给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。<p>子数组 是数组的一段连续部分。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我提供两种做法，一是前缀和，二是滑动窗口。最优解是前缀和。</p><h2 id="思路一-前缀和"><a href="#思路一-前缀和" class="headerlink" title="思路一 - 前缀和"></a>思路一 - 前缀和</h2><p>创建一个变量 sum，在遍历 input 数组的同时把每个数字累加到 sum 上，并把每个 sum 和当前的 index 存到一个 map 中。如果在 map 中存在一个 key &#x3D; sum - goal，说明存在一个子数组和为 goal，我们可以把 key 背后的 value 累加到结果里。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarraysWithSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> goal)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum += nums[i];<br>            res += map.getOrDefault(sum - goal, <span class="hljs-number">0</span>);<br>            map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实现二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarraysWithSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> goal)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>map[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>sum += num;<br><span class="hljs-keyword">if</span> (sum &gt;= goal) &#123;<br>res += map[sum - goal];<br>&#125;<br>map[sum]++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-滑动窗口"><a href="#思路二-滑动窗口" class="headerlink" title="思路二 - 滑动窗口"></a>思路二 - 滑动窗口</h2><p>这道题可以用类似 992 题那样的滑动窗口的思路做，来找到子数组的和<code>恰巧</code>等于 goal 的子数组个数。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2) - 接近于O(n^2)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarraysWithSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> goal)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(nums, goal) - helper(nums, goal - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> limit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; len) &#123;<br>            sum += nums[end];<br>            end++;<br>            <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; sum &gt; limit) &#123;<br>                sum -= nums[start];<br>                start++;<br>            &#125;<br>            res += end - start + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1845. Seat Reservation Manager</title>
    <link href="/posts/3294691136.html"/>
    <url>/posts/3294691136.html</url>
    
    <content type="html"><![CDATA[<p>Design a system that manages the reservation state of n seats that are numbered from 1 to n.</p><p>Implement the SeatManager class:</p><ul><li>SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.</li><li>int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.</li><li>void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.</li></ul><p>Example 1:<br>Input<br>[“SeatManager”, “reserve”, “reserve”, “unreserve”, “reserve”, “reserve”, “reserve”, “reserve”, “unreserve”]<br>[[5], [], [], [2], [], [], [], [], [5]]<br>Output<br>[null, 1, 2, null, 2, 3, 4, 5, null]</p><p>Explanation<br>SeatManager seatManager &#x3D; new SeatManager(5); &#x2F;&#x2F; Initializes a SeatManager with 5 seats.<br>seatManager.reserve();    &#x2F;&#x2F; All seats are available, so return the lowest numbered seat, which is 1.<br>seatManager.reserve();    &#x2F;&#x2F; The available seats are [2,3,4,5], so return the lowest of them, which is 2.<br>seatManager.unreserve(2); &#x2F;&#x2F; Unreserve seat 2, so now the available seats are [2,3,4,5].<br>seatManager.reserve();    &#x2F;&#x2F; The available seats are [2,3,4,5], so return the lowest of them, which is 2.<br>seatManager.reserve();    &#x2F;&#x2F; The available seats are [3,4,5], so return the lowest of them, which is 3.<br>seatManager.reserve();    &#x2F;&#x2F; The available seats are [4,5], so return the lowest of them, which is 4.<br>seatManager.reserve();    &#x2F;&#x2F; The only available seat is seat 5, so return 5.<br>seatManager.unreserve(5); &#x2F;&#x2F; Unreserve seat 5, so now the available seats are [5].</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; seatNumber &lt;&#x3D; n<br>For each call to reserve, it is guaranteed that there will be at least one unreserved seat.<br>For each call to unreserve, it is guaranteed that seatNumber will be reserved.<br>At most 105 calls in total will be made to reserve and unreserve.</p><p>座位预约管理系统。</p><blockquote>请你设计一个管理 n 个座位预约的系统，座位编号从 1 到 n 。<p>请你实现 SeatManager 类：<br>SeatManager(int n) 初始化一个 SeatManager 对象，它管理从 1 到 n 编号的 n 个座位。所有座位初始都是可预约的。<br>int reserve() 返回可以预约座位的 最小编号 ，此座位变为不可预约。<br>void unreserve(int seatNumber) 将给定编号 seatNumber 对应的座位变成可以预约。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/seat-reservation-manager">https://leetcode-cn.com/problems/seat-reservation-manager</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-贪心"><a href="#思路一-贪心" class="headerlink" title="思路一 - 贪心"></a>思路一 - 贪心</h2><p>既然是要返回可以预约座位的最小编号，那么我们可以考虑用一个最小堆存放还未被使用过的座位编号。一开始，堆中存放了所有的座位编号，当有人开始就坐，我们就按座位号从小到大分发座位。谁离开了座位，他的座位号也会被回收到最小堆的堆顶。再有新的人来坐，那么最小的座位号还是会被优先分发。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeatManager</span> &#123;<br>PriorityQueue&lt;Integer&gt; minHeap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SeatManager</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>minHeap.offer(i);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!minHeap.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> minHeap.poll();<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unreserve</span><span class="hljs-params">(<span class="hljs-type">int</span> seatNumber)</span> &#123;<br>minHeap.offer(seatNumber);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your SeatManager object will be instantiated and called as such:</span><br><span class="hljs-comment"> * SeatManager obj = new SeatManager(n);</span><br><span class="hljs-comment"> * int param_1 = obj.reserve();</span><br><span class="hljs-comment"> * obj.unreserve(seatNumber);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="思路二-优化过了的贪心"><a href="#思路二-优化过了的贪心" class="headerlink" title="思路二 - 优化过了的贪心"></a>思路二 - 优化过了的贪心</h2><p>注意 input 数据如果很大的话，把所有数字都放到堆中的做法就不是很聪明。我们可以换一个思路，假设没有任何人坐下之前，屋子里是没有椅子的，当有人开始进来坐下的时候，如果此时没有可用的椅子，我们就加一把椅子；如果有人离开，人可以离开但是椅子再也不离开了，那么再有新的人进来的时候，直接坐空着的椅子就好了。</p><p>这里我们还是需要一个最小堆，存放的是此时没有人坐的椅子。如果堆为空，说明没有椅子可用，椅子数要加一；当有人离开的时候，把此人的椅子编号再放回最小堆即可。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeatManager</span> &#123;<br>    PriorityQueue&lt;Integer&gt; queue;<br>    <span class="hljs-type">int</span> seats;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SeatManager</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        seats = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ++seats;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unreserve</span><span class="hljs-params">(<span class="hljs-type">int</span> seatNumber)</span> &#123;<br>        queue.offer(seatNumber);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your SeatManager object will be instantiated and called as such:</span><br><span class="hljs-comment"> * SeatManager obj = new SeatManager(n);</span><br><span class="hljs-comment"> * int param_1 = obj.reserve();</span><br><span class="hljs-comment"> * obj.unreserve(seatNumber);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1244. Design A Leaderboard</title>
    <link href="/posts/41030754.html"/>
    <url>/posts/41030754.html</url>
    
    <content type="html"><![CDATA[<p>Design a Leaderboard class, which has 3 functions:</p><p>addScore(playerId, score): Update the leaderboard by adding score to the given player’s score. If there is no player with such id in the leaderboard, add him to the leaderboard with the given score.</p><p>top(K): Return the score sum of the top K players.</p><p>reset(playerId): Reset the score of the player with the given id to 0 (in other words erase it from the leaderboard). It is guaranteed that the player was added to the leaderboard before calling this function.</p><p>Initially, the leaderboard is empty.</p><p>Example 1:<br>Input:<br>[“Leaderboard”,”addScore”,”addScore”,”addScore”,”addScore”,”addScore”,”top”,”reset”,”reset”,”addScore”,”top”]<br>[[],[1,73],[2,56],[3,39],[4,51],[5,4],[1],[1],[2],[2,51],[3]]<br>Output:<br>[null,null,null,null,null,null,73,null,null,null,141]<br>Explanation:<br>Leaderboard leaderboard &#x3D; new Leaderboard ();<br>leaderboard.addScore(1,73); &#x2F;&#x2F; leaderboard &#x3D; [[1,73]];<br>leaderboard.addScore(2,56); &#x2F;&#x2F; leaderboard &#x3D; [[1,73],[2,56]];<br>leaderboard.addScore(3,39); &#x2F;&#x2F; leaderboard &#x3D; [[1,73],[2,56],[3,39]];<br>leaderboard.addScore(4,51); &#x2F;&#x2F; leaderboard &#x3D; [[1,73],[2,56],[3,39],[4,51]];<br>leaderboard.addScore(5,4); &#x2F;&#x2F; leaderboard &#x3D; [[1,73],[2,56],[3,39],[4,51],[5,4]];<br>leaderboard.top(1); &#x2F;&#x2F; returns 73;<br>leaderboard.reset(1); &#x2F;&#x2F; leaderboard &#x3D; [[2,56],[3,39],[4,51],[5,4]];<br>leaderboard.reset(2); &#x2F;&#x2F; leaderboard &#x3D; [[3,39],[4,51],[5,4]];<br>leaderboard.addScore(2,51); &#x2F;&#x2F; leaderboard &#x3D; [[2,51],[3,39],[4,51],[5,4]];<br>leaderboard.top(3); &#x2F;&#x2F; returns 141 &#x3D; 51 + 51 + 39;<br>Constraints:<br>1 &lt;&#x3D; playerId, K &lt;&#x3D; 10000<br>It’s guaranteed that K is less than or equal to the current number of players.<br>1 &lt;&#x3D; score &lt;&#x3D; 100<br>There will be at most 1000 function calls.</p><p>力扣排行榜。</p><blockquote><p>新一轮的「力扣杯」编程大赛即将启动，为了动态显示参赛者的得分数据，需要设计一个排行榜 Leaderboard。<br>请你帮忙来设计这个 Leaderboard 类，使得它有如下 3 个函数：<br>addScore(playerId, score)：假如参赛者已经在排行榜上，就给他的当前得分增加 score 点分值并更新排行。<br>假如该参赛者不在排行榜上，就把他添加到榜单上，并且将分数设置为 score。<br>top(K)：返回前 K 名参赛者的 得分总和。<br>reset(playerId)：将指定参赛者的成绩清零（换句话说，将其从排行榜中删除）。题目保证在调用此函数前，该参赛者已有成绩，并且在榜单上。<br>请注意，在初始状态下，排行榜是空的。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-a-leaderboard">https://leetcode-cn.com/problems/design-a-leaderboard</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>这是一道设计题。我的思路如下，我们需要一个 hashmap，一个 treemap。除了题目要求实现的函数之外，我还需要一个 helper 函数。他的作用是当某一个 player 的分数有变动的时候，我需要将对应 unique score 记录的 player 的个数做出修改。其余部分参见代码。<br>hashmap - &lt;playerId, his score&gt;<br>treemap - &lt;each unique score, how many people have this same score&gt;</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaderboard</span> &#123;<br><span class="hljs-comment">// &lt;playerId, score&gt;</span><br>HashMap&lt;Integer, Integer&gt; map;<br><span class="hljs-comment">// &lt;score, num of people&gt;</span><br>TreeMap&lt;Integer, Integer&gt; treemap;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Leaderboard</span><span class="hljs-params">()</span> &#123;<br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>treemap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addScore</span><span class="hljs-params">(<span class="hljs-type">int</span> playerId, <span class="hljs-type">int</span> score)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">curScore</span> <span class="hljs-operator">=</span> map.get(playerId);<br><span class="hljs-keyword">if</span> (curScore != <span class="hljs-literal">null</span>) &#123;<br>helper(curScore);<br>curScore += score;<br>map.put(playerId, curScore);<br><span class="hljs-keyword">if</span> (treemap.containsKey(curScore)) &#123;<br>treemap.put(curScore, treemap.get(curScore) + <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>treemap.put(curScore, <span class="hljs-number">1</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>map.put(playerId, score);<br>treemap.put(score, treemap.getOrDefault(score, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">(<span class="hljs-type">int</span> K)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Map.Entry&lt;Integer, Integer&gt; scoreEntry = treemap.lastEntry();<br><span class="hljs-keyword">while</span> (K &gt; <span class="hljs-number">0</span> &amp;&amp; scoreEntry != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Math.min(scoreEntry.getValue(), K);<br>sum += scoreEntry.getKey() * count;<br>scoreEntry = treemap.lowerEntry(scoreEntry.getKey());<br>K -= count;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> playerId)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> map.get(playerId);<br>map.put(playerId, <span class="hljs-number">0</span>);<br>helper(score);<br>treemap.put(<span class="hljs-number">0</span>, treemap.getOrDefault(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br> <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> treemap.get(score);<br><span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>treemap.remove(score);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>treemap.put(score, count - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Leaderboard object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Leaderboard obj = new Leaderboard();</span><br><span class="hljs-comment"> * obj.addScore(playerId,score);</span><br><span class="hljs-comment"> * int param_2 = obj.top(K);</span><br><span class="hljs-comment"> * obj.reset(playerId);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>二刷我再提供另外一种思路，需要用到 hashmap 和一个 list。同时这里我需要自己创建一个 node class，存放每个元素的 id 和 score。hashmap 存的是&lt;id, Node&gt;，list 存的是所有的 node。</p><ul><li>addScore, 如果某个 id 不存在，则创建一个新的 node，记录其 score，并分别放入 hashmap 和 list。如果某个 id 存在，则去 hashmap 中找到这个 node，累加他的 score</li><li>top，对 list 按 score 从大到小排序，然后取前 k 个元素，累加他们的 score</li><li>reset，按 playerId 去 hashmap 中找到这个对应的 node，将其 score 置为 0</li></ul><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - sort<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaderboard</span> &#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> score;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> score)</span> &#123;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.score = score;<br>&#125;<br>&#125;<br>HashMap&lt;Integer, Node&gt; map;<br>List&lt;Node&gt; list;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Leaderboard</span><span class="hljs-params">()</span> &#123;<br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addScore</span><span class="hljs-params">(<span class="hljs-type">int</span> playerId, <span class="hljs-type">int</span> score)</span> &#123;<br><span class="hljs-keyword">if</span> (map.containsKey(playerId)) &#123;<br>map.get(playerId).score += score;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(playerId, score);<br>map.put(playerId, node);<br>list.add(node);<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">(<span class="hljs-type">int</span> K)</span> &#123;<br>Collections.sort(list, (a, b) -&gt; b.score - a.score);<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(K, list.size()); i++) &#123;<br>sum += list.get(i).score;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> playerId)</span> &#123;<br>map.get(playerId).score = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Leaderboard object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Leaderboard obj = new Leaderboard();</span><br><span class="hljs-comment"> * obj.addScore(playerId,score);</span><br><span class="hljs-comment"> * int param_2 = obj.top(K);</span><br><span class="hljs-comment"> * obj.reset(playerId);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sort</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1838. Frequency of the Most Frequent Element</title>
    <link href="/posts/2171882472.html"/>
    <url>/posts/2171882472.html</url>
    
    <content type="html"><![CDATA[<p>The frequency of an element is the number of times it occurs in an array.</p><p>You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.</p><p>Return the maximum possible frequency of an element after performing at most k operations.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,4], k &#x3D; 5<br>Output: 3<br>Explanation: Increment the first element three times and the second element two times to make nums &#x3D; [4,4,4].<br>4 has a frequency of 3.</p><p>Example 2:<br>Input: nums &#x3D; [1,4,8,13], k &#x3D; 5<br>Output: 2<br>Explanation: There are multiple optimal solutions:</p><ul><li>Increment the first element three times to make nums &#x3D; [4,4,8,13]. 4 has a frequency of 2.</li><li>Increment the second element four times to make nums &#x3D; [1,8,8,13]. 8 has a frequency of 2.</li><li>Increment the third element five times to make nums &#x3D; [1,4,13,13]. 13 has a frequency of 2.</li></ul><p>Example 3:<br>Input: nums &#x3D; [3,9,6], k &#x3D; 2<br>Output: 1</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>最高频元素的频数。</p><blockquote><p>元素的 频数 是该元素在一个数组中出现的次数。<br>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。<br>执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element">https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我暂时提供一个滑动窗口的思路，不太好想。注意题目的解释有一点问题，不是只能对着一个元素做加一操作，而是你可以找若干个元素，对这若干个元素分别做加一操作，做 k 次操作。这些元素中有的可以做不止一次操作，只要全局操作次数为 k 即可。但是对哪些元素做加一操作，这就需要用到滑动窗口了。</p><p>首先我们需要对 input 数组排序，之后还是用经典的滑动窗口模板，给出 start 和 end 两个指针。对于 end 指针指向的元素 nums[end]，我们可以把它视为一个 target number，意思是我们试图把其他小于 nums[end] 的元素都通过加一操作变为 nums[end]，从而使得 nums[end] 是出现次数最多的元素。对于 start 和 end 指针夹住的这一段元素，他们的加和很好算；但是如果他们的加和 sum + k 次操作之后的和大于这一段计划中的和的话，则需要移动 start 指针缩短窗口的距离。通过这个方法我们可以算出符合条件的最大的子数组的长度。</p><p>这一段计划中的和应该是<code>出现次数最多的元素 * 个数 = nums[end] * (end - start)</code>。这里 end - start 这个范围不一定准，取决于滑动窗口的代码如何写。</p><p>最后注意数据范围，计算 sum 的时候要用 long 型。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxFrequency</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Arrays.sort(nums);<br><span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>sum += nums[end];<br><span class="hljs-keyword">while</span> (sum + k &lt; (<span class="hljs-type">long</span>) nums[end] * (end - start + <span class="hljs-number">1</span>)) &#123;<br>sum -= nums[start];<br>start++;<br>&#125;<br>res = Math.max(res, end - start + <span class="hljs-number">1</span>);<br>end++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1670. Design Front Middle Back Queue</title>
    <link href="/posts/3222341826.html"/>
    <url>/posts/3222341826.html</url>
    
    <content type="html"><![CDATA[<p>Design a queue that supports push and pop operations in the front, middle, and back.</p><p>Implement the FrontMiddleBack class:<br>FrontMiddleBack() Initializes the queue.<br>void pushFront(int val) Adds val to the front of the queue.<br>void pushMiddle(int val) Adds val to the middle of the queue.<br>void pushBack(int val) Adds val to the back of the queue.<br>int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.<br>int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.<br>int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.<br>Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:<br>Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].<br>Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].</p><p>Example 1:<br>Input:<br>[“FrontMiddleBackQueue”, “pushFront”, “pushBack”, “pushMiddle”, “pushMiddle”, “popFront”, “popMiddle”, “popMiddle”, “popBack”, “popFront”]<br>[[], [1], [2], [3], [4], [], [], [], [], []]<br>Output:<br>[null, null, null, null, null, 1, 3, 4, 2, -1]</p><p>Explanation:<br>FrontMiddleBackQueue q &#x3D; new FrontMiddleBackQueue();<br>q.pushFront(1);   &#x2F;&#x2F; [1]<br>q.pushBack(2);    &#x2F;&#x2F; [1, 2]<br>q.pushMiddle(3);  &#x2F;&#x2F; [1, 3, 2]<br>q.pushMiddle(4);  &#x2F;&#x2F; [1, 4, 3, 2]<br>q.popFront();     &#x2F;&#x2F; return 1 -&gt; [4, 3, 2]<br>q.popMiddle();    &#x2F;&#x2F; return 3 -&gt; [4, 2]<br>q.popMiddle();    &#x2F;&#x2F; return 4 -&gt; [2]<br>q.popBack();      &#x2F;&#x2F; return 2 -&gt; []<br>q.popFront();     &#x2F;&#x2F; return -1 -&gt; [] (The queue is empty)<br>Constraints:</p><p>1 &lt;&#x3D; val &lt;&#x3D; 109<br>At most 1000 calls will be made to pushFront, pushMiddle, pushBack, popFront, popMiddle, and popBack.</p><p>设计前中后队列。</p><blockquote><p>请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。<br>请你完成 FrontMiddleBack 类：<br>FrontMiddleBack() 初始化队列。<br>void pushFront(int val) 将 val 添加到队列的 最前面 。<br>void pushMiddle(int val) 将 val 添加到队列的 正中间 。<br>void pushBack(int val) 将 val 添加到队里的 最后面 。<br>int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：<br>将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。<br>从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-front-middle-back-queue">https://leetcode-cn.com/problems/design-front-middle-back-queue</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道设计题，思路是用两个双端队列deque做。首先我需要创建两个deque，first 和 second。first 在左边，second 在右边。当元素个数为偶数的时候，first 和 second 的元素个数是相同的；但是当元素个数为奇数的时候，right 会比 left 多一个元素。这里我用了一个 balance() 函数确保 right 至多比 left 多一个元素。</p><p>pushFront() - 只会从 left 的左侧加元素</p><p>pushBack() - 只会从 right 的右侧加元素</p><p>popFront() - 只会从 left 的左侧弹出元素</p><p>popBack() - 只会从 right 的右侧弹出元素</p><p>pushMiddle() - 如果两个 deque 元素个数相同，则加入 right；反之则加入 left</p><p>popMiddle() - 如果两个 deque 元素个数相同，则试图弹出 left 的最右侧元素（注意有可能为空）；反之则弹出 right 最左侧的元素</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - 均摊的O(1)，因为需要balance两个queue<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontMiddleBackQueue</span> &#123;<br>    Deque&lt;Integer&gt; first;<br>    Deque&lt;Integer&gt; second;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FrontMiddleBackQueue</span><span class="hljs-params">()</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        second = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushFront</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        first.offerFirst(val);<br>        balance();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushMiddle</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (first.size() &lt; second.size()) &#123;<br>            first.offerLast(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            second.offerFirst(val);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushBack</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        second.offerLast(val);<br>        balance();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">popFront</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> first.pollFirst();<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-literal">null</span>) &#123;<br>            num = second.pollFirst();<br>            <span class="hljs-keyword">return</span> num == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            balance();<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">popMiddle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (first.size() == second.size()) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> first.pollLast();<br>            <span class="hljs-keyword">return</span> num == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> second.pollFirst();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">popBack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> second.pollLast();<br>        balance();<br>        <span class="hljs-keyword">return</span> num == <span class="hljs-literal">null</span> ? -<span class="hljs-number">1</span> : num;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">balance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (first.size() &gt; second.size()) &#123;<br>            second.offerFirst(first.pollLast());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first.size() + <span class="hljs-number">1</span> &lt; second.size()) &#123;<br>            first.offerLast(second.pollFirst());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your FrontMiddleBackQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();</span><br><span class="hljs-comment"> * obj.pushFront(val);</span><br><span class="hljs-comment"> * obj.pushMiddle(val);</span><br><span class="hljs-comment"> * obj.pushBack(val);</span><br><span class="hljs-comment"> * int param_4 = obj.popFront();</span><br><span class="hljs-comment"> * int param_5 = obj.popMiddle();</span><br><span class="hljs-comment"> * int param_6 = obj.popBack();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1704. Determine if String Halves Are Alike</title>
    <link href="/posts/3347588841.html"/>
    <url>/posts/3347588841.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.</p><p>Two strings are alike if they have the same number of vowels (‘a’, ‘e’, ‘i’, ‘o’, ‘u’, ‘A’, ‘E’, ‘I’, ‘O’, ‘U’). Notice that s contains uppercase and lowercase letters.</p><p>Return true if a and b are alike. Otherwise, return false.</p><p>Example 1:<br>Input: s &#x3D; “book”<br>Output: true<br>Explanation: a &#x3D; “bo” and b &#x3D; “ok”. a has 1 vowel and b has 1 vowel. Therefore, they are alike.</p><p>Example 2:<br>Input: s &#x3D; “textbook”<br>Output: false<br>Explanation: a &#x3D; “text” and b &#x3D; “book”. a has 1 vowel whereas b has 2. Therefore, they are not alike.<br>Notice that the vowel o is counted twice.</p><p>Constraints:<br>2 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s.length is even.<br>s consists of uppercase and lowercase letters.</p><p>判断字符串的两半是否相似。</p><blockquote><p>给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。<br>两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。<br>如果 a 和 b 相似，返回 true ；否则，返回 false 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/determine-if-string-halves-are-alike">https://leetcode-cn.com/problems/determine-if-string-halves-are-alike</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 two pointer。用两个指针，从 input 字符串的左右两边往中间逼近，逼近的时候分别检查左指针和右指针各自统计了多少元音字母。最后判断的是左右两边的元音字母的个数是否相等。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">halvesAreAlike</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (isVowel(s.charAt(start))) &#123;<br>                left++;<br>            &#125;<br>            start++;<br>            <span class="hljs-keyword">if</span> (isVowel(s.charAt(end))) &#123;<br>                right++;<br>            &#125;<br>            end--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left == right;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVowel</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span> || c == <span class="hljs-string">&#x27;A&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span> || c == <span class="hljs-string">&#x27;I&#x27;</span> || c == <span class="hljs-string">&#x27;O&#x27;</span><br>                || c == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1749. Maximum Absolute Sum of Any Subarray</title>
    <link href="/posts/2509629052.html"/>
    <url>/posts/2509629052.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, …, numsr-1, numsr] is abs(numsl + numsl+1 + … + numsr-1 + numsr).</p><p>Return the maximum absolute sum of any (possibly empty) subarray of nums.</p><p>Note that abs(x) is defined as follows:<br>If x is a negative integer, then abs(x) &#x3D; -x.<br>If x is a non-negative integer, then abs(x) &#x3D; x.</p><p>Example 1:<br>Input: nums &#x3D; [1,-3,2,3,-4]<br>Output: 5<br>Explanation: The subarray [2,3] has absolute sum &#x3D; abs(2+3) &#x3D; abs(5) &#x3D; 5.</p><p>Example 2:<br>Input: nums &#x3D; [2,-5,1,-4,3,-2]<br>Output: 8<br>Explanation: The subarray [-5,1,-4] has absolute sum &#x3D; abs(-5+1-4) &#x3D; abs(-8) &#x3D; 8.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>任意子数组和的绝对值的最大值。</p><blockquote>给你一个整数数组 nums 。一个子数组 [numsl, numsl+1, ..., numsr-1, numsr] 的 和的绝对值 为 abs(numsl + numsl+1 + ... + numsr-1 + numsr) 。<p>请你找出 nums 中 和的绝对值 最大的任意子数组（可能为空），并返回该 最大值 。</p><p>abs(x) 定义如下：</p><p>如果 x 是负整数，那么 abs(x) &#x3D; -x 。<br>如果 x 是非负整数，那么 abs(x) &#x3D; x 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray">https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前缀和，也带一些动态规划的思想。题目要找的是一段子数组，这一段子数组的和要不然非常大要不然非常小，这样才能使得其绝对值是最大的。但是由于子数组的长度是不确定的所以用一般的前缀和的思路应该是会超时的（O(n^2)的复杂度），主要问题是在于我们并不知道子数组的长度。这道题算是个脑筋急转弯吧，思路有点类似前缀和，但是在统计前缀和的时候我们记录一个前缀和里面全局的最大值 max 和全局的最小值 min。那么最大值和最小值的差值这一段组成的子数组的和就一定是满足题意的最大值。又因为题目问的是绝对值所以无所谓 max 先出现还是 min 先出现。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAbsoluteSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + nums[i];<br>            max = Math.max(max, presum[i + <span class="hljs-number">1</span>]);<br>            min = Math.min(min, presum[i + <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">0</span>, max - min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1801. Number of Orders in the Backlog</title>
    <link href="/posts/3380811999.html"/>
    <url>/posts/3380811999.html</url>
    
    <content type="html"><![CDATA[<p>You are given a 2D integer array orders, where each orders[i] &#x3D; [price, amount, orderType] denotes that amount orders have been placed of type orderType at the price price. The orderTyp is:<br>0 if it is a batch of buy orders, or<br>1 if it is a batch of sell orders.<br>Note that orders[i] represents a batch of amount independent orders with the same price and order type. All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.</p><p>There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:<br>If the order is a buy order, you look at the sell order with the smallest price in the backlog. If that sell order’s price is smaller than or equal to the current buy order’s price, they will match and be executed, and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.</p><p>Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. If that buy order’s price is larger than or equal to the current sell order’s price, they will match and be executed, and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.</p><p>Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/11/ex1.png" alt="Example 1"><br>Input: orders &#x3D; [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]<br>Output: 6<br>Explanation: Here is what happens with the orders:</p><ul><li>5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.</li><li>2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.</li><li>1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.</li><li>4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.<br>Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.</li></ul><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/03/11/ex2.png" alt="Example 2"><br>Input: orders &#x3D; [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]<br>Output: 999999984<br>Explanation: Here is what happens with the orders:</p><ul><li>109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.</li><li>3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.</li><li>999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.</li><li>1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.<br>Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders &#x3D; 1999999991, which is equal to 999999984 % (109 + 7).</li></ul><p>Constraints:<br>1 &lt;&#x3D; orders.length &lt;&#x3D; 105<br>orders[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; pricei, amounti &lt;&#x3D; 109<br>orderTypei is either 0 or 1.</p><p>积压订单中的订单总数。</p><blockquote>给你一个二维整数数组 orders ，其中每个 orders[i] = [price, amount, orderType] 表示有 amount 笔类型为 orderType 、价格为 price 的订单。<p>订单类型 orderType 可以分为两种：<br>0 表示这是一批采购订单 buy<br>1 表示这是一批销售订单 sell<br>注意，orders[i] 表示一批共计 amount 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：<br>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。</p><p>反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。</p><p>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog">https://leetcode-cn.com/problems/number-of-orders-in-the-backlog</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心，具体做法需要用到两个堆，一个最大堆一个最小堆。题目描述里没有明确说明，但是抵消订单是没有先后顺序的，也就是说如果一张可以被抵消的订单出现的比较晚，他还是可以被合适的订单抵消掉。同时这里我们无需考虑订单抵消的合理性，比如一个 buy 订单的 price 很大，他也可以拿来抵消一个 price 很小的 sell 订单。因为我们最后考虑的只是积压订单的数量而不是数额。</p><p>我们为采购订单 buys 创建一个最大堆（相当于是买价最大的买单在顶部），为销售订单 sells 创建一个最小堆（相当于是卖价最小的订单在顶部），然后根据订单的 orderType 来区分到底是采购订单还是销售订单，把订单根据类型分别放到两个堆中。当两个堆都不为空的时候，如果最小堆堆顶元素的 sell price &lt; 最大堆堆顶元素的 buy price，两者就可以匹配，匹配的订单数为两边订单的较小值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberOfBacklogOrders</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] orders)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// [price, amount, buy/sell]</span><br>        <span class="hljs-comment">// maxheap</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; buys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// minheap</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; sells = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] order : orders) &#123;<br>            <span class="hljs-keyword">if</span> (order[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span>) &#123;<br>                buys.offer(order);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sells.offer(order);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!buys.isEmpty() &amp;&amp; !sells.isEmpty() &amp;&amp; sells.peek()[<span class="hljs-number">0</span>] &lt;= buys.peek()[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Math.min(buys.peek()[<span class="hljs-number">1</span>], sells.peek()[<span class="hljs-number">1</span>]);<br>                buys.peek()[<span class="hljs-number">1</span>] -= k;<br>                sells.peek()[<span class="hljs-number">1</span>] -= k;<br>                <span class="hljs-keyword">if</span> (buys.peek()[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>                    buys.poll();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (sells.peek()[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>                    sells.poll();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] order : buys) &#123;<br>            res = (res + order[<span class="hljs-number">1</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] order : sells) &#123;<br>            res = (res + order[<span class="hljs-number">1</span>]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>MOD</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 841. Keys and Rooms</title>
    <link href="/posts/4018564189.html"/>
    <url>/posts/4018564189.html</url>
    
    <content type="html"><![CDATA[<p>There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p><p>When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p><p>Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.</p><p>Example 1:<br>Input: rooms &#x3D; [[1],[2],[3],[]]<br>Output: true<br>Explanation:<br>We visit room 0 and pick up key 1.<br>We then visit room 1 and pick up key 2.<br>We then visit room 2 and pick up key 3.<br>We then visit room 3.<br>Since we were able to visit every room, we return true.</p><p>Example 2:<br>Input: rooms &#x3D; [[1,3],[3,0,1],[2],[0]]<br>Output: false<br>Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.</p><p>Constraints:<br>n &#x3D;&#x3D; rooms.length<br>2 &lt;&#x3D; n &lt;&#x3D; 1000<br>0 &lt;&#x3D; rooms[i].length &lt;&#x3D; 1000<br>1 &lt;&#x3D; sum(rooms[i].length) &lt;&#x3D; 3000<br>0 &lt;&#x3D; rooms[i][j] &lt; n<br>All the values of rooms[i] are unique.</p><p>钥匙和房间。</p><blockquote>有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。<p>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，…，N-1] 中的一个整数表示，其中 N &#x3D; rooms.length。 钥匙 rooms[i][j] &#x3D; v 可以打开编号为 v 的房间。</p><p>最初，除 0 号房间外的其余所有房间都被锁住。</p><p>你可以自由地在房间之间来回走动。</p><p>如果能进入每个房间返回 true，否则返回 false。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/keys-and-rooms">https://leetcode-cn.com/problems/keys-and-rooms</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道图论&#x2F;遍历的题，问是否能访问到每个房间，也就是在问是否能访问到图上的每个点。这道题BFS和DFS都能做，都需要一个额外数组记录某个房间是否有被访问过以避免死循环。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>BFS实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canVisitAllRooms</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rooms.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : rooms.get(cur)) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>                    queue.offer(next);<br>                    visited[next] = <span class="hljs-literal">true</span>;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count == n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canVisitAllRooms</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rooms.size();<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        count++;<br>        dfs(rooms, visited, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count == n;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="hljs-type">boolean</span>[] visited, <span class="hljs-type">int</span> index)</span> &#123;<br>        List&lt;Integer&gt; keys = rooms.get(index);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : keys) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>                visited[next] = <span class="hljs-literal">true</span>;<br>                count++;<br>                dfs(rooms, visited, next);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 670. Maximum Swap</title>
    <link href="/posts/2897332235.html"/>
    <url>/posts/2897332235.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer num. You can swap two digits at most once to get the maximum valued number.</p><p>Return the maximum valued number you can get.</p><p>Example 1:<br>Input: num &#x3D; 2736<br>Output: 7236<br>Explanation: Swap the number 2 and the number 7.</p><p>Example 2:<br>Input: num &#x3D; 9973<br>Output: 9973<br>Explanation: No swap.</p><p>Constraints:<br>0 &lt;&#x3D; num &lt;&#x3D; 108</p><p>最大交换。</p><blockquote>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。<p>示例 1 :<br>输入: 2736<br>输出: 7236<br>解释: 交换数字2和数字7。</p><p>示例 2 :<br>输入: 9973<br>输出: 9973<br>解释: 不需要交换。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基本思路是贪心。将 input 数字转成 char array，再创建一个叫做 bucket 的数组，长度为 10，记录每个数字在 char array 中最后出现的下标。遍历 char array，把每个不同数字最后出现的下标记录好。</p><p>再次遍历 char array，对于 i 位置上的数字 d，我们从 9 到 0 看看是否有一个比 d 更大的数字，如果有，我们再看看这个更大的数字最后一次出现的下标是否大于 i，如果是，则将位置 i 上的这个数字与那个更大的数字交换位置。最后，将 char array 转成数字，返回即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">char</span>[] digits = Integer.toString(num).toCharArray();<br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">// 记录每个不同数字最后一次出现的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; digits.length; i++) &#123;<br>            last[digits[i] - <span class="hljs-string">&#x27;0&#x27;</span>] = i;<br>        &#125;<br><br>        <span class="hljs-comment">// 再次扫描</span><br><span class="hljs-comment">// 对于每个数字，看是否有一个比当前这个数字更大的数字在右边，从9开始看</span><br><span class="hljs-comment">// 若有，就swap过来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; digits.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>; j &gt; digits[i] - <span class="hljs-string">&#x27;0&#x27;</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (i &lt; last[j]) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> digits[i];<br>                    digits[i] = digits[last[j]];<br>                    digits[last[j]] = temp;<br>                    <span class="hljs-keyword">return</span> Integer.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(digits));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 115. Distinct Subsequences</title>
    <link href="/posts/1111500657.html"/>
    <url>/posts/1111500657.html</url>
    
    <content type="html"><![CDATA[<p>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct subsequences of <code>s</code> which equals <code>t</code></em>.</p><p>A string’s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>It is guaranteed the answer fits on a 32-bit signed integer.</p><p>Example 1:<br>Input: s &#x3D; “rabbbit”, t &#x3D; “rabbit”<br>Output: 3<br>Explanation:<br>As shown below, there are 3 ways you can generate “rabbit” from S.<br><code>rabbbit</code><br><code>rabbbit</code><br><code>rabbbit</code></p><p>Example 2:<br>Input: s &#x3D; “babgbag”, t &#x3D; “bag”<br>Output: 5<br>Explanation:<br>As shown below, there are 5 ways you can generate “bag” from S.<br><code>babgbag</code><br><code>babgbag</code><br><code>babgbag</code><br><code>babgbag</code><br><code>babgbag</code></p><p>Constraints:</p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> and <code>t</code> consist of English letters.</li></ul><p>不同的子序列。</p><blockquote><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/distinct-subsequences">https://leetcode-cn.com/problems/distinct-subsequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二维DP。我们首先创建一个二维数组，长度是 int[][] dp &#x3D; new int[s.length() + 1][t.length() + 1]。+1 的部分是DP类型的题的经典操作，<strong>这个DP数组的含义是当 S 以 i 结尾，T 以 j 结尾的时候，满足题意的 subsequence 的个数是多少。</strong></p><p>这里有<a href="https://leetcode-cn.com/problems/distinct-subsequences/solution/pythonti-jie-yi-kan-jiu-dong-de-fen-xi-yao-yao-yao/">几个重点</a>需要提及</p><ul><li>首先如果 T 为空的时候，因为一个空串是任何非空字符串的 subsequence 所以 dp[i][0] &#x3D; 1</li><li>如果 T 不为空，又分如下两种情况，我们用这个例子理解，S &#x3D; ABCC, T &#x3D; ABC<br>如果s.charAt(i - 1) &#x3D;&#x3D; t.charAt(j - 1)，也就是两边字母相同的时候，dp[i][j] &#x3D; dp[i - 1][j] + dp[i - 1][j - 1]。比如例子中如果S和T都走到了各自最后的字母C的时候，这里有匹配，需要比较的是ABCC中含有多少个不同的ABC，这里分两种情况<ul><li>如果我们考虑使用当前这个匹配，我们看一下前面的子串 ABC 和 AB 的匹配情况，对应dp[i - 1][j - 1]</li><li>如果不使用当前这个匹配，也就是说 S 中不包含标红的 C 的时候，我们看一下 S &#x3D; ABC 里面有多少能有多少subsequence能匹配 T，对应dp[i - 1][j]</li></ul></li><li>把如上这两种情况加起来，dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j]<br>如果s.charAt(i - 1) !&#x3D; t.charAt(j - 1)，也就是当前字母不匹配的情况下，我们只需要看 dp[i][j - 1]</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化：空串匹配</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1461. Check If a String Contains All Binary Codes of Size K</title>
    <link href="/posts/3860343257.html"/>
    <url>/posts/3860343257.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary string s and an integer k.</p><p>Return True if every binary code of length k is a substring of s. Otherwise, return False.</p><p>Example 1:<br>Input: s &#x3D; “00110110”, k &#x3D; 2<br>Output: true<br>Explanation: The binary codes of length 2 are “00”, “01”, “10” and “11”. They can be all found as substrings at indicies 0, 1, 3 and 2 respectively.</p><p>Example 2:<br>Input: s &#x3D; “00110”, k &#x3D; 2<br>Output: true</p><p>Example 3:<br>Input: s &#x3D; “0110”, k &#x3D; 1<br>Output: true<br>Explanation: The binary codes of length 1 are “0” and “1”, it is clear that both exist as a substring.</p><p>Example 4:<br>Input: s &#x3D; “0110”, k &#x3D; 2<br>Output: false<br>Explanation: The binary code “00” is of length 2 and doesn’t exist in the array.</p><p>Example 5:<br>Input: s &#x3D; “0000000001011100”, k &#x3D; 4<br>Output: false</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^5<br>s consists of 0’s and 1’s only.<br>1 &lt;&#x3D; k &lt;&#x3D; 20</p><p>检查一个字符串是否包含所有长度为 K 的二进制子串。</p><blockquote><p>给你一个二进制字符串 s 和一个整数 k 。如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 true ，否则请返回 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题问的是在字符串中是否能找到所有长度为 K 的二进制子串，应该不难想到需要用滑动窗口做，但是这里有一个很巧妙的处理，能快速知道你到底需要找多少个子串。因为子串的长度是 K，所以一共需要找 Math.pow(2, k) 个子串。所以这里我们利用一个 hashset，如果遍历完 input 字符串之后 set.size() &#x3D;&#x3D; k 则证明找全了，否则就是有缺失。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasAllCodes</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n - k; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(i, i + k);<br>            set.add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> set.size() == (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window with fixed size</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1481. Least Number of Unique Integers after K Removals</title>
    <link href="/posts/2929899458.html"/>
    <url>/posts/2929899458.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers <code>arr</code> and an integer <code>k</code>. Find the <em>least number of unique integers</em> after removing exactly <code>k</code> elements.</p><p>Example 1:<br>Input: arr &#x3D; [5,5,4], k &#x3D; 1<br>Output: 1<br>Explanation: Remove the single 4, only 5 is left.</p><p>Example 2:<br>Input: arr &#x3D; [4,3,1,1,3,3,2], k &#x3D; 3<br>Output: 2<br>Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.</p><p>Constraints:</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li><li><code>0 &lt;= k &lt;= arr.length</code></li></ul><p>不同整数的最少数目。</p><blockquote><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。现需要从数组中恰好移除 <code>k</code> 个元素，请找出移除后数组中不同整数的最少数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是先用 hashmap 记录每个不同元素的出现次数，然后按照每个元素出现次数从小到大开始删除，直到删除掉K个元素为止。如果当把某个元素全都删掉之后 K &lt; 0，则说明最后这个元素的出现次数不需要全部删除，只需要删除一部分。我这里提供两种实现，一种是最小堆；另一种是通过数组记录不同元素的出现次数，但是需要排序。两种做法都需要用到 hashmap。</p><h2 id="思路一-最小堆"><a href="#思路一-最小堆" class="headerlink" title="思路一 - 最小堆"></a>思路一 - 最小堆</h2><p>用hashmap统计完数字的出现次数之后，我们把hashmap中所有的元素都放入一个最小堆，堆顶是[出现次数最少的元素，出现次数]。这样每次被pop出来的都是出现次数最少的元素。这样做我们可以尽可能多地删掉 unique key，使得最后剩下的部分里 unique key 更少。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLeastNumOfUniqueInts</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map.get(key);<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; key, val &#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] top = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> top[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (k &lt; count) &#123;<br>                <span class="hljs-keyword">return</span> queue.size() + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-hashmap-排序"><a href="#思路二-hashmap-排序" class="headerlink" title="思路二 - hashmap + 排序"></a>思路二 - hashmap + 排序</h2><p>我们需要一个 int 数组，长度为 size，size 记录的是map.size()。我们把 hashmap 里每个 entrySet 放入 count 数组。这样当 count 数组被排序之后，因为 count[i] 表示的是当前某个元素的出现次数，所以还是出现次数较小的在前。其余部分的思路跟第一种做法类似。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLeastNumOfUniqueInts</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();<br><span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>count[i] = map.get(key);<br>i++;<br>&#125;<br>Arrays.sort(count);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : count) &#123;<br><span class="hljs-keyword">if</span> (k &gt;= c) &#123;<br>k -= c;<br>size--;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> size;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1151. Minimum Swaps to Group All 1s Together</title>
    <link href="/posts/663832577.html"/>
    <url>/posts/663832577.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary array data, return the minimum number of swaps required to group all 1’s present in the array together in any place in the array.</p><p>Example 1:<br>Input: data &#x3D; [1,0,1,0,1]<br>Output: 1<br>Explanation: There are 3 ways to group all 1’s together:<br>[1,1,1,0,0] using 1 swap.<br>[0,1,1,1,0] using 2 swaps.<br>[0,0,1,1,1] using 1 swap.<br>The minimum is 1.</p><p>Example 2:<br>Input: data &#x3D; [0,0,0,1,0]<br>Output: 0<br>Explanation: Since there is only one 1 in the array, no swaps are needed.</p><p>Example 3:<br>Input: data &#x3D; [1,0,1,0,1,0,0,1,1,0,1]<br>Output: 3<br>Explanation: One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].</p><p>Constraints:<br>1 &lt;&#x3D; data.length &lt;&#x3D; 105<br>data[i] is either 0 or 1.</p><p>最少交换次数来组合所有的 1。</p><p>给出一个二进制数组 data，你需要通过交换位置，将数组中所有的 1 组合到一起，并返回所有可能中所需最少的交换次数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题问的是 swap 的次数，注意 swap 的策略是有好坏的，这也就是为什么例子一有三种 swap 的结果但是这三种策略的代价是不一样的。我这里提供一个滑动窗口的思路。这道题前缀和也能做，日后有时间我再补充。注意这道题的滑动窗口尺寸是固定的。滑动窗口的尺寸就是 1 的个数。</p><p>首先我们用一个变量 ones 记录 input 数组中一共有多少个 1。然后我们用滑动窗口的模板开始扫描 input 数组，当 end 指针遇到 1 的时候，count++；当 end 和 start 两个指针的距离 &#x3D;&#x3D; ones 的时候，此时我们看一下 end 和 start 之间有几个 1，此时 ones 和 count 的差值就是需要 swap 的次数。遍历整个数组，找到全局最小的 swap 次数即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : data) &#123;<br>            <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) &#123;<br>                ones++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (ones == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (end &lt; data.length) &#123;<br>            <span class="hljs-keyword">if</span> (data[end] == <span class="hljs-number">1</span>) &#123;<br>                count++;<br>            &#125;<br>            end++;<br>            <span class="hljs-keyword">if</span> (end - start == ones) &#123;<br>                res = Math.min(res, ones - count);<br>                <span class="hljs-keyword">if</span> (data[start] == <span class="hljs-number">1</span>) &#123;<br>                    count--;<br>                &#125;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><p>这里我再提供一个 for 循环的代码。因为这道题滑动窗口的 size 是固定的，所以 for 循环也能做。<br>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data)</span> &#123;<br>        <span class="hljs-comment">// 统计一共有多少个1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : data) &#123;<br>            <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) &#123;<br>                ones++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 统计前ones个位置上有多少个1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ones; i++) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">1</span>) &#123;<br>                c++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-comment">// 如果1都在一开始的位置上，则无需swap</span><br>        <span class="hljs-keyword">if</span> (c == ones) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-comment">// min是一开始的位置上需要swap的次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> ones - c;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> ones; j &lt; data.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (data[j] == <span class="hljs-number">1</span>) &#123;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (data[j - ones] == <span class="hljs-number">1</span>) &#123;<br>                k--;<br>            &#125;<br>            min = Math.min(min, ones - k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1151. Minimum Swaps to Group All 1s Together<br>2134. Minimum Swaps to Group All 1s Together II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1717. Maximum Score From Removing Substrings</title>
    <link href="/posts/1397164712.html"/>
    <url>/posts/1397164712.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s and two integers x and y. You can perform two types of operations any number of times.</p><p>Remove substring “ab” and gain x points.<br>For example, when removing “ab” from “cabxbae” it becomes “cxbae”.<br>Remove substring “ba” and gain y points.<br>For example, when removing “ba” from “cabxbae” it becomes “cabxe”.<br>Return the maximum points you can gain after applying the above operations on s.</p><p>Example 1:<br>Input: s &#x3D; “cdbcbbaaabab”, x &#x3D; 4, y &#x3D; 5<br>Output: 19<br>Explanation:</p><ul><li>Remove the “ba” underlined in “cdbcbbaaabab”. Now, s &#x3D; “cdbcbbaaab” and 5 points are added to the score.</li><li>Remove the “ab” underlined in “cdbcbbaaab”. Now, s &#x3D; “cdbcbbaa” and 4 points are added to the score.</li><li>Remove the “ba” underlined in “cdbcbbaa”. Now, s &#x3D; “cdbcba” and 5 points are added to the score.</li><li>Remove the “ba” underlined in “cdbcba”. Now, s &#x3D; “cdbc” and 5 points are added to the score.<br>Total score &#x3D; 5 + 4 + 5 + 5 &#x3D; 19.</li></ul><p>Example 2:<br>Input: s &#x3D; “aabbaaxybbaabb”, x &#x3D; 5, y &#x3D; 4<br>Output: 20</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>1 &lt;&#x3D; x, y &lt;&#x3D; 104<br>s consists of lowercase English letters.</p><p>删除子字符串的最大得分。</p><blockquote><p>给你一个字符串 s 和两个整数 x 和 y 。你可以执行下面两种操作任意次。</p><p>删除子字符串 “ab” 并得到 x 分。<br>比方说，从 “cabxbae” 删除 ab ，得到 “cxbae” 。<br>删除子字符串”ba” 并得到 y 分。<br>比方说，从 “cabxbae” 删除 ba ，得到 “cabxe” 。<br>请返回对 s 字符串执行上面操作若干次能得到的最大得分。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-score-from-removing-substrings">https://leetcode-cn.com/problems/maximum-score-from-removing-substrings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-栈"><a href="#思路一-栈" class="headerlink" title="思路一 - 栈"></a>思路一 - 栈</h2><p>这道题总体的思路是贪心，做法一我先给出一个需要用到<code>额外空间</code>的做法。我需要用到<code>两个 stack</code>。首先我预处理一下 input，这样我知道到底是 ab 组合得分更高还是 ba 组合得分更高。接着我开始遍历 input 字符串，我优先处理得分高的组合，比如如果得分高的组合是 ab 的话，当我遇到 ab 这样的子串，我优先处理，然后把它的得分加到 res 中；其他不是 ab 的字母全都加到第一个栈中，记为 stack1。</p><p>接着我再从 stack1 中把所有字符串倒出来，因为栈是先进后出的，所以如果一开始我处理的是 ab 的话，那么我现在正好可以处理 ba 这种子串了。注意 ba 从 stack 里倒出来的时候，其实是以 ab 的顺序出来的（这也就是11行和21行判断 first 和 second 的代码是一样的原因）。从 stack1 中弹出的字符我放到另一个栈，记为 stack2。这样我可以利用 stack2 获取到 ba 这种组合同时记录它的得分。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumGain</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        Stack&lt;Character&gt; stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Stack&lt;Character&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(x, y);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(x, y);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> (x &gt; y) ? <span class="hljs-string">&#x27;a&#x27;</span> : <span class="hljs-string">&#x27;b&#x27;</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> (x &gt; y) ? <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (!stack1.isEmpty() &amp;&amp; stack1.peek() == first &amp;&amp; c == second) &#123;<br>                stack1.pop();<br>                res += max;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack1.push(c);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stack1.isEmpty()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> stack1.pop();<br>            <span class="hljs-keyword">if</span> (!stack2.isEmpty() &amp;&amp; stack2.peek() == first &amp;&amp; c == second) &#123;<br>                stack2.pop();<br>                res += min;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack2.push(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// stack</span><br></code></pre></td></tr></table></figure><h2 id="思路二-无需额外空间"><a href="#思路二-无需额外空间" class="headerlink" title="思路二 - 无需额外空间"></a>思路二 - 无需额外空间</h2><p>做法二是一个更优的做法，它不需要额外的空间。我们首先还是需要对得分进行预处理。若 x &lt; y，我们交换 x 和 y，也交换 a 和 b。这意味着：我们总是先处理得分高的组合 a+b。</p><ul><li>如果 x &gt; y，就先处理 “ab”</li><li>如果 x &lt; y，就先处理 “ba”</li></ul><p>整个代码后续都用变量 a 和 b 处理，和是 “ab” 还是 “ba” 无关。</p><p>设两个变量 count1 记录 a 出现的次数，count2 记录 b 出现的次数。开始遍历 input 字符串，如果当前字符是 a，因为我们需要先凑 ab 组合，所以当我们遇到 a 的时候，暂且 count1++，因为只要等到后面有 b 出现的时候，才能将得分最大化。如果当前字符是 b，我们需要判断前面是否有 a 出现过，如果有的话，说明可以凑成 ab 组合，此时我们就将 count1 减一，并将得分加上 x。否则的话，我们就将 count2++，因为我们需要等到后面有 a 出现的时候才能凑成 ba 组合。如果当前字符既不是 a 也不是 b，说明我们到了一个<code>分段点</code>。把当前段里剩下的 a 和 b 尝试做第二优先级的组合（即得分较低的组合），得 y 分；然后把这段配对状态清空（cnt1 &#x3D; cnt2 &#x3D; 0）。记得最后还要再做一次计算因为最后一个字符有可能是 a 或 b。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumGain</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;b&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>            a = b;<br>            b = a;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempScore</span> <span class="hljs-operator">=</span> x;<br>            x = y;<br>            y = tempScore;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == a) &#123;<br>                count1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == b) &#123;<br>                <span class="hljs-keyword">if</span> (count1 &gt; <span class="hljs-number">0</span>) &#123;<br>                    count1--;<br>                    res += x;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    count2++;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += Math.min(count1, count2) * y;<br>                count1 = <span class="hljs-number">0</span>;<br>                count2 = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        res += Math.min(count1, count2) * y;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 304. Range Sum Query 2D - Immutable</title>
    <link href="/posts/629787401.html"/>
    <url>/posts/629787401.html</url>
    
    <content type="html"><![CDATA[<p>Given a 2D matrix matrix, handle multiple queries of the following type:</p><p>Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p><p>Implement the NumMatrix class:</p><p>NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.<br>int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).<br>You must design an algorithm where sumRegion works on O(1) time complexity.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg" alt="Example 1"><br>Input<br>[“NumMatrix”, “sumRegion”, “sumRegion”, “sumRegion”]<br>[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]<br>Output<br>[null, 8, 11, 12]</p><p>Explanation<br>NumMatrix numMatrix &#x3D; new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (i.e sum of the red rectangle)<br>numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (i.e sum of the green rectangle)<br>numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (i.e sum of the blue rectangle)</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>-104 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 104<br>0 &lt;&#x3D; row1 &lt;&#x3D; row2 &lt; m<br>0 &lt;&#x3D; col1 &lt;&#x3D; col2 &lt; n<br>At most 104 calls will be made to sumRegion.</p><p>二维区域和检索 - 矩阵不可变。</p><blockquote><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p><p>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 NumMatrix 类：</p><p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable">https://leetcode.cn/problems/range-sum-query-2d-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟303题类似，也是<code>差分数组</code>的题，思路也是前缀和。这里因为 input 矩阵不能修改，我们必须创建一个额外的二维数组记录结果。我这里给一个<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/dai-tu-shi-java-er-wei-qian-zhui-he-by-c-pebj/">很好的图示</a>帮助理解。<br><img src="https://pic.leetcode-cn.com/1614615488-IBbfAx-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2.png" alt="图示"></p><p>sumRegion(A,D) &#x3D; sumRegion(O,D) - sumRegion(O,E) - sumRegion(O,F) + sumRegion(O,G)</p><p>我们先用一个二维矩阵 grid 记录了整个 input 矩阵的二维前缀和。如果要求整个二维矩阵的前缀和 sumRegion(O, D), 可以直接返回 grid[x + 1][y + 1]，但是上面这个式子记忆的时候下标容易出错，我是这样记的。</p><p>OD - OE - OF + OG，中间减去的那两个部分一个需要横坐标 - 1，一个需要纵坐标 - 1</p><p>[x2 + 1, y2 + 1] - [x1, y2 + 1] - [x2 + 1. y1] + [x1, y1]</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-comment">// grid[i+1][j+1] = sumRegion(0,0,i,j)</span><br>    <span class="hljs-type">int</span>[][] grid;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                grid[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = grid[i + <span class="hljs-number">1</span>][j] + grid[i][j + <span class="hljs-number">1</span>] + matrix[i][j] - grid[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br><span class="hljs-comment">// [x2 + 1, y2 + 1] - [x1, y2 + 1] - [x2 + 1, y1] + [x1, y1]</span><br><span class="hljs-comment">// [22, 12, 21, 11]</span><br>        <span class="hljs-keyword">return</span> grid[row2 + <span class="hljs-number">1</span>][col2 + <span class="hljs-number">1</span>] - grid[row1][col2 + <span class="hljs-number">1</span>] - grid[row2 + <span class="hljs-number">1</span>][col1] + grid[row1][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">303. Range Sum Query - Immutable<br>304. Range Sum Query 2D - Immutable<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>prefix sum</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 303. Range Sum Query - Immutable</title>
    <link href="/posts/2810047019.html"/>
    <url>/posts/2810047019.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, handle multiple queries of the following type:<br>Calculate the sum of the elements of nums between indices left and right inclusive where left &lt;&#x3D; right.</p><p>Implement the NumArray class:<br>NumArray(int[] nums) Initializes the object with the integer array nums.<br>int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + … + nums[right]).</p><p>Example 1:<br>Input<br>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]<br>Output<br>[null, 1, -1, -3]</p><p>Explanation<br>NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return (-2) + 0 + 3 &#x3D; 1<br>numArray.sumRange(2, 5); &#x2F;&#x2F; return 3 + (-5) + 2 + (-1) &#x3D; -1<br>numArray.sumRange(0, 5); &#x2F;&#x2F; return (-2) + 0 + 3 + (-5) + 2 + (-1) &#x3D; -3</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; left &lt;&#x3D; right &lt; nums.length<br>At most 104 calls will be made to sumRange.</p><p>区域和检索 - 数组不可变。</p><blockquote>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。<p>实现 NumArray 类：<br>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable">https://leetcode-cn.com/problems/range-sum-query-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题求的是某一个范围内的数组元素的和，思路是前缀和。因为 int sumRange(int i, int j) 求的是闭区间 [i, j] 内所有元素的和所以我们创建一个 nums.length + 1 长度的数组记录前缀和。这样我们就能做到在求 sumRange() 这个函数的时候时间复杂度为O(1)了。代码注释帮助理解记忆这个前缀和的写法，这样不容易发生越界的报错。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间<br>prepare - O(n)<br>sumRange() - O(1)</p><p>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br>    <span class="hljs-type">int</span>[] presum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        presum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// for循环按原数组的长度来，思考presum每个位置应该存什么，就不容易发生越界</span><br><span class="hljs-comment">// 按如下这个规则写，前x项的前缀和是存在preSum[x + 1]位置上的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">return</span> presum[right + <span class="hljs-number">1</span>] - presum[left];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">303. Range Sum Query - Immutable<br>304. Range Sum Query 2D - Immutable<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>prefix sum</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1561. Maximum Number of Coins You Can Get</title>
    <link href="/posts/3851844021.html"/>
    <url>/posts/3851844021.html</url>
    
    <content type="html"><![CDATA[<p>There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:<br>In each step, you will choose any 3 piles of coins (not necessarily consecutive).<br>Of your choice, Alice will pick the pile with the maximum number of coins.<br>You will pick the next pile with maximum number of coins.<br>Your friend Bob will pick the last pile.<br>Repeat until there are no more piles of coins.<br>Given an array of integers piles where piles[i] is the number of coins in the ith pile.</p><p>Return the maximum number of coins which you can have.</p><p>Example 1:<br>Input: piles &#x3D; [2,4,1,2,7,8]<br>Output: 9<br>Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.<br>Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.<br>The maximum number of coins which you can have are: 7 + 2 &#x3D; 9.<br>On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 &#x3D; 6 coins which is not optimal.</p><p>Example 2:<br>Input: piles &#x3D; [2,4,5]<br>Output: 4</p><p>Example 3:<br>Input: piles &#x3D; [9,8,7,6,5,1,2,3,4]<br>Output: 18</p><p>你可以获得的最大硬币数目。</p><blockquote><p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：<br>每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。<br>Alice 将会取走硬币数量最多的那一堆。<br>你将会取走硬币数量第二多的那一堆。<br>Bob 将会取走最后一堆。<br>重复这个过程，直到没有更多硬币。<br>给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。<br>返回你可以获得的最大硬币数目。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get">https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是排序 + two pointer。这道题我们必须排序，否则是拿不到次多的那一堆的。排序完之后，我们用左右两个指针逼近中间，左指针 i 指向的是每次选取的三堆硬币中最少的，右指针 j 指向的是每次选取的三堆硬币中最多的，j - 1 指向的是次多的。要选取的次数是piles.length &#x2F; 3。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxCoins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles)</span> &#123;<br>        Arrays.sort(piles);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> piles.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; count != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; j - <span class="hljs-number">1</span>) &#123;<br>                res += piles[j - <span class="hljs-number">1</span>];<br>                count--;<br>            &#125;<br>            i++;<br>            j -= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1052. Grumpy Bookstore Owner</title>
    <link href="/posts/2939645324.html"/>
    <url>/posts/2939645324.html</url>
    
    <content type="html"><![CDATA[<p>Today, the bookstore owner has a store open for customers.length minutes.  Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.</p><p>On some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, grumpy[i] &#x3D; 1, otherwise grumpy[i] &#x3D; 0.  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</p><p>The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.</p><p>Return the maximum number of customers that can be satisfied throughout the day.</p><p>Example 1:<br>Input: customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3<br>Output: 16<br>Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes.<br>The maximum number of customers that can be satisfied &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.</p><p>Note:<br>1 &lt;&#x3D; X &lt;&#x3D; customers.length &#x3D;&#x3D; grumpy.length &lt;&#x3D; 20000<br>0 &lt;&#x3D; customers[i] &lt;&#x3D; 1000<br>0 &lt;&#x3D; grumpy[i] &lt;&#x3D; 1</p><p>爱生气的书店老板。</p><blockquote>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。<p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] &#x3D; 1，否则 grumpy[i] &#x3D; 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner">https://leetcode-cn.com/problems/grumpy-bookstore-owner</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口。这道题我提供两个做法，一个是固定长度的滑动窗口，一个是类似76题的那种模板。<br>可以用固定长度做是因为老板有一次机会可以让自己连续 X 分钟不生气。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码一-固定长度的滑动窗口"><a href="#代码一-固定长度的滑动窗口" class="headerlink" title="代码一 - 固定长度的滑动窗口"></a>代码一 - 固定长度的滑动窗口</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSatisfied</span><span class="hljs-params">(<span class="hljs-type">int</span>[] customers, <span class="hljs-type">int</span>[] grumpy, <span class="hljs-type">int</span> minutes)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> customers.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> minutes;<br>        <span class="hljs-comment">// 如果前k分钟不生气的满意值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            sum += customers[i];<br>        &#125;<br><span class="hljs-comment">// 之后的分钟按是否生气正常累加客户的满意值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grumpy[i] == <span class="hljs-number">0</span>) &#123;<br>                sum += customers[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> sum;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grumpy[i] == <span class="hljs-number">1</span>) &#123;<br>                sum += customers[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (grumpy[i - k] == <span class="hljs-number">1</span>) &#123;<br>                sum -= customers[i - k];<br>            &#125;<br>            res = Math.max(res, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSatisfied</span><span class="hljs-params">(<span class="hljs-type">int</span>[] customers, <span class="hljs-type">int</span>[] grumpy, <span class="hljs-type">int</span> minutes)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">satisfied</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> customers.length;<br><span class="hljs-comment">// 老板不生气的时段内顾客的满意度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grumpy[i] == <span class="hljs-number">0</span>) &#123;<br>                satisfied += customers[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (grumpy[end] == <span class="hljs-number">1</span>) &#123;<br>                curSum += customers[end];<br>            &#125;<br>            end++;<br><span class="hljs-comment">// 如果长度正好等于minutes，统计当前max的值，代表能有多少顾客的满意度可以被改变</span><br>            <span class="hljs-keyword">if</span> (end - start == minutes) &#123;<br>                max = Math.max(max, curSum);<br>                <span class="hljs-keyword">if</span> (grumpy[start] == <span class="hljs-number">1</span>) &#123;<br>                    curSum -= customers[start];<br>                &#125;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> satisfied + max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1052. Grumpy Bookstore Owner<br>1849. Grumpy Bookstore Owner<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 765. Couples Holding Hands</title>
    <link href="/posts/3447756879.html"/>
    <url>/posts/3447756879.html</url>
    
    <content type="html"><![CDATA[<p>There are n couples sitting in 2n seats arranged in a row and want to hold hands.</p><p>The people and seats are represented by an integer array row where row[i] is the ID of the person sitting in the ith seat. The couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2n - 2, 2n - 1).</p><p>Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p><p>Example 1:<br>Input: row &#x3D; [0,2,1,3]<br>Output: 1<br>Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</p><p>Example 2:<br>Input: row &#x3D; [3,2,0,1]<br>Output: 0<br>Explanation: All couples are already seated side by side.</p><p>Constraints:<br>2n &#x3D;&#x3D; row.length<br>2 &lt;&#x3D; n &lt;&#x3D; 30<br>n is even.<br>0 &lt;&#x3D; row[i] &lt; 2n<br>All the elements of row are unique.</p><p>情侣牵手。</p><blockquote><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。<br>人和座位用 0 到 2N - 1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N - 2, 2N - 1)。<br>这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决定的。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/couples-holding-hands">https://leetcode-cn.com/problems/couples-holding-hands</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题有两种思路，一种是贪心，一种是并查集 union find。我这里先给出贪心的思路。同时建议可以先做一下41题，思路类似。</p><p>这个题贪心的做法跟桶排序类似，还是试着将每个坐标上放应该放的数字。过一下第一个例子，[0, 2, 1, 3]。第一个数字是0，那么第二个数字的判断就是看他是否是第一个数字0的配偶。判断配偶的方式是看当前这个nums[i + 1]是不是等于nums[i] ^ 1。这一点不容易想到。因为配偶的座位排序要求不是非常严格，比如0和1，既可以01这样坐，也可以10这样坐。但是位运算的这个特点就可以无视0和1的顺序，来判断两个相邻的数字是否互为配偶。如果想不到这个位运算的办法，那么就只能通过先判断当前index上数字的奇偶性来判断index + 1那个位置上的数字是否是配偶。贪心的做法为什么对呢？我这里引用一个<a href="https://leetcode.com/problems/couples-holding-hands/discuss/113359/Java-AC-O(n)-greedy-solution./254186">discussion给的例子</a>，并且稍加解释。</p><blockquote><p>The proof is easy. Consider a simple example: 7 1 4 6 2 3 0 5. At first step we have two choice to match the first couple: swap 7 with 0, or swap 1 with 6. Then we get 0 1 4 6 2 3 7 5 or 7 6 4 1 2 3 0 5. Pay attention that the first couple doesn’t count any more. For the later part it is composed of 4 X 2 3 Y 5 (X&#x3D;6 Y&#x3D;7 or X&#x3D;1 Y&#x3D;0). Since different couples are unrelated, we don’t care X Y is 6 7 pair or 0 1 pair. They are equivalent! Thus it means our choice doesn’t count.<br>Therefore, just follow the distinction and you will get it right!</p></blockquote><p>具体实现的时候，这里我需要一个<code>idx</code>数组，记录一开始每个数字的下标是多少，因为之后 input 数组会被修改所以需要把一开始的状态记录下来。</p><p>接着开始遍历，每次走两格，因为题目规定一定是比如[0, 1], [2, 3], [4, 5]这种组合坐在一起，所以情侣之间应该满足一个是奇数一个是偶数且奇数是较大的那一个。知道这个规则之后，对于每一个我们遇到的数字，我们去 row 里找他配对的数字 next 在哪里，如果 next 正好在下一个 index <code>i + 1</code>那么就已经是配对好了的，反之就要找到这个数字并放到 index <code>i + 1</code> 这个位置上。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-type">int</span>[] row)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> row.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>[] idx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-comment">// 记录每个数字当前的下标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>idx[row[i]] = i;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br><span class="hljs-comment">// 每两个作为一对，它们必然是紧邻的奇偶数，且偶数更小，故可推出另一个</span><br><span class="hljs-comment">// 0 - 当前是偶数，那么配对是奇数</span><br><span class="hljs-comment">// 1 - 当前是奇数，那么配对是偶数</span><br><span class="hljs-comment">// next是配对数字在idx数组中的下标</span><br>next = (row[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? row[i] + <span class="hljs-number">1</span> : row[i] - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 如果row[i],row[i+1]已然是一对，就跳过</span><br><span class="hljs-keyword">if</span> (next == row[i + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 反之，进行交换，使row[i+1]能和row[i]为一对</span><br><span class="hljs-comment">// 即将当前row[i+1]的值放到next所在下标去，注意交换顺序</span><br><span class="hljs-type">int</span> <span class="hljs-variable">nextIdx</span> <span class="hljs-operator">=</span> idx[next]; <span class="hljs-comment">// 配对数字的下标</span><br>idx[row[i + <span class="hljs-number">1</span>]] = nextIdx; <span class="hljs-comment">// 把配对数字的下标放到i + 1这个位置上</span><br>row[nextIdx] = row[i + <span class="hljs-number">1</span>];<br>count++;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>graph</tag>
      
      <tag>union find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1208. Get Equal Substrings Within Budget</title>
    <link href="/posts/2802235815.html"/>
    <url>/posts/2802235815.html</url>
    
    <content type="html"><![CDATA[<p>You are given two strings s and t of the same length and an integer maxCost.</p><p>You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).</p><p>Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.</p><p>Example 1:<br>Input: s &#x3D; “abcd”, t &#x3D; “bcdf”, maxCost &#x3D; 3<br>Output: 3<br>Explanation: “abc” of s can change to “bcd”.<br>That costs 3, so the maximum length is 3.</p><p>Example 2:<br>Input: s &#x3D; “abcd”, t &#x3D; “cdef”, maxCost &#x3D; 3<br>Output: 1<br>Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.</p><p>Example 3:<br>Input: s &#x3D; “abcd”, t &#x3D; “acde”, maxCost &#x3D; 0<br>Output: 1<br>Explanation: You cannot make any change, so the maximum length is 1.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>t.length &#x3D;&#x3D; s.length<br>0 &lt;&#x3D; maxCost &lt;&#x3D; 106<br>s and t consist of only lowercase English letters.</p><p>尽可能使字符串相等。</p><blockquote>给你两个长度相同的字符串，s 和 t。<p>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget">https://leetcode-cn.com/problems/get-equal-substrings-within-budget</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是滑动窗口，而且可以用模板。模板参见 76 题。可以消耗的开销一共是 maxCost，对于每个相同位置上的字符的 ASCII 码的差值，可以通过先移动 end 指针不断消耗 maxCost，直到 maxCost &#x3D;&#x3D; 0。当 maxCost &#x3D;&#x3D; 0 的时候，可以试图移动 start 指针，过程中记录 res 的最大值即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">equalSubstring</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> maxCost)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; len) &#123;<br>            maxCost -= Math.abs(s.charAt(end) - t.charAt(end));<br>            end++;<br>            <span class="hljs-keyword">while</span> (maxCost &lt; <span class="hljs-number">0</span>) &#123;<br>                maxCost += Math.abs(s.charAt(start) - t.charAt(start));<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1423. Maximum Points You Can Obtain from Cards</title>
    <link href="/posts/4252400418.html"/>
    <url>/posts/4252400418.html</url>
    
    <content type="html"><![CDATA[<p>There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.</p><p>In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.</p><p>Your score is the sum of the points of the cards you have taken.</p><p>Given the integer array cardPoints and the integer k, return the maximum score you can obtain.</p><p>Example 1:<br>Input: cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3<br>Output: 12<br>Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 &#x3D; 12.</p><p>Example 2:<br>Input: cardPoints &#x3D; [2,2,2], k &#x3D; 2<br>Output: 4<br>Explanation: Regardless of which two cards you take, your score will always be 4.</p><p>Example 3:<br>Input: cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7<br>Output: 55<br>Explanation: You have to take all the cards. Your score is the sum of points of all cards.</p><p>Example 4:<br>Input: cardPoints &#x3D; [1,1000,1], k &#x3D; 1<br>Output: 1<br>Explanation: You cannot take the card in the middle. Your best score is 1. </p><p>Example 5:<br>Input: cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3<br>Output: 202</p><p>Constraints:<br>1 &lt;&#x3D; cardPoints.length &lt;&#x3D; 105<br>1 &lt;&#x3D; cardPoints[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; cardPoints.length</p><p>可获得的最大点数。</p><blockquote><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。<br>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。<br>你的点数就是你拿到手中的所有卡牌的点数之和。<br>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards">https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题有两种做法，一种是前缀和 + 滑动窗口，另一种是动态规划，我这里暂时先提供前一种做法。动态规划的思路我自己想清楚了日后再补充。这道题滑动窗口的思路也可以应用到 1509 题。</p><p>题设说的拿掉卡牌的规则是一定要从数组的两端拿，一共拿 k 张牌。那么我一开始可以先从数组的左边拿 k 张牌，设这 k 张牌的点数之和为 sum，然后每次从数组左边靠中间的部分去掉一张牌并用一张数组右侧的牌替换，看看所有卡牌点数的加和是否能更大。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(k)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cardPoints, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cardPoints.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>sum += cardPoints[i];<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> sum;<br><span class="hljs-keyword">while</span> (index &lt; k) &#123;<br>sum -= cardPoints[k - <span class="hljs-number">1</span> - index];<br>sum += cardPoints[n - <span class="hljs-number">1</span> - index];<br>max = Math.max(max, sum);<br>index++;<br>&#125;<br><span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 923. 3Sum With Multiplicity</title>
    <link href="/posts/269569957.html"/>
    <url>/posts/269569957.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] &#x3D;&#x3D; target.</p><p>As the answer can be very large, return it modulo 109 + 7.</p><p>Example 1:<br>Input: arr &#x3D; [1,1,2,2,3,3,4,4,5,5], target &#x3D; 8<br>Output: 20<br>Explanation:<br>Enumerating by the values (arr[i], arr[j], arr[k]):<br>(1, 2, 5) occurs 8 times;<br>(1, 3, 4) occurs 8 times;<br>(2, 2, 4) occurs 2 times;<br>(2, 3, 3) occurs 2 times.</p><p>Example 2:<br>Input: arr &#x3D; [1,1,2,2,2,2], target &#x3D; 5<br>Output: 12<br>Explanation:<br>arr[i] &#x3D; 1, arr[j] &#x3D; arr[k] &#x3D; 2 occurs 12 times:<br>We choose one 1 from [1,1] in 2 ways,<br>and two 2s from [2,2,2,2] in 6 ways.</p><p>Example 3:<br>Input: arr &#x3D; [2,1,3], target &#x3D; 6<br>Output: 1<br>Explanation: (1, 2, 3) occured one time in the array so we return 1.</p><p>Constraints:<br>3 &lt;&#x3D; arr.length &lt;&#x3D; 3000<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 100<br>0 &lt;&#x3D; target &lt;&#x3D; 300</p><p>多重三数之和。</p><blockquote><p>给定一个整数数组 arr ，以及一个整数 target 作为目标值，返回满足 i &lt; j &lt; k 且 arr[i] + arr[j] + arr[k] &#x3D;&#x3D; target 的元组 i, j, k 的数量。</p><p>由于结果会非常大，请返回 109 + 7 的模。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/3sum-with-multiplicity">https://leetcode.cn/problems/3sum-with-multiplicity</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题我们找的是一个满足题意的三元组，但是注意因为 input 里面给的数字是有重复的，所以计算的时候要小心一些。因为题目要求三个数的下标要满足 i &lt; j &lt; k，这道题的做法是类似 two sum 的思路，也是先固定前两个数字，然后在剩下的数字中寻找第三个数字。不同的是，这道题的 input 数组里面有重复的数字，所以我们需要记录每个数字出现的次数。</p><p>首先我们记录一下 input 数组里面每个数字都分别出现的次数，用一个 count 数组记录好。接着我们还是按 3sum 的思路开始遍历，首先确定前两个数字 i, j（注意这里的 i, j, k 其实不是下标，题目说的不清楚，这里其实指的是三数之和里三个不同的数字），那么要找的第三个数字 k &#x3D; target - i - j。如果 k 的范围不在 0 - 100 则说明是一个无效的组合（因为题目的数据范围规定 0 &lt;&#x3D; arr[i] &lt;&#x3D; 100），直接跳过即可；当 k 是一个有效的数字的时候，也需要判断如下几种 case</p><ul><li>如果 i &#x3D;&#x3D; j &amp;&amp; j &#x3D;&#x3D; k，说明 i, j, k 三个数字相同。对于三个数字相同的组合，他们可以产生的组合数量是 count[i] * (count[i] - 1) * (count[i] - 2) &#x2F; 6</li><li>如果 i &#x3D;&#x3D; j &amp;&amp; j !&#x3D; k, 说明其中两个数字相同，组合数量是 count[i] * (count[i] - 1) &#x2F; 2 * count[k]</li><li>如果三个数字都互不相同，组合数量是 count[i] * count[j] * count[k]</li></ul><p>这个做法巧妙之处在于他扫描的不是原数组，而是根据题目给的数据范围去扫描（0 - 100）。比如第一个例子的 target &#x3D; 8，input数组里有 1 和 2，假设此时没有 5 的话，根据我们的算法，count[5] &#x3D;&#x3D; 0，所以 1 + 2 + 5 &#x3D; 8 这个组合也不会找的到。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threeSumMulti</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">long</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            count[num]++;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 注意res的类型，极容易错</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= <span class="hljs-number">100</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> target - i - j;<br>                <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">100</span> || k &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 三个数相同</span><br>                <span class="hljs-keyword">if</span> (i == j &amp;&amp; j == k) &#123;<br>                    res += count[i] * (count[i] - <span class="hljs-number">1</span>) * (count[i] - <span class="hljs-number">2</span>) / <span class="hljs-number">6</span>;<br>                &#125;<br>                <span class="hljs-comment">// 其中两个数相同</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j &amp;&amp; j != k) &#123;<br>                    res += count[i] * (count[i] - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> * count[k];<br>                &#125;<br>                <span class="hljs-comment">// 三个数各不相同</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; j &lt; k) &#123;<br>                    res += count[i] * count[j] * count[k];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % MOD);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 643. Maximum Average Subarray I</title>
    <link href="/posts/2019896287.html"/>
    <url>/posts/2019896287.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums consisting of n elements, and an integer k.</p><p>Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.</p><p>Example 1:<br>Input: nums &#x3D; [1,12,-5,-6,50,3], k &#x3D; 4<br>Output: 12.75000<br>Explanation: Maximum average is (12 - 5 - 6 + 50) &#x2F; 4 &#x3D; 51 &#x2F; 4 &#x3D; 12.75</p><p>Example 2:<br>Input: nums &#x3D; [5], k &#x3D; 1<br>Output: 5.00000</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>子数组最大平均数 I。</p><blockquote>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。<p>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p><p>任何误差小于 10-5 的答案都将被视为正确答案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-average-subarray-i">https://leetcode.cn/problems/maximum-average-subarray-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路是滑动窗口，但是窗口的长度是固定的，为 k。我们先计算一下数组前 k 个数的和；然后从第 k + 1 个数开始，分别计算不同窗口里面数字的 sum，并且记录一个最大的 sum。最后再计算平均值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMaxAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> sum;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            sum = sum + nums[i] - nums[i - k];<br>            max = Math.max(max, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max / k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findMaxAverage = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        sum += nums[i];<br>    &#125;<br>    <span class="hljs-keyword">let</span> maxSum = sum;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        sum = sum - nums[i - k] + nums[i];<br>        maxSum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxSum, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> * maxSum / k;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1657. Determine if Two Strings Are Close</title>
    <link href="/posts/1169337340.html"/>
    <url>/posts/1169337340.html</url>
    
    <content type="html"><![CDATA[<p>Two strings are considered close if you can attain one from the other using the following operations:</p><p>Operation 1: Swap any two existing characters.<br>For example, abcde -&gt; aecdb<br>Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.<br>For example, aacabb -&gt; bbcbaa (all a’s turn into b’s, and all b’s turn into a’s)<br>You can use the operations on either string as many times as necessary.</p><p>Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.</p><p>Example 1:<br>Input: word1 &#x3D; “abc”, word2 &#x3D; “bca”<br>Output: true<br>Explanation: You can attain word2 from word1 in 2 operations.<br>Apply Operation 1: “abc” -&gt; “acb”<br>Apply Operation 1: “acb” -&gt; “bca”</p><p>Example 2:<br>Input: word1 &#x3D; “a”, word2 &#x3D; “aa”<br>Output: false<br>Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.</p><p>Example 3:<br>Input: word1 &#x3D; “cabbba”, word2 &#x3D; “abbccc”<br>Output: true<br>Explanation: You can attain word2 from word1 in 3 operations.<br>Apply Operation 1: “cabbba” -&gt; “caabbb”<br>Apply Operation 2: “caabbb” -&gt; “baaccc”<br>Apply Operation 2: “baaccc” -&gt; “abbccc”</p><p>Constraints:<br>1 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 105<br>word1 and word2 contain only lowercase English letters.</p><p>确定两个字符串是否接近。</p><blockquote><p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：<br>操作 1：交换任意两个 现有 字符。<br>例如，abcde -&gt; aecdb<br>操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。<br>例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）<br>你可以根据需要对任意一个字符串多次使用这两种操作。<br>给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/determine-if-two-strings-are-close">https://leetcode-cn.com/problems/determine-if-two-strings-are-close</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。这道题按照给的两种操作来判断，注意标红的条件，这两种操作可以被执行多次。</p><p>先说操作 1，如果要满足交换任意两个字符 char，使得 A 变成 B，那么这两个被交换的字符的出现次数一定要相同才行，也就是说在字符串 A 中如果你要替换某个字母 x，那么在字符串 B 中相同 index 位置上的那个字母 y 的出现次数要跟 x 相同才行。</p><p>对于操作 2，如果要满足将一个现有字符替换成另一个现有字符，比如题目给的例子，那么需要满足第一个字符串中 a 的数量 &#x3D; 第二个字符串中 b 的数量，同时第一个字符串中 b 的数量 &#x3D; 第二个字符串中 a 的数量。这两个条件转化成代码就是检查两个字符串中所有出现过的字母的数量是不是能一一对应（字母不一定相同）。参见<a href="https://leetcode.com/problems/determine-if-two-strings-are-close/discuss/935920/C++-Short-and-Simple-oror-O(-N-)-solution">这个例子</a>，如果所有出现的字母的次数在排序后能对的上，则执行操作 2 就能满足题意。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">closeStrings</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (word1.length() != word2.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span>[] count1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] count2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            count1[word1.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            count2[word2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (count1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count2[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count2[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count1[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        Arrays.sort(count1);<br>        Arrays.sort(count2);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (count1[i] != count2[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1338. Reduce Array Size to The Half</title>
    <link href="/posts/4045788427.html"/>
    <url>/posts/4045788427.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.</p><p>Return the minimum size of the set so that at least half of the integers of the array are removed.</p><p>Example 1:<br>Input: arr &#x3D; [3,3,3,3,5,5,5,2,2,7]<br>Output: 2<br>Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).<br>Possible sets of size 2 are {3,5},{3,2},{5,2}.<br>Choosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has a size greater than half of the size of the old array.</p><p>Example 2:<br>Input: arr &#x3D; [7,7,7,7,7,7]<br>Output: 1<br>Explanation: The only possible set you can choose is {7}. This will make the new array empty.</p><p>Constraints:<br>2 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>arr.length is even.<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 105</p><p>数组大小减半。</p><blockquote>给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。<p>返回 至少 能删除数组中的一半整数的整数集合的最小大小。</p></blockquote><h2 id="思路一-counting-sort"><a href="#思路一-counting-sort" class="headerlink" title="思路一 - counting sort"></a>思路一 - counting sort</h2><p>首先我们看一下数组中出现的最大元素是什么，记录为 max。之后我们创建一个长度为 max + 1 的数组 count，记录所有元素的出现次数，并在记录完毕之后对其排序。当这个 count 数组有序之后，我们从元素最大的地方开始统计，计算一下每个元素的出现次数，当统计到数组中一半整数为止。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSetSize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            max = Math.max(max, num);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            count[num]++;<br>        &#125;<br>        Arrays.sort(count);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> count.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            half -= count[i];<br>            res++;<br>            <span class="hljs-keyword">if</span> (half &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-最大堆"><a href="#思路二-最大堆" class="headerlink" title="思路二 - 最大堆"></a>思路二 - 最大堆</h2><p>既然是试图删除数组中的一些 unique 的元素，使得删除的元素数量尽量大，但是这个集合尽量小，那么我们就需要统计每个元素在 input 数组中的出现次数。这里我们用 hashmap 统计，统计好的结果我们存入一个以 priority queue 表示的最大堆，堆顶是出现次数最多的数字。这样每次堆顶元素弹出的时候，他的出现次数是当前最多的，这样才能尽快地删除数组中一半整数。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSetSize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// [key, value]</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : map.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> map.get(num);<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; num, val &#125;);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; n / <span class="hljs-number">2</span>) &#123;<br>            count += queue.poll()[<span class="hljs-number">1</span>];<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>counting sort</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 984. String Without AAA or BBB</title>
    <link href="/posts/567095977.html"/>
    <url>/posts/567095977.html</url>
    
    <content type="html"><![CDATA[<p>Given two integers a and b, return any string s such that:</p><ul><li>s has length a + b and contains exactly a ‘a’ letters, and exactly b ‘b’ letters,</li><li>The substring ‘aaa’ does not occur in s, and</li><li>The substring ‘bbb’ does not occur in s.</li></ul><p>Example 1:<br>Input: a &#x3D; 1, b &#x3D; 2<br>Output: “abb”<br>Explanation: “abb”, “bab” and “bba” are all correct answers.</p><p>Example 2:<br>Input: a &#x3D; 4, b &#x3D; 1<br>Output: “aabaa”</p><p>Constraints:<br>0 &lt;&#x3D; a, b &lt;&#x3D; 100<br>It is guaranteed such an s exists for the given a and b.</p><p>不含 AAA 或 BBB 的字符串。</p><blockquote>给定两个整数 A 和 B，返回任意字符串 S，要求满足：<p>S 的长度为 A + B，且正好包含 A 个 ‘a’ 字母与 B 个 ‘b’ 字母；<br>子串 ‘aaa’ 没有出现在 S 中；<br>子串 ‘bbb’ 没有出现在 S 中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-without-aaa-or-bbb">https://leetcode-cn.com/problems/string-without-aaa-or-bbb</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>这道题的大体思想是贪心，但是这道题我会提供两种不同的贪心思路。</p><p>这道题算是 1405 题的前置题，因为只涉及两个字母。基本思路是优先放更多的字母，除非这个字母已经连续出现过两次了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码一-一般的贪心"><a href="#代码一-一般的贪心" class="headerlink" title="代码一 - 一般的贪心"></a>代码一 - 一般的贪心</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">strWithout3a3b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a + b;<br>        <span class="hljs-keyword">while</span> (sb.length() &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> ((a &gt; b &amp;&amp; c1 &lt; <span class="hljs-number">2</span>) || (c2 == <span class="hljs-number">2</span>)) &#123;<br>                sb.append(<span class="hljs-string">&#x27;a&#x27;</span>);<br>                c1++;<br>                c2 = <span class="hljs-number">0</span>;<br>                a--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(<span class="hljs-string">&#x27;b&#x27;</span>);<br>                c2++;<br>                c1 = <span class="hljs-number">0</span>;<br>                b--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码二-用到优先队列的贪心，对于这道题显得没必要"><a href="#代码二-用到优先队列的贪心，对于这道题显得没必要" class="headerlink" title="代码二 - 用到优先队列的贪心，对于这道题显得没必要"></a>代码二 - 用到优先队列的贪心，对于这道题显得没必要</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">strWithout3a3b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y[<span class="hljs-number">1</span>] - x[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">0</span>, a &#125;);<br>        <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>) queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">1</span>, b &#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sb.length();<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (sb.charAt(len - <span class="hljs-number">1</span>) == (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + cur[<span class="hljs-number">0</span>]) &amp;&amp; sb.charAt(len - <span class="hljs-number">2</span>) == (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + cur[<span class="hljs-number">0</span>])) &#123;<br>                    <span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-type">int</span>[] next = queue.poll();<br>                    sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + next[<span class="hljs-number">0</span>]));<br>                    <span class="hljs-keyword">if</span> (--next[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                        queue.offer(next);<br>                    &#125;<br>                    queue.offer(cur);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + cur[<span class="hljs-number">0</span>]));<br>                    <span class="hljs-keyword">if</span> (--cur[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                        queue.offer(cur);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + cur[<span class="hljs-number">0</span>]));<br><span class="hljs-keyword">if</span> (--cur[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>queue.offer(cur);<br>&#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>另一种做法的思想是，因为 A 和 B 这两个字母一定有一个更多，我们可以将 A 和 B 先一一交替放入结果集，类似 ABABAB 这样，然后再考虑把多出来的字母插入 ABABAB 并且保证不要超过同时出现三次这个条件。所以我们先统计一下哪个字母更多，并生成那个 AB 交替的字符串。这里对于交替字符串的生成，我选择先放出现次数少的那个字母，因为这样我才可以将出现次数更多的字母 attach 到这个 StringBuilder 的最前面。如果多的字母还未用完，那么我可以尝试将这个较多的字母再放到每一个较少的字母后面。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">strWithout3a3b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;b&#x27;</span>;<br>        <span class="hljs-comment">// c1是较少的字母，c2是较多的字母</span><br>        <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>            c1 = <span class="hljs-string">&#x27;b&#x27;</span>;<br>            c2 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; b &gt; <span class="hljs-number">0</span>) &#123;<br>            sb.append(c1);<br>            sb.append(c2);<br>            a--;<br>            b--;<br>        &#125;<br><br>        <span class="hljs-comment">// c2是较多的字母</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> c2;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(a, b);<br>        <span class="hljs-comment">// 因为c1是较少的字母，我们才可以把c2放到c1的前面</span><br>        <span class="hljs-keyword">if</span> (max &gt;= <span class="hljs-number">2</span>) &#123;<br>            sb2.append(c2);<br>            sb2.append(c2);<br>            max -= <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">0</span>) &#123;<br>            sb2.append(c2);<br>            max--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sb.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (sb.charAt(i) == c) &#123;<br>                sb2.append(sb.charAt(i));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb2.append(sb.charAt(i));<br>                <span class="hljs-keyword">if</span> (max &gt; <span class="hljs-number">0</span>) &#123;<br>                    sb2.append(c);<br>                    max--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb2.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">984. String Without AAA or BBB<br>1405. Longest Happy String<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1405. Longest Happy String</title>
    <link href="/posts/765065633.html"/>
    <url>/posts/765065633.html</url>
    
    <content type="html"><![CDATA[<p>A string s is called happy if it satisfies the following conditions:</p><ul><li>s only contains the letters ‘a’, ‘b’, and ‘c’.</li><li>s does not contain any of “aaa”, “bbb”, or “ccc” as a substring.</li><li>s contains at most a occurrences of the letter ‘a’.</li><li>s contains at most b occurrences of the letter ‘b’.</li><li>s contains at most c occurrences of the letter ‘c’.</li></ul><p>Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string “”.</p><p>A substring is a contiguous sequence of characters within a string.</p><p>Example 1:<br>Input: a &#x3D; 1, b &#x3D; 1, c &#x3D; 7<br>Output: “ccaccbcc”<br>Explanation: “ccbccacc” would also be a correct answer.</p><p>Example 2:<br>Input: a &#x3D; 7, b &#x3D; 1, c &#x3D; 0<br>Output: “aabaa”<br>Explanation: It is the only correct answer in this case.</p><p>Constraints:<br>0 &lt;&#x3D; a, b, c &lt;&#x3D; 100<br>a + b + c &gt; 0</p><p>最长快乐字符串。</p><blockquote>如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。<p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p><p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-happy-string">https://leetcode-cn.com/problems/longest-happy-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题其实是 984 题的升级版，984 题只有 A 和 B 两个字母，这道题需要处理三个不同字母。</p><p>这道题的思路是贪心。这道题的贪心贪的就是尽可能先用剩余个数最多的字母。具体做法是我们用一个优先队列把三个字母及其次数放进去，次数最多的字母在堆顶。如果当前堆顶的字母已经在 res 里连续拼接过两次了，就需要再弹出下一个字母，直到堆空或者下一个字母不和当前堆顶的字母连续。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestDiverseString</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br><span class="hljs-comment">// [&#x27;a&#x27;, count]</span><br>PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y[<span class="hljs-number">1</span>] - x[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">0</span>, a&#125;);<br><span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>) queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, b&#125;);<br><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>) queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">2</span>, c&#125;);<br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">int</span>[] cur = queue.poll();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br><span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">2</span> &amp;&amp; sb.charAt(n - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;a&#x27;</span> == cur[<span class="hljs-number">0</span>] &amp;&amp; sb.charAt(n - <span class="hljs-number">2</span>) - <span class="hljs-string">&#x27;a&#x27;</span> == cur[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-type">int</span>[] next = queue.poll();<br>sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + next[<span class="hljs-number">0</span>]));<br><span class="hljs-keyword">if</span> (--next[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>queue.offer(next);<br>&#125;<br>queue.offer(cur);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + cur[<span class="hljs-number">0</span>]));<br><span class="hljs-keyword">if</span> (--cur[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>queue.offer(cur);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">984. String Without AAA or BBB<br>1405. Longest Happy String<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1471. The k Strongest Values in an Array</title>
    <link href="/posts/119670836.html"/>
    <url>/posts/119670836.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers arr and an integer k.</p><p>A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| &gt; |arr[j] - m| where m is the median of the array.<br>If |arr[i] - m| &#x3D;&#x3D; |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] &gt; arr[j].</p><p>Return a list of the strongest k values in the array. return the answer in any arbitrary order.</p><p>Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) &#x2F; 2) in the sorted list (0-indexed).</p><p>For arr &#x3D; [6, -3, 7, 2, 11], n &#x3D; 5 and the median is obtained by sorting the array arr &#x3D; [-3, 2, 6, 7, 11] and the median is arr[m] where m &#x3D; ((5 - 1) &#x2F; 2) &#x3D; 2. The median is 6.<br>For arr &#x3D; [-7, 22, 17, 3], n &#x3D; 4 and the median is obtained by sorting the array arr &#x3D; [-7, 3, 17, 22] and the median is arr[m] where m &#x3D; ((4 - 1) &#x2F; 2) &#x3D; 1. The median is 3.</p><p>Example 1:<br>Input: arr &#x3D; [1,2,3,4,5], k &#x3D; 2<br>Output: [5,1]<br>Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.<br>Please note that although |5 - 3| &#x3D;&#x3D; |1 - 3| but 5 is stronger than 1 because 5 &gt; 1.</p><p>Example 2:<br>Input: arr &#x3D; [1,1,3,5,5], k &#x3D; 2<br>Output: [5,5]<br>Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].</p><p>Example 3:<br>Input: arr &#x3D; [6,7,11,7,6,8], k &#x3D; 5<br>Output: [11,8,6,6,7]<br>Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].<br>Any permutation of [11,8,6,6,7] is accepted.</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-105 &lt;&#x3D; arr[i] &lt;&#x3D; 105<br>1 &lt;&#x3D; k &lt;&#x3D; arr.length</p><p>数组中的 k 个最强值。</p><blockquote>给你一个整数数组 arr 和一个整数 k 。<p>设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 arr[i] 的值比 arr[j] 的值更强：</p><p>|arr[i] - m| &gt; |arr[j] - m|<br>|arr[i] - m| &#x3D;&#x3D; |arr[j] - m|，且 arr[i] &gt; arr[j]<br>请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。</p><p>中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 ((n - 1) &#x2F; 2) 的元素。</p><p>例如 arr &#x3D; [6, -3, 7, 2, 11]，n &#x3D; 5：数组排序后得到 arr &#x3D; [-3, 2, 6, 7, 11] ，数组的中间位置为 m &#x3D; ((5 - 1) &#x2F; 2) &#x3D; 2 ，中位数 arr[m] 的值为 6 。<br>例如 arr &#x3D; [-7, 22, 17, 3]，n &#x3D; 4：数组排序后得到 arr &#x3D; [-7, 3, 17, 22] ，数组的中间位置为 m &#x3D; ((4 - 1) &#x2F; 2) &#x3D; 1 ，中位数 arr[m] 的值为 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/the-k-strongest-values-in-an-array">https://leetcode-cn.com/problems/the-k-strongest-values-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 two pointer。首先为了求中位数，对input数组排序是不可避免的了，排序完之后就可以找到中位数。注意这道题的中位数有<code>自己的定义</code>。因为 input 数组被排序了所以我们可以利用左右两个指针，分别根据规则计算左右指针指向的元素的强度。因为中位数一定是在排序后的数组中比较中间的位置，同时强度的计算又和数字与中位数的距离挂钩，所以数组两端的数字应该是 input 数组中强度最大的。接下来我们就可以按照规则计算找到强度最大的前 k 个元素，并视情况而定去移动左右指针。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getStrongest(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        Arrays.sort(arr);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> arr[(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; index &lt; k) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(arr[left] - m) &gt; Math.abs(arr[right] - m)) &#123;<br>                res[index++] = arr[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[index++] = arr[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 744. Find Smallest Letter Greater Than Target</title>
    <link href="/posts/3106797658.html"/>
    <url>/posts/3106797658.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.</p><p>Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.</p><p>Example 1:<br>Input: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “a”<br>Output: “c”<br>Explanation: The smallest character that is lexicographically greater than ‘a’ in letters is ‘c’.</p><p>Example 2:<br>Input: letters &#x3D; [“c”,”f”,”j”], target &#x3D; “c”<br>Output: “f”<br>Explanation: The smallest character that is lexicographically greater than ‘c’ in letters is ‘f’.</p><p>Example 3:<br>Input: letters &#x3D; [“x”,”x”,”y”,”y”], target &#x3D; “z”<br>Output: “x”<br>Explanation: There are no characters in letters that is lexicographically greater than ‘z’ so we return letters[0].</p><p>Constraints:<br>2 &lt;&#x3D; letters.length &lt;&#x3D; 104<br>letters[i] is a lowercase English letter.<br>letters is sorted in non-decreasing order.<br>letters contains at least two different characters.<br>target is a lowercase English letter.</p><p>寻找比目标字母大的最小字母。</p><blockquote>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。<p>在比较时，字母是依序循环出现的。举个例子：</p><p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target">https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最优解是二分法，当然线性的做法也是可以的。</p><p>这里有一个 corner case 需要判断，就是如果 target 字母 &gt;&#x3D; input 数组的最后一个字母，那么我们返回的是 input 数组的首字母。其他环节都是正常的二分法判断。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">nextGreatestLetter</span><span class="hljs-params">(<span class="hljs-type">char</span>[] letters, <span class="hljs-type">char</span> target)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> letters.length;<br>        <span class="hljs-keyword">if</span> (target &gt;= letters[n - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> letters[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (letters[mid] &lt;= target) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (letters[left] &gt; target) &#123;<br>            <span class="hljs-keyword">return</span> letters[left];<br>        &#125;<br>        <span class="hljs-keyword">return</span> letters[right];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 二分查找模板 binary search</title>
    <link href="/posts/3220296722.html"/>
    <url>/posts/3220296722.html</url>
    
    <content type="html"><![CDATA[<p>二分法是算法题里面一个比较基础但是很容易错的概念，一开始练习的时候由于不熟悉二分法的套路，反复出现死循环或者目标值找错，非常影响做题心情。我总结了如下几个模板。原则上这里的模板无论你使用哪一个，都可以解决二分法类型的问题，只不过有一些题目，比如寻找一个最大值&#x2F;最小值的，可能某一个模板更适合，需要判断的条件较少。</p><p><strong>如下模板是用Java实现的</strong></p><p>模板一，找有序数组中是否存在一个目标值。注意 right 指针一开始定义是在数组下标范围内的，所以 while 的条件才能写成 &lt;&#x3D;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// left和right都在数组下标范围内</span><br>        <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// while循环跳出的条件是right &lt; left</span><br>        <span class="hljs-comment">// 如果没找到target的话，也不需要特判了</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果没找到就只能返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板二，适合判断当前 index 和 index + 1 之间的关系。right 指针一开始的定义是在数组下标范围外的，[left, right)，所以在需要移动 right 指针的时候不能写成 right &#x3D; mid - 1。这样会遗漏掉一些下标的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// right不在下标范围内</span><br>        <span class="hljs-comment">// [left, right)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// while循环跳出的条件是left == right</span><br>        <span class="hljs-comment">// 这个模板比较适合判断当前index和index + 1之间的关系</span><br>        <span class="hljs-comment">// left &lt; right, example, left = 0, right = 1</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 因为搜索范围是左闭右开所以这里不能-1</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后的特判</span><br>        <span class="hljs-keyword">if</span> (left != nums.length &amp;&amp; nums[left] == target) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板三，适用于查找有序数组中某个元素是否存在。若不存在，往往题目要求返回 -1。注意 right 指针一开始定义是在数组下标范围内的，while条件不满足的时候，left + 1 &#x3D;&#x3D; right，两下标应该指向某个下标 i 和 i + 1。这样如果有什么特殊的值需要判断，应该不是 left 就是 right 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// left和right都在数组下标范围内</span><br>        <span class="hljs-comment">// [left, right]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 举例，start - 0, end = 3</span><br>        <span class="hljs-comment">// 中间隔了起码有start + 1和start + 2两个下标</span><br>        <span class="hljs-comment">// 这样跳出while循环的时候，start + 1 == end</span><br>        <span class="hljs-comment">// 才有了最后的两个判断</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 特判</span><br>        <span class="hljs-keyword">if</span> (nums[left] == target) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-comment">// 如果没找到就只能返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这 3 个模板的不同之处在于：</p><p>左、中、右索引的分配。<br>循环或递归终止条件。<br>后处理的必要性。<br>模板 #1 和 #3 是最常用的，几乎所有二分查找问题都可以用其中之一轻松实现。模板 #2 更高级一些，用于解决某些类型的问题。</p><p>这 3 个模板中的每一个都提供了一个特定的用例</p><p><strong>模板 #1 (left &lt;&#x3D; right)</strong></p><p>二分查找的最基础和最基本的形式。<br>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。<br>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</p><p><strong>模板 #2 (left &lt; right)</strong></p><p>一种实现二分查找的高级方法。<br>查找条件需要访问元素的直接右邻居。<br>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。<br>保证查找空间在每一步中至少有 2 个元素。<br>需要进行后处理。 当你剩下 1 个元素时，循环 &#x2F; 递归结束。 需要评估剩余元素是否符合条件。</p><p><strong>模板 #3 (left + 1 &lt; right)</strong></p><p>实现二分查找的另一种方法。<br>搜索条件需要访问元素的直接左右邻居。<br>使用元素的邻居来确定它是向右还是向左。<br>保证查找空间在每个步骤中至少有 3 个元素。<br>需要进行后处理。 当剩下 2 个元素时，循环 &#x2F; 递归结束。 需要评估其余元素是否符合条件。</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode-cn.com/leetbook/read/binary-search/xewjg7/">https://leetcode-cn.com/leetbook/read/binary-search/xewjg7/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><a href="https://shurui91.github.io/posts/939082724.html">LeetCode 题目总结</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 633. Sum of Square Numbers</title>
    <link href="/posts/2502926144.html"/>
    <url>/posts/2502926144.html</url>
    
    <content type="html"><![CDATA[<p>Given a non-negative integer c, decide whether there’re two integers a and b such that a2 + b2 &#x3D; c.</p><p>Example 1:<br>Input: c &#x3D; 5<br>Output: true<br>Explanation: 1 * 1 + 2 * 2 &#x3D; 5</p><p>Example 2:<br>Input: c &#x3D; 3<br>Output: false</p><p>Example 3:<br>Input: c &#x3D; 4<br>Output: true</p><p>Example 4:<br>Input: c &#x3D; 2<br>Output: true</p><p>Example 5:<br>Input: c &#x3D; 1<br>Output: true</p><p>Constraints:<br>0 &lt;&#x3D; c &lt;&#x3D; 231 - 1</p><p>平方数之和。</p><blockquote>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个数字 C，请判断是否存在另外两个数字 A 和 B，满足 A 平方 + B 平方 &#x3D; C 平方。</p><p>思路是双指针逼近。根据题意，A 和 B 的范围一定比 C 的平方根要小，所以 A 和 B 的取值范围是 <code>0 - Math.sqrt(C)</code>。可以将 left &#x3D; 0，right &#x3D; Math.sqrt(C) 做二分，其余部分就是二分法题目的常规判断了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) Math.sqrt(c);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            res = left * left + right * right;<br>            <span class="hljs-keyword">if</span> (res == c) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &gt; c) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1695. Maximum Erasure Value</title>
    <link href="/posts/3675741170.html"/>
    <url>/posts/3675741170.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.</p><p>Return the maximum score you can get by erasing exactly one subarray.</p><p>An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],…,a[r] for some (l,r).</p><p>Example 1:<br>Input: nums &#x3D; [4,2,4,5,6]<br>Output: 17<br>Explanation: The optimal subarray here is [2,4,5,6].</p><p>Example 2:<br>Input: nums &#x3D; [5,2,1,2,5,2,1,2,5]<br>Output: 8<br>Explanation: The optimal subarray here is [5,2,1] or [1,2,5].</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>删除子数组的最大得分。</p><blockquote><p>给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。</p><p>返回 只删除一个 子数组可获得的 最大得分 。</p><p>如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-erasure-value">https://leetcode-cn.com/problems/maximum-erasure-value</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-滑动窗口"><a href="#思路一-滑动窗口" class="headerlink" title="思路一 - 滑动窗口"></a>思路一 - 滑动窗口</h2><p>这道题可以用滑动窗口做，而且跟第 3 题很接近。这里我们找的是一个子数组的和，子数组的数字们都是互不相同的，我们用 hashset 来检查窗口内部的元素是否有重复。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[end];<br>            <span class="hljs-keyword">if</span> (!set.contains(num)) &#123;<br>                set.add(num);<br>                sum += num;<br>                res = Math.max(res, sum);<br>                end++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set.remove(nums[start]);<br>                sum -= nums[start];<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个更快的代码"><a href="#一个更快的代码" class="headerlink" title="一个更快的代码"></a>一个更快的代码</h2><p>这里我再提供一个用数组当做 hashset 的实现，思路是一样的，但是运行速度快很多。<br>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10001</span>];<br>        <span class="hljs-keyword">while</span> (end &lt; len) &#123;<br>            <span class="hljs-keyword">if</span> (set[nums[end]] == <span class="hljs-number">0</span>) &#123;<br>                sum += nums[end];<br>                set[nums[end]] = <span class="hljs-number">1</span>;<br>                end++;<br>                res = Math.max(res, sum);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum -= nums[start];<br>                set[nums[start]] = <span class="hljs-number">0</span>;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-前缀和"><a href="#思路二-前缀和" class="headerlink" title="思路二 - 前缀和"></a>思路二 - 前缀和</h2><p>这道题也可以用前缀和的思路实现。首先需要创建一个长度为 len + 1 的数组记录input数组的前缀和。也是需要左右两个指针，一开始右指针往前走，并同时将当前数字 nums[end] 及其下标的对应关系记录在hashmap里。当我们遇到一个 nums[end] 存在于 hashmap 的时候，我们需要开始挪动 start 指针，一直挪动到覆盖掉 nums[end] 第一次出现的 index + 1 为止。一个需要考虑的corner case是如果整个数组都没有重复数字，目标子数组的和就是整个数组的和。这也就是为什么这道题计算前缀和的部分跟别的题稍有不同的原因之一。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumUniqueSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// sums[0] = nums[0];</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            sums[i + <span class="hljs-number">1</span>] = sums[i] + nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; len) &#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(nums[end])) &#123;<br>                res = Math.max(res, sums[end] - sums[start]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> map.get(nums[end]);<br>                <span class="hljs-keyword">while</span> (start &lt; lastIndex + <span class="hljs-number">1</span>) &#123;<br>                    map.remove(nums[start]);<br>                    start++;<br>                &#125;<br>            &#125;<br>            map.put(nums[end], end);<br>            end++;<br>        &#125;<br>        <span class="hljs-comment">// corner case, when end pointer keeps moving until the end of the array</span><br>        res = Math.max(res, sums[end] - sums[start]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">3. Longest Substring Without Repeating Characters<br>1695. Maximum Erasure Value<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1679. Max Number of K-Sum Pairs</title>
    <link href="/posts/2723676600.html"/>
    <url>/posts/2723676600.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array nums and an integer k.</p><p>In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.</p><p>Return the maximum number of operations you can perform on the array.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,4], k &#x3D; 5<br>Output: 2<br>Explanation: Starting with nums &#x3D; [1,2,3,4]:</p><ul><li>Remove numbers 1 and 4, then nums &#x3D; [2,3]</li><li>Remove numbers 2 and 3, then nums &#x3D; []<br>There are no more pairs that sum up to 5, hence a total of 2 operations.</li></ul><p>Example 2:<br>Input: nums &#x3D; [3,1,3,4,3], k &#x3D; 6<br>Output: 1<br>Explanation: Starting with nums &#x3D; [3,1,3,4,3]:</p><ul><li>Remove the first two 3’s, then nums &#x3D; [1,4,3]<br>There are no more pairs that sum up to 6, hence a total of 1 operation.</li></ul><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; k &lt;&#x3D; 109</p><p>K 和数对的最大数目。</p><blockquote>给你一个整数数组 nums 和一个整数 k 。<p>每一步操作中，你需要从数组中选出和为 k 的两个整数，并将它们移出数组。</p><p>返回你可以对数组执行的最大操作数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/max-number-of-k-sum-pairs">https://leetcode-cn.com/problems/max-number-of-k-sum-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路类似 two sum，我们需要创建一个 hashmap 来记录 input 中的数字，以便找到 <code>k - nums[i]</code>。这里我提供三种实现方式。</p><h2 id="思路一-扫描一次"><a href="#思路一-扫描一次" class="headerlink" title="思路一 - 扫描一次"></a>思路一 - 扫描一次</h2><p>扫描一次的做法巧妙的地方在于他对当 <code>nums[i]</code> 正好是 K 的一半的 case 的处理。当 <code>nums[i]</code> 正好是K的一半的时候，此时 res 只 + 1，这样就能跟其他情况 merge 在一起而无需扫描两遍了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (map.getOrDefault(k - num, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                map.put(k - num, map.get(k - num) - <span class="hljs-number">1</span>);<br>                res++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-扫描两次"><a href="#思路二-扫描两次" class="headerlink" title="思路二 - 扫描两次"></a>思路二 - 扫描两次</h2><p>第一遍扫描用 hashmap 记录每个数字出现的次数。第二次扫描试着找 hashmap 里是否存在两个不同数字满足 a + b &#x3D;&#x3D; k。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> first : map.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> k - first;<br>            <span class="hljs-keyword">if</span> (map.containsKey(second)) &#123;<br>                <span class="hljs-keyword">if</span> (first == second) &#123;<br>                    res += map.get(first) / <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(map.get(first), map.get(second));<br>                    res += min;<br>                    map.put(first, map.get(first) - min);<br>                    map.put(second, map.get(second) - min);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路三-排序-双指针"><a href="#思路三-排序-双指针" class="headerlink" title="思路三 - 排序 + 双指针"></a>思路三 - 排序 + 双指针</h2><p>因为题目只说每次操作需要找一对数字满足 a + b &#x3D; k，不需要考虑重复元素，所以可以先对 input 数组排序，排序过后看两边指针指向的元素之和是否等于 k。</p><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span> (sum == k) &#123;<br>                count++;<br>                left++;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; k) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1457. Pseudo-Palindromic Paths in a Binary Tree</title>
    <link href="/posts/805821143.html"/>
    <url>/posts/805821143.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.</p><p>Return the number of pseudo-palindromic paths going from the root node to leaf nodes.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png" alt="image"><br>Input: root &#x3D; [2,3,1,3,1,null,1]<br>Output: 2<br>Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png" alt="image"><br>Input: root &#x3D; [2,1,1,1,3,null,null,null,null,null,1]<br>Output: 1<br>Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).</p><p>Example 3:<br>Input: root &#x3D; [9]<br>Output: 1</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 105].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 9</p><p>二叉树中的伪回文路径。</p><blockquote><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。<br>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前序遍历 + 回溯。用前序遍历的方法遍历整棵树，在遍历的过程中记录用一个长度为 10 的数组记录每个不同 node.val 的出现次数。遍历到叶子节点的时候看一下数组里出现次数为奇数的元素有几个，如果有超过1个元素的出现次数为奇数，那么当前这条从根节点到叶子节点的路径就不是回文路径。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pseudoPalindromicPaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>helper(root, map);<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span>[] map)</span> &#123;<br><span class="hljs-comment">// base case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>map[root.val]++;<br><span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (isPalindrome(map)) &#123;<br>count++;<br>&#125;<br>&#125;<br>helper(root.left, map);<br>helper(root.right, map);<br>map[root.val]--;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span>[] map)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.length; i++) &#123;<br><span class="hljs-keyword">if</span> (map[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>single++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> single &gt; <span class="hljs-number">1</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1358. Number of Substrings Containing All Three Characters</title>
    <link href="/posts/2596969875.html"/>
    <url>/posts/2596969875.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s consisting only of characters a, b and c.</p><p>Return the number of substrings containing at least one occurrence of all these characters a, b and c.</p><p>Example 1:<br>Input: s &#x3D; “abcabc”<br>Output: 10<br>Explanation: The substrings containing at least one occurrence of the characters a, b and c are “abc”, “abca”, “abcab”, “abcabc”, “bca”, “bcab”, “bcabc”, “cab”, “cabc” and “abc” (again).</p><p>Example 2:<br>Input: s &#x3D; “aaacb”<br>Output: 3<br>Explanation: The substrings containing at least one occurrence of the characters a, b and c are “aaacb”, “aacb” and “acb”.</p><p>Example 3:<br>Input: s &#x3D; “abc”<br>Output: 1</p><p>Constraints:<br>3 &lt;&#x3D; s.length &lt;&#x3D; 5 x 10^4<br>s only consists of a, b or c characters.</p><p>包含所有三种字符的子字符串数目。</p><blockquote><p>给你一个字符串 s ，它只包含三种字符 a, b 和 c 。</p><p>请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难想到这是一道滑动窗口的题，因为窗口内的子串需要满足 abc 三个字母同时出现，但是这道题不太容易思考的地方在于怎么计算满足题意的子串数量。</p><p>对于大部分的滑动窗口题，我们一开始还是移动右指针 <code>end</code> 来看看左右指针之间 <code>[start, end]</code> 的部分是否满足题意，就这道题而言，移动右指针，同时统计左右指针之间 abc 三个字母各自的出现次数。当 abc 三个字母的出现次数都分别大于 0 时，我们就可以考虑移动左指针，直到不满足题意的子串。</p><p>注意当我们第一次满足 <code>abc 三个字母的出现次数都分别大于 0 时</code> 这个条件的时候，我们就可以尝试移动左指针 <code>start</code> 了。此时 <code>[start, end]</code> 之间的子串都是满足题意的，直到我们移动左指针 <code>start</code> 导致 abc 中某个字母的出现次数变为 0。所以在 <code>start</code> 指针移动过程中，结果是累加的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            map[c1 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            end++;<br>            <span class="hljs-comment">// 只有abc出现次数都大于0的时候才移动左指针</span><br>            <span class="hljs-keyword">while</span> (map[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; map[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; map[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2 - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                start++;<br>            &#125;<br>            <span class="hljs-comment">// [左指针及其左边, 右指针] 都是满足题意的子串</span><br>            <span class="hljs-comment">// 所以个数是 start</span><br>            res += start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1358. Number of Substrings Containing All Three Characters<br>3325. Count Substrings With K-Frequency Characters I<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1020. Number of Enclaves</title>
    <link href="/posts/493219565.html"/>
    <url>/posts/493219565.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.</p><p>A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.</p><p>Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.</p><p>Example 1:</p><p>Input: grid &#x3D; [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>Output: 3<br>Explanation: There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.</p><p>Example 2:</p><p>Input: grid &#x3D; [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]<br>Output: 0<br>Explanation: All 1s are either on the boundary or can reach the boundary.</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 500<br>grid[i][j] is either 0 or 1.</p><p>飞地的数量。</p><blockquote>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。<p>一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。</p><p>返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/number-of-enclaves">https://leetcode.cn/problems/number-of-enclaves</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，就是变相的 flood fill 类型的题目。这里我给出 BFS 和 DFS 两种解法，时间复杂度均为O(mn)，空间复杂度均为O(n)。如果代码看不懂，请先移步 200 题。无论是哪种做法，都需要遍历 matrix 两遍。第一遍先找 matrix 边界上的 1，然后 traverse，把遇到的所有的 1 改成 0。再一次遍历 matrix，如果 matrix 中还有 1，就说明这些 1 是飞地，无法离开 matrix 的。注意这道题其实让你求的是飞地的面积而不是飞地的数量，所以要累加所有遇到的 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="BFS代码"><a href="#BFS代码" class="headerlink" title="BFS代码"></a>BFS代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] dx = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>[] dy = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>m = grid.length;<br>n = grid[<span class="hljs-number">0</span>].length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-comment">// 处理边界上的1</span><br><span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == n - <span class="hljs-number">1</span>) &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>bfs(grid, i, j);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            grid[x][y] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dx[k];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> y + dy[k];<br>                <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; grid[newX][newY] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; newX, newY &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS代码"><a href="#DFS代码" class="headerlink" title="DFS代码"></a>DFS代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numEnclaves</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// 处理边界上的 1</span><br>                <span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == n - <span class="hljs-number">1</span>) &amp;&amp; grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dfs(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理不能触及边界的 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        dfs(grid, i + <span class="hljs-number">1</span>, j);<br>        dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        dfs(grid, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 921. Minimum Add to Make Parentheses Valid</title>
    <link href="/posts/2414888932.html"/>
    <url>/posts/2414888932.html</url>
    
    <content type="html"><![CDATA[<p>A parentheses string is valid if and only if:</p><ul><li>It is the empty string,</li><li>It can be written as AB (A concatenated with B), where A and B are valid strings, or</li><li>It can be written as (A), where A is a valid string.</li></ul><p>You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.</p><ul><li>For example, if s &#x3D; “()))”, you can insert an opening parenthesis to be “(()))” or a closing parenthesis to be “())))”.</li></ul><p>Return the minimum number of moves required to make s valid.</p><p>Example 1:<br>Input: s &#x3D; “())”<br>Output: 1</p><p>Example 2:<br>Input: s &#x3D; “(((“<br>Output: 3</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s[i] is either ‘(‘ or ‘)’.</p><p>使括号有效的最少添加。</p><blockquote>给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。<p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：</p><p>它是一个空字符串，或者<br>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 (A)，其中 A 是有效字符串。<br>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid">https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>括号匹配类型的题目，思路不是栈就是动态规划。这道题只涉及栈。</p><ul><li>遇到左括号，无条件入栈</li><li>遇到右括号，如果栈顶有元素且为左括号，则抵消左括号</li><li>如果栈顶没有元素，无条件入栈</li></ul><p>最后看一下栈内元素个数，这些元素就是匹配不上的括号数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAddToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.offerLast(c);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    stack.pollLast();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stack.offerLast(c);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">20. Valid Parentheses<br>678. Valid Parenthesis String<br>921. Minimum Add to Make Parentheses Valid<br>1111. Maximum Nesting Depth of Two Valid Parentheses Strings<br>1003. Check If Word Is Valid After Substitutions<br>1249. Minimum Remove to Make Valid Parentheses<br>1541. Minimum Insertions to Balance a Parentheses String<br>1963. Minimum Number of Swaps to Make the String Balanced<br>2116. Check if a Parentheses String Can Be Valid<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1669. Merge In Between Linked Lists</title>
    <link href="/posts/3338124454.html"/>
    <url>/posts/3338124454.html</url>
    
    <content type="html"><![CDATA[<p>You are given two linked lists: list1 and list2 of sizes n and m respectively.</p><p>Remove list1’s nodes from the ath node to the bth node, and put list2 in their place.</p><p>The blue edges and nodes in the following figure indicate the result:</p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/fig1.png" alt="Example"><br>Build the result list and return its head.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2024/03/01/ll.png" alt="Example 1"><br>Input: list1 &#x3D; [10,1,13,6,9,5], a &#x3D; 3, b &#x3D; 4, list2 &#x3D; [1000000,1000001,1000002]<br>Output: [10,1,13,1000000,1000001,1000002,5]<br>Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex2.png" alt="Example 2"><br>Input: list1 &#x3D; [0,1,2,3,4,5,6], a &#x3D; 2, b &#x3D; 5, list2 &#x3D; [1000000,1000001,1000002,1000003,1000004]<br>Output: [0,1,1000000,1000001,1000002,1000003,1000004,6]<br>Explanation: The blue edges and nodes in the above figure indicate the result.</p><p>Constraints:</p><p>3 &lt;&#x3D; list1.length &lt;&#x3D; 104<br>1 &lt;&#x3D; a &lt;&#x3D; b &lt; list1.length - 1<br>1 &lt;&#x3D; list2.length &lt;&#x3D; 104</p><p>合并两个链表。</p><blockquote>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。<p>请你将 list1 中第 a 个节点到第 b 个节点删除，并将list2 接在被删除节点的位置。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-in-between-linked-lists">https://leetcode-cn.com/problems/merge-in-between-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>图示应该表示的很清楚了，唯一需要注意的是 a 和 b 表示的是 list 中的节点 index + 1。其他都是常规操作了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeInBetween</span><span class="hljs-params">(ListNode list1, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> list1;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; count &lt; b) &#123;<br>            <span class="hljs-keyword">if</span> (count == a - <span class="hljs-number">1</span>) &#123;<br>                start = cur;<br>            &#125;<br>            cur = cur.next;<br>            count++;<br>        &#125;<br>        start.next = list2;<br>        <span class="hljs-comment">// 注意如果list2只有一个node怎么办</span><br>        <span class="hljs-keyword">while</span> (list2.next != <span class="hljs-literal">null</span>) &#123;<br>            list2 = list2.next;<br>        &#125;<br>        list2.next = cur.next;<br>        cur.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1609. Even Odd Tree</title>
    <link href="/posts/1695688838.html"/>
    <url>/posts/1695688838.html</url>
    
    <content type="html"><![CDATA[<p>A binary tree is named Even-Odd if it meets the following conditions:<br>The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.<br>For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).<br>For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).<br>Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/09/15/sample_1_1966.png" alt="Example 1"><br>Input: root &#x3D; [1,10,4,3,null,7,9,12,8,6,null,null,2]<br>Output: true<br>Explanation: The node values on each level are:<br>Level 0: [1]<br>Level 1: [10,4]<br>Level 2: [3,7,9]<br>Level 3: [12,8,6,2]<br>Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/09/15/sample_2_1966.png" alt="Example 2"><br>Input: root &#x3D; [5,4,2,3,3,7]<br>Output: false<br>Explanation: The node values on each level are:<br>Level 0: [5]<br>Level 1: [4,2]<br>Level 2: [3,3,7]<br>Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2020/09/22/sample_1_333_1966.png" alt="Example 3"><br>Input: root &#x3D; [5,9,1,3,5,7]<br>Output: false<br>Explanation: Node values in the level 1 should be even integers.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 105].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 106</p><p>奇偶树。</p><blockquote><p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：<br>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。<br>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增<br>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减<br>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/even-odd-tree">https://leetcode-cn.com/problems/even-odd-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就是比较常规的BFS思路做，无非是在遍历的过程中根据题意多一些额外的判断，用一个boolean变量去track到底是在奇数层还是在偶数层，然后根据当前层的奇偶性来判断到底节点们应该是单调增还是单调减。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEvenOddTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br>Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.offer(root);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> odd ? Integer.MIN_VALUE : Integer.MAX_VALUE;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-keyword">if</span> (odd &amp;&amp; (cur.val % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || cur.val &lt;= prev)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!odd &amp;&amp; (cur.val % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> || cur.val &gt;= prev)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>prev = cur.val;<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.right);<br>&#125;<br>&#125;<br>odd = !odd;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 897. Increasing Order Search Tree</title>
    <link href="/posts/1227851573.html"/>
    <url>/posts/1227851573.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="Example 1"><br>Input: root &#x3D; [5,3,6,2,4,null,8,1,null,null,null,7,9]<br>Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="Example 2"><br>Input: root &#x3D; [5,1,7]<br>Output: [1,null,5,null,7]</p><p>Constraints:<br>The number of nodes in the given tree will be in the range [1, 100].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>递增顺序搜索树。</p><blockquote><p>给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题跟之前的114题很像，也是属于需要把树做扁平化处理的题目。既然题目都说了用<code>中序遍历</code>，我这里给出两种做法，迭代和递归。时间空间复杂度均是 O(n)。看代码应该能明白思路，只是需要注意当处理节点的时候，需要找到新的 head 节点，以及把处理过的每个节点的左指针设置成 <code>null</code>，新的树里面每个节点都只有右指针。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java迭代实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">increasingBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 虚拟头节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() || cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            cur.left = <span class="hljs-literal">null</span>;<br>            pre.right = cur;<br>            pre = cur;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">increasingBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        increasingBST(root.left);<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>            root.left = <span class="hljs-literal">null</span>;<br>            pre.right = root;<br>        &#125;<br>        pre = root;<br>        increasingBST(root.right);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">114. Flatten Binary Tree to Linked List<br>430. Flatten a Multilevel Doubly Linked List<br>897. Increasing Order Search Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>linked list</tag>
      
      <tag>inorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1325. Delete Leaves With a Given Value</title>
    <link href="/posts/1215096328.html"/>
    <url>/posts/1215096328.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary tree root and an integer target, delete all the leaf nodes with value target.</p><p>Note that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/01/09/sample_1_1684.png" alt="Example 1"><br>Input: root &#x3D; [1,2,3,2,null,2,4], target &#x3D; 2<br>Output: [1,null,3,null,4]<br>Explanation: Leaf nodes in green with value (target &#x3D; 2) are removed (Picture in left).<br>After removing, new nodes become leaf nodes with value (target &#x3D; 2) (Picture in center).</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/01/09/sample_2_1684.png" alt="Example 2"><br>Input: root &#x3D; [1,3,3,3,2], target &#x3D; 3<br>Output: [1,3,null,null,2]</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2020/01/15/sample_3_1684.png" alt="Example 3"><br>Input: root &#x3D; [1,2,null,2,null,2], target &#x3D; 2<br>Output: [1]<br>Explanation: Leaf nodes in green with value (target &#x3D; 2) are removed at each step.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 3000].<br>1 &lt;&#x3D; Node.val, target &lt;&#x3D; 1000</p><p>删除给定值的叶子节点。</p><blockquote>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。<p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p><p>也就是说，你需要重复此过程直到不能继续删除。</p></blockquote><h2 id="思路一-递归"><a href="#思路一-递归" class="headerlink" title="思路一 - 递归"></a>思路一 - 递归</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">removeLeafNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>root.left = removeLeafNodes(root.left, target);<br>root.right = removeLeafNodes(root.right, target);<br><span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; root.val == target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="思路二-后序遍历"><a href="#思路二-后序遍历" class="headerlink" title="思路二 - 后序遍历"></a>思路二 - 后序遍历</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">removeLeafNodes</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(root, target);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> helper(root.left, target);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> helper(root.right, target);<br>        root.left = left;<br>        root.right = right;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span> &amp;&amp; root.val == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">814. Binary Tree Pruning<br>1325. Delete Leaves With a Given Value<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 814. Binary Tree Pruning</title>
    <link href="/posts/1728207630.html"/>
    <url>/posts/1728207630.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p><p>A subtree of a node node is node plus every node that is a descendant of node.</p><p>Example 1:</p><p>Input: root &#x3D; [1,null,0,0,1]<br>Output: [1,null,0,null,1]<br>Explanation:<br>Only the red nodes satisfy the property “every subtree not containing a 1”.<br>The diagram on the right represents the answer.</p><p>Example 2:</p><p>Input: root &#x3D; [1,0,1,0,0,0,1]<br>Output: [1,null,1,null,1]</p><p>Example 3:</p><p>Input: root &#x3D; [1,1,0,1,1,0,1,0]<br>Output: [1,1,0,1,1,null,1]</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 200].<br>Node.val is either 0 or 1.</p><p>二叉树剪枝。</p><blockquote>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。<p>返回移除了所有不包含 1 的子树的原二叉树。</p><p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-pruning">https://leetcode-cn.com/problems/binary-tree-pruning</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是后序遍历。对于每一个节点值 node.val，如果他没有左右孩子或者他的左右孩子的节点值都是 0 的话，就把他剪除（往上返回 null）。可以和1325题放在一起做，两者几乎是同一道题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        root.left = pruneTree(root.left);<br>        root.right = pruneTree(root.right);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; root.val == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">814. Binary Tree Pruning<br>1325. Delete Leaves With a Given Value<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1010. Pairs of Songs With Total Durations Divisible by 60</title>
    <link href="/posts/2959796256.html"/>
    <url>/posts/2959796256.html</url>
    
    <content type="html"><![CDATA[<p>You are given a list of songs where the ith song has a duration of time[i] seconds.</p><p>Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 &#x3D;&#x3D; 0.</p><p>Example 1:<br>Input: time &#x3D; [30,20,150,100,40]<br>Output: 3<br>Explanation: Three pairs have a total duration divisible by 60:<br>(time[0] &#x3D; 30, time[2] &#x3D; 150): total duration 180<br>(time[1] &#x3D; 20, time[3] &#x3D; 100): total duration 120<br>(time[1] &#x3D; 20, time[4] &#x3D; 40): total duration 60</p><p>Example 2:<br>Input: time &#x3D; [60,60,60]<br>Output: 3<br>Explanation: All three pairs have a total duration of 120, which is divisible by 60.</p><p>Constraints:<br>1 &lt;&#x3D; time.length &lt;&#x3D; 6 * 104<br>1 &lt;&#x3D; time[i] &lt;&#x3D; 500</p><p>总持续时间可被 60 整除的歌曲。</p><blockquote>在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。<p>返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字 i 和 j 满足  i &lt; j 且有 (time[i] + time[j]) % 60 &#x3D;&#x3D; 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60">https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实把对 60 取模这个动作拿掉，你会发现这个题跟 two sum 几乎是一样的，所以思路也是类似去解决 two sum 一样的思路。对于两个数相加之后取模的操作，满足如下规则</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">(<span class="hljs-keyword">A</span> + B) % <span class="hljs-number">60</span> == (<span class="hljs-keyword">A</span> % <span class="hljs-number">60</span>) + (B % <span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p><span style="color:red">这里我提供两种实现方式，但是核心思想还是跟 two sum 类似。</span></p><p>第一种，我们还是创建一个 hashmap，每当遇到一个数字 num 的时候，我们找一下另一个能和当前 num 组成配对的数字是否存在。潜在的配对数字是 <code>(60 - num % 60) % 60</code>。如果有就说明有合法的 pair。这个公式<code>(60 - num % 60) % 60</code>有一点技巧，处理了两个 corner case，30 + 30 和 0 + 60。首先 <code>num % 60</code> 就确保了可以把 num 变成一个小于 60 的数字，那么<code>60 - num % 60</code>也一定小于 60。为什么要再次对<code>(60 - num % 60)</code>取模 60 是为了处理 30 和 30 这种 pair。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(60) - O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numPairsDivisibleBy60</span><span class="hljs-params">(<span class="hljs-type">int</span>[] time)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t : time) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">comp</span> <span class="hljs-operator">=</span> (<span class="hljs-number">60</span> - t % <span class="hljs-number">60</span>) % <span class="hljs-number">60</span>;<br>            res += map.getOrDefault(comp, <span class="hljs-number">0</span>);<br>            map.put(t % <span class="hljs-number">60</span>, map.getOrDefault(t % <span class="hljs-number">60</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实现二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numPairsDivisibleBy60</span><span class="hljs-params">(<span class="hljs-type">int</span>[] time)</span> &#123;<br><span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">60</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t : time) &#123;<br><span class="hljs-comment">// 这里的处理是为了找到[30, 30]这种组合</span><br>res += map[(<span class="hljs-number">60</span> - t % <span class="hljs-number">60</span>) % <span class="hljs-number">60</span>];<br>map[t % <span class="hljs-number">60</span>]++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">1010. Pairs of Songs With Total Durations Divisible by 60<br>2453. Destroy Sequential Targets<br>3184. Count Pairs That Form a Complete Day I<br>3185. Count Pairs That Form a Complete Day II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two sum</tag>
      
      <tag>counting sort</tag>
      
      <tag>MOD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 395. Longest Substring with At Least K Repeating Characters</title>
    <link href="/posts/255632933.html"/>
    <url>/posts/255632933.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.</p><p>if no such substring exists, return 0.</p><p>Example 1:<br>Input: s &#x3D; “aaabb”, k &#x3D; 3<br>Output: 3<br>Explanation: The longest substring is “aaa”, as ‘a’ is repeated 3 times.</p><p>Example 2:<br>Input: s &#x3D; “ababbc”, k &#x3D; 2<br>Output: 5<br>Explanation: The longest substring is “ababb”, as ‘a’ is repeated 2 times and ‘b’ is repeated 3 times.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s consists of only lowercase English letters.<br>1 &lt;&#x3D; k &lt;&#x3D; 105</p><p>至少有 K 个重复字符的最长子串。</p><blockquote><p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters">https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-递归"><a href="#思路一-递归" class="headerlink" title="思路一 - 递归"></a>思路一 - 递归</h2><p>首先暴力解就是以一个 O(n^2) 的复杂度去遍历input字符串，看看字符串中是否存在一个 [s.charAt(j), s.charAt(i)] 的子串满足题意。这个做法会超时。</p><p>递归&#x2F;分治的思路是首先统计一下 input 字符串里每个不同字母的出现次数。然后我们再次遍历 input 字符串，当走到某个位置 i 的时候，看一下这个位置指向的字母的出现次数是否大于等于 k，如果不满足这个条件，则说明这个字母不能成为题目要求的子串的一部分，就要从这个地方把字符串分割成两半再往下递归看。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-keyword">return</span> helper(s, k, <span class="hljs-number">0</span>, s.length());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br><span class="hljs-comment">// 整个字符串的长度都不足k，直接返回0</span><br><span class="hljs-keyword">if</span> (end - start &lt; k) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 统计每个字符出现的次数</span><br><span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) &#123;<br>count[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>&#125;<br><br><span class="hljs-comment">// 找到第一个不满足条件的字符的位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) &#123;<br><span class="hljs-keyword">if</span> (count[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; k &amp;&amp; count[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">nextStart</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (nextStart &lt; end &amp;&amp; count[s.charAt(nextStart) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; k) &#123;<br>nextStart++;<br>&#125;<br><span class="hljs-keyword">return</span> Math.max(helper(s, k, <span class="hljs-number">0</span>, i), helper(s, k, nextStart, end));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> end - start;<br>&#125;<br>&#125;<br><span class="hljs-comment">// time complexity: O(n^2), space complexity: O(n)</span><br></code></pre></td></tr></table></figure><h2 id="思路二-滑动窗口"><a href="#思路二-滑动窗口" class="headerlink" title="思路二 - 滑动窗口"></a>思路二 - 滑动窗口</h2><p>这里我们把题目要求拆分一下。既然题目说了只有小写字母（这里好像是不太对，因为用数组统计的时候如果数组长度只创建成26是会越界的），那么我们可以从 1 到 26 去试探。这里我们试探的是找一个子串，其中包含了一个，两个，三个或者。。26 个不同字符，每个字符出现次数不少于 K。这样一来我们就可以把题目转化成类似 159 和 340 那样的做法了。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 试探input字符串中是否能找到一个最长的字符串，存在有numUniqueTarget个不同字符</span><br>        <span class="hljs-comment">// 我们这里是从1 - 26一个个去试探</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">numUniqueTarget</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; numUniqueTarget &lt;= <span class="hljs-number">26</span>; numUniqueTarget++) &#123;<br>            res = Math.max(res, helper(s, k, numUniqueTarget));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// sliding window模板</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-comment">// 子串内unique的字母个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 出现次数不少于K的字母个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numNoLessThanK</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span> (map[c1]++ == <span class="hljs-number">0</span>) &#123;<br>                counter++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map[c1] == k) &#123;<br>                numNoLessThanK++;<br>            &#125;<br>            end++;<br><br>            <span class="hljs-keyword">while</span> (counter &gt; i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                <span class="hljs-keyword">if</span> (map[c2]-- == k) &#123;<br>                    numNoLessThanK--;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (map[c2] == <span class="hljs-number">0</span>) &#123;<br>                    counter--;<br>                &#125;<br>                start++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (counter == numNoLessThanK) &#123;<br>                res = Math.max(res, end - start);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
      <tag>divide and conquer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1404. Number of Steps to Reduce a Number in Binary Representation to One</title>
    <link href="/posts/4271675218.html"/>
    <url>/posts/4271675218.html</url>
    
    <content type="html"><![CDATA[<p>Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:<br>If the current number is even, you have to divide it by 2.<br>If the current number is odd, you have to add 1 to it.<br>It is guaranteed that you can always reach one for all test cases.</p><p>Example 1:<br>Input: s &#x3D; “1101”<br>Output: 6<br>Explanation: “1101” corressponds to number 13 in their decimal representation.<br>Step 1) 13 is odd, add 1 and obtain 14.<br>Step 2) 14 is even, divide by 2 and obtain 7.<br>Step 3) 7 is odd, add 1 and obtain 8.<br>Step 4) 8 is even, divide by 2 and obtain 4.<br>Step 5) 4 is even, divide by 2 and obtain 2.<br>Step 6) 2 is even, divide by 2 and obtain 1.  </p><p>Example 2:<br>Input: s &#x3D; “10”<br>Output: 1<br>Explanation: “10” corressponds to number 2 in their decimal representation.<br>Step 1) 2 is even, divide by 2 and obtain 1.  </p><p>Example 3:<br>Input: s &#x3D; “1”<br>Output: 0</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 500<br>s consists of characters ‘0’ or ‘1’<br>s[0] &#x3D;&#x3D; ‘1’</p><p>将二进制表示减到 1 的步骤数。</p><blockquote>给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数：<p>如果当前数字为偶数，则将其除以 2 。</p><p>如果当前数字为奇数，则将其加上 1 。</p><p>题目保证你总是可以按上述规则将测试用例变为 1 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one">https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然处理的是一个以字符串表示的二进制数字，那么我们就按照规则和需求进行处理。最终的目的是把这个二进制数变成 1，所以我们从右往左扫描 input 字符串，如果遇到 0 则可以除以 2，这里除以 2 相当于是位运算里的右移一位，需要一步；如果遇到 1，则对其 + 1 再除以 2，这里需要两步。在计算的过程中我们需要记录进位 carry。</p><p>此时我们有一个已经用到的步数 res 和一个进位 carry。</p><ul><li>如果当前位置上是0且carry &#x3D; 0，则可以除以2，这里花费一步</li><li>如果当前位置上是0且carry &#x3D; 1，则需要花费两步，一步是+1，另一步是除以2；此时carry仍然是1</li><li>如果当前位置上是1且carry &#x3D; 0，则需要花费两步，一步是+1，另一步是除以2；此时carry是1</li><li>如果当前位置上是1且carry &#x3D; 1，则可以除以2，这里花费一步</li></ul><p>注意题目条件有这一条，s[0] &#x3D;&#x3D; ‘1’，所以第一位要特判，从右往左扫描的时候要在第一位停下。最后看一下，如果依然进位carry &#x3D; 0，则已经满足题意；如果进位carry &#x3D; 1，则加上进位之后s[0] &#x3D; 0，此时要变回1则还需要再 + 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSteps</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> &amp;&amp; s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-comment">// &#x27;0&#x27;</span><br><span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br><span class="hljs-comment">// 如果没有进位，则这些最低位的0都可以通过右移的方式被移除</span><br>                <span class="hljs-comment">// 移除几个就是几步操作</span><br><span class="hljs-keyword">if</span> (carry == <span class="hljs-number">0</span>) &#123;<br>res++;<br>&#125;<br><span class="hljs-comment">// 如果有进位，则加一再除以二，两步操作</span><br><span class="hljs-comment">// 注意加一操作是会产生进位的，所以carry = 1</span><br><span class="hljs-keyword">else</span> &#123;<br>res += <span class="hljs-number">2</span>;<br>carry = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// &#x27;1&#x27;</span><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 加一再除以二，两步操作</span><br><span class="hljs-comment">// 产生进位, carry = 1</span><br><span class="hljs-keyword">if</span> (carry == <span class="hljs-number">0</span>) &#123;<br>res += <span class="hljs-number">2</span>;<br>carry = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 如果之前有carry了，那么当前位会变成0，需要除以二，一步操作</span><br><span class="hljs-comment">// 同时注意因为当前位会变成0所以是会产生进位的，所以carry = 1</span><br><span class="hljs-keyword">else</span> &#123;<br>res++;<br>carry = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res + carry;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1582. Special Positions in a Binary Matrix</title>
    <link href="/posts/1297775566.html"/>
    <url>/posts/1297775566.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n binary matrix mat, return the number of special positions in mat.</p><p>A position (i, j) is called special if mat[i][j] &#x3D;&#x3D; 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/12/23/special1.jpg" alt="Example 1"><br>Input: mat &#x3D; [[1,0,0],[0,0,1],[1,0,0]]<br>Output: 1<br>Explanation: (1, 2) is a special position because mat[1][2] &#x3D;&#x3D; 1 and all other elements in row 1 and column 2 are 0.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/12/24/special-grid.jpg" alt="Example 2"><br>Input: mat &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>Output: 3<br>Explanation: (0, 0), (1, 1) and (2, 2) are special positions.</p><p>Constraints:<br>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>mat[i][j] is either 0 or 1.</p><p>二进制矩阵中的特殊位置。</p><blockquote><p>给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。<br>特殊位置 定义：如果 mat[i][j] &#x3D;&#x3D; 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/special-positions-in-a-binary-matrix">https://leetcode.cn/problems/special-positions-in-a-binary-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是找二进制矩阵中的特殊位置。这个特殊位置的定义是如果当前坐标值是1且他是当前行和当前列唯一的1，则当前位置就是一个特殊位置。</p><p>这道题不涉及算法，思路是需要扫描两遍矩阵。第一遍扫描的时候我们需要额外创建两个数组，一个记录当前行有多少个1，一个记录当前列有多少个1。第二遍扫描的时候，再碰到1的时候，我们就去看这个位置所在的行和所在的列是不是都只有一个1，如果是，则说明这是一个满足题意的特殊位置。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSpecial</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; rowMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Integer, Integer&gt; colMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    rowMap.put(i, rowMap.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    colMap.put(j, colMap.getOrDefault(j, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">1</span> &amp;&amp; rowMap.get(i) == <span class="hljs-number">1</span> &amp;&amp; colMap.get(j) == <span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1283. Find the Smallest Divisor Given a Threshold</title>
    <link href="/posts/2167423149.html"/>
    <url>/posts/2167423149.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division’s result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.</p><p>Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7&#x2F;3 &#x3D; 3 and 10&#x2F;2 &#x3D; 5).</p><p>The test cases are generated so that there will be an answer.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,5,9], threshold &#x3D; 6<br>Output: 5<br>Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1.<br>If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). </p><p>Example 2:<br>Input: nums &#x3D; [44,22,33,11,1], threshold &#x3D; 5<br>Output: 44</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 104<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 106<br>nums.length &lt;&#x3D; threshold &lt;&#x3D; 106</p><p>使结果不超过阈值的最小除数。</p><blockquote>给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。<p>请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。</p><p>每个数除以除数后都向上取整，比方说 7&#x2F;3 &#x3D; 3 ， 10&#x2F;2 &#x3D; 5 。</p><p>题目保证一定有解。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold">https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分法。按照题意规定的计算方式，我们要找到一个合适的除数。但是如何确定除数的范围呢，下限肯定是1，上限应该是数组中最大的数字，我们暂且定义他为 max。因为如果除 max 都大了，做如上那一通操作得出的除法结果求和只会是离 threshold 越来越远。</p><p>确定好了除数的上限和下限之后，我们就可以开始做二分了。这里做二分没什么可说的，我们写一个 helper 函数，按照题意，每次找到一个 mid，去计算那个所谓的 sum 是否是一个最大的且小于 threshold 的结果。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestDivisor</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            right = Math.max(right, num);<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (helper(nums, mid) &gt; threshold) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> divisor)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>sum += num / divisor;<br><span class="hljs-comment">// 不能整除的时候，需要向上取整</span><br><span class="hljs-keyword">if</span> (num % divisor != <span class="hljs-number">0</span>) &#123;<br>sum++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 135. Candy</title>
    <link href="/posts/2265685598.html"/>
    <url>/posts/2265685598.html</url>
    
    <content type="html"><![CDATA[<p>There are N children standing in a line. Each child is assigned a rating value.</p><p>You are giving candies to these children subjected to the following requirements:</p><p>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?</p><p>Example 1:<br>Input: [1,0,2]<br>Output: 5<br>Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</p><p>Example 2:<br>Input: [1,2,2]<br>Output: 4<br>Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.<br> The third child gets 1 candy because it satisfies the above two conditions.</p><p>分发糖果。</p><blockquote><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/candy">https://leetcode.cn/problems/candy</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心。根据题意，我们需要对input数组扫描两遍，因为对于每个孩子来说，他拥有的糖果数需要同时和他的左右邻居比较以确保满足题意。所以我们创建两个和 input 数组等长的数组，left 数组从左往右扫描，right 数组从右往左扫描。</p><p>更新 left 数组的方式是，对于每个孩子，需要看他的评分是否大于他左边的孩子的评分，如果大于，当前这个孩子的糖果数起码是他左边孩子的糖果数 + 1</p><p>更新 right 数组的方式是，对于每个孩子，需要看他的评分是否大于他右边的孩子的评分，如果大于，当前这个孩子的糖果数起码是他右边孩子的糖果数 + 1</p><p>在更新 right 数组的同时，我们可以得到相同位置上 left 数组和 right 数组之间的较大值，这个较大值即是当前位置上的孩子需要拥有的糖果数</p><p>最后附上<a href="https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/">一个动图</a>帮助理解。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ratings.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(left, <span class="hljs-number">1</span>);<br>        Arrays.fill(right, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                right[i] = right[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res += Math.max(left[i], right[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1219. Path with Maximum Gold</title>
    <link href="/posts/128470414.html"/>
    <url>/posts/128470414.html</url>
    
    <content type="html"><![CDATA[<p>In a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.</p><p>Return the maximum amount of gold you can collect under the conditions:<br>Every time you are located in a cell you will collect all the gold in that cell.<br>From your position you can walk one step to the left, right, up or down.<br>You can’t visit the same cell more than once.<br>Never visit a cell with 0 gold.<br>You can start and stop collecting gold from any position in the grid that has some gold.<br>Example 1:</p><p>Input: grid &#x3D; [[0,6,0],[5,8,7],[0,9,0]]<br>Output: 24<br>Explanation:<br>[[0,6,0],<br> [5,8,7],<br> [0,9,0]]<br>Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.<br>Example 2:</p><p>Input: grid &#x3D; [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<br>Output: 28<br>Explanation:<br>[[1,0,7],<br> [2,0,6],<br> [3,4,5],<br> [0,3,0],<br> [9,0,20]]<br>Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.<br>Constraints:</p><p>1 &lt;&#x3D; grid.length, grid[i].length &lt;&#x3D; 15<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100<br>There are at most 25 cells containing gold.</p><p>黄金矿工。</p><blockquote>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。<p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><p>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<br>矿工每次可以从当前位置向上下左右四个方向走。<br>每个单元格只能被开采（进入）一次。<br>不得开采（进入）黄金数目为 0 的单元格。<br>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-with-maximum-gold">https://leetcode-cn.com/problems/path-with-maximum-gold</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是回溯 backtracking。注意题目里面的几个条件。既然问的是最大受益，所以二维数组每个坐标你都需要做回溯，以判断到底从哪个坐标开始挖矿的收益最大。写回溯函数的时候，注意处理越界以及当前 cell 值为 0 的情况。遇到 cell 值为 0，直接返回 0，因为这个地方按照题意你是不能访问&#x2F;开采的。对于一般情况，你需要看一下四个方向往下回溯哪一个方向的收益最大，返回那个最大的收益。同时既然是回溯，在回溯的最后记得把修改过的 cell 值再改回来。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(k * 4 * 3 ^ (k - 1)) &#x3D; O(4 * 3 ^ k) - 你最多有K个cell需要作为起点去访问，对于每个cell你最多有四种情况需要判断，但是对于下一个cell你只需要判断三种情况<br>空间O(k) - 回溯使用到的栈空间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaximumGold</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-number">0</span>) &#123;<br>                    res = Math.max(res, dfs(grid, i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-comment">// 越界处理和当cell值为0的时候不visit</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> grid[i][j];<br>        <span class="hljs-comment">// mark as 0 after visited</span><br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> dfs(grid, i, j + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(grid, i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(left, Math.max(right, Math.max(up, down)));<br>        <span class="hljs-comment">// 还原</span><br>        grid[i][j] = origin;<br>        <span class="hljs-keyword">return</span> grid[i][j] + max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 720. Longest Word in Dictionary</title>
    <link href="/posts/2419185708.html"/>
    <url>/posts/2419185708.html</url>
    
    <content type="html"><![CDATA[<p>Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.</p><p>If there is no answer, return the empty string.</p><p>Example 1:<br>Input:<br>words &#x3D; [“w”,”wo”,”wor”,”worl”, “world”]<br>Output: “world”<br>Explanation:<br>The word “world” can be built one character at a time by “w”, “wo”, “wor”, and “worl”.</p><p>Example 2:<br>Input:<br>words &#x3D; [“a”, “banana”, “app”, “appl”, “ap”, “apply”, “apple”]<br>Output: “apple”<br>Explanation:<br>Both “apply” and “apple” can be built from other words in the dictionary. However, “apple” is lexicographically smaller than “apply”.</p><p>Note:<br>All the strings in the input will only contain lowercase letters.<br>The length of words will be in the range [1, 1000].<br>The length of words[i] will be in the range [1, 30].</p><p>词典中最长的单词。</p><blockquote><p>给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。<br>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。<br>题意是给出一个字符串数组 words 组成的一本英语词典。从中找出最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p></blockquote><h2 id="思路一，hashset"><a href="#思路一，hashset" class="headerlink" title="思路一，hashset"></a>思路一，hashset</h2><p>我们需要一个 hashset 记录单词。注意 Arrays.sort() 是可以对字母&#x2F;单词排序的，所以我们用这个函数先对 input array 进行排序，这样字典序较小的单词会靠前。此时我们再次扫描 input array，遍历每个单词，把每个单词加入一个 hashset。加入之前判断</p><p>这个单词的长度是否为 1 或者 hashset 里面已经存在了这个单词除去最后一个字母的前缀（比如 abc 的话，我们去检查一下 hashset 里是否有 ab）。这两个条件只要满足一个，就可以更新 res 的长度。<br>单词长度为 1 的话，只能是有一个空的前缀，但是越晚出现的单个字母，其字典序应该更大。这也就是为什么出现单个字母我们也需要更新 res 的原因。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestWord</span><span class="hljs-params">(String[] words)</span> &#123;<br>Arrays.sort(words);<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (String w : words) &#123;<br><span class="hljs-keyword">if</span> (w.length() == <span class="hljs-number">1</span> || set.contains(w.substring(<span class="hljs-number">0</span>, w.length() - <span class="hljs-number">1</span>))) &#123;<br>res = w.length() &gt; res.length() ? w : res;<br>set.add(w);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二，字典树"><a href="#思路二，字典树" class="headerlink" title="思路二，字典树"></a>思路二，字典树</h2><p>再来是字典树 + BFS 的做法。这里我们还是自己写一个 node class 表示节点。遍历 input 数组，把每个单词都做成一个字典树的node。之后通过 BFS 的方式遍历 queue 中所有的 node，返回字典序最小的结果。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - node class</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// 字典树节点,每个节点代表一个字母</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-comment">// 该节点的下一个字母</span><br>Node[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br><span class="hljs-comment">// 如果是单词结尾，保存该单词，否则为空</span><br>String word;<br>&#125;<br><br><span class="hljs-comment">// 定义字典树根节点</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestWord</span><span class="hljs-params">(String[] words)</span> &#123;<br><span class="hljs-comment">// 根节点默认单词为空</span><br>root.word = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">// 将每一个单词加入字典树</span><br><span class="hljs-keyword">for</span> (String s : words) &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (node.children[c] == <span class="hljs-literal">null</span>) &#123;<br>node.children[c] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>&#125;<br>node = node.children[c];<br>&#125;<br><span class="hljs-comment">// 单词结尾时，将该单词保存至当前节点中</span><br>node.word = s;<br>&#125;<br><span class="hljs-comment">// bfs</span><br>Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// bfs起点</span><br>q.offer(root);<br><span class="hljs-comment">// 返回结果</span><br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span> (q.size() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> q.size();<br><span class="hljs-comment">// 当前长度下字典顺序最小的单词</span><br><span class="hljs-type">String</span> <span class="hljs-variable">smallestValid</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>size--;<br><span class="hljs-type">Node</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> q.poll();<br><span class="hljs-comment">// 记录当前长度下字典顺序最小的单词</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>.equals(smallestValid)) &#123;<br>smallestValid = n.word;<br>&#125;<br>Node[] children = n.children;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-comment">// 如果子节点为空，或者子节点不是单词结尾，跳过</span><br><span class="hljs-keyword">if</span> (children[i] == <span class="hljs-literal">null</span> || children[i].word == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 将子节点添加到Queue中（子节点为下一个长度的单词）</span><br>q.offer(children[i]);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 当前长度遍历完之后，将字典顺序最小的一个保存至返回结果</span><br>res = smallestValid;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">392.</span> <span class="hljs-variable">Is</span> <span class="hljs-variable">Subsequence</span><br><span class="hljs-number">524.</span> <span class="hljs-built_in">Longest</span> <span class="hljs-built_in">Word</span> <span class="hljs-variable">in</span> <span class="hljs-variable">Dictionary</span> <span class="hljs-variable">through</span> <span class="hljs-variable">Deleting</span><br><span class="hljs-number">720.</span> <span class="hljs-built_in">Longest</span> <span class="hljs-built_in">Word</span> <span class="hljs-variable">in</span> <span class="hljs-variable">Dictionary</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sort</tag>
      
      <tag>string</tag>
      
      <tag>trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 524. Longest Word in Dictionary through Deleting</title>
    <link href="/posts/2214751183.html"/>
    <url>/posts/2214751183.html</url>
    
    <content type="html"><![CDATA[<p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p><p>Example 1:<br>Input:<br>s &#x3D; “abpcplea”, d &#x3D; [“ale”,”apple”,”monkey”,”plea”]</p><p>Output:<br>“apple”</p><p>Example 2:<br>Input:<br>s &#x3D; “abpcplea”, d &#x3D; [“a”,”b”,”c”]</p><p>Output:<br>“a”</p><p>Note:<br>All the strings in the input will only contain lower-case letters.<br>The size of the dictionary won’t exceed 1,000.<br>The length of all the strings in the input won’t exceed 1,000.</p><p>通过删除字母匹配到字典里最长单词。</p><blockquote><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是双指针，类似于392题找子序列。因为 s 删除字母是无序的，所以只能通过判断子序列的方式来看 dictionary 中的每个单词是不是由 s 删减而来。如果你找到一个单词了，之后再有一个单词，他也是 s 的子序列的话，需要用 <code>str.compareTo()</code> 额外判断 str 的字典序是否比 res 小，若是则替换 res，从而得到字典序最小的结果。</p><p><code>a.compareTo(b)</code> 这个函数如果返回负数，说明 a 的字典序比 b 小，返回正数说明 a 的字典序比 b 大。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn) - 要与m个单词比较，单词平均长度为n<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; dictionary)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (String word : dictionary) &#123;<br>            <span class="hljs-keyword">if</span> (helper(word, s)) &#123;<br>                <span class="hljs-keyword">if</span> (word.length() &gt; res.length()) &#123;<br>                    res = word;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (word.length() == res.length() &amp;&amp; word.compareTo(res) &lt; <span class="hljs-number">0</span>) &#123;<br>                    res = word;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == s.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">392. Is Subsequence<br>524. Longest Word in Dictionary through Deleting<br>720. Longest Word in Dictionary<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1051. Height Checker</title>
    <link href="/posts/742715672.html"/>
    <url>/posts/742715672.html</url>
    
    <content type="html"><![CDATA[<p>A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.</p><p>You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).</p><p>Return the number of indices where heights[i] !&#x3D; expected[i].</p><p>Example 1:<br>Input: heights &#x3D; [1,1,4,2,1,3]<br>Output: 3<br>Explanation:<br>heights:  [1,1,4,2,1,3]<br>expected: [1,1,1,2,3,4]<br>Indices 2, 4, and 5 do not match.</p><p>Example 2:<br>Input: heights &#x3D; [5,1,2,3,4]<br>Output: 5<br>Explanation:<br>heights:  [5,1,2,3,4]<br>expected: [1,2,3,4,5]<br>All indices do not match.</p><p>Example 3:<br>Input: heights &#x3D; [1,2,3,4,5]<br>Output: 0<br>Explanation:<br>heights:  [1,2,3,4,5]<br>expected: [1,2,3,4,5]<br>All indices match.</p><p>Constraints:<br>1 &lt;&#x3D; heights.length &lt;&#x3D; 100<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; 100</p><p>高度检查器。</p><blockquote>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。<p>请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。</p><p>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/height-checker">https://leetcode-cn.com/problems/height-checker</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-排序"><a href="#思路一-排序" class="headerlink" title="思路一 - 排序"></a>思路一 - 排序</h2><p>因为题目问的是需要移动多少个人的位置，所以当排序过后，每个人就知道他们应该站在什么位置上了。此时把排序过的和未排序过的数组进行比较，有不同的，则说明需要移动。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">heightChecker</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] sorted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            sorted[i] = heights[i];<br>        &#125;<br>        Arrays.sort(sorted);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (sorted[i] != heights[i]) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-桶排序"><a href="#思路二-桶排序" class="headerlink" title="思路二 - 桶排序"></a>思路二 - 桶排序</h2><p>桶排序的做法类似，但是更高效。因为身高的数据范围是 [1, 100]，所以我们创建 101 个桶，表示身高从 0 到 100 每个不同身高分别有多少人。第一次遍历数组，记录不同身高分别有多少人。再次遍历数组，因为需要满足排列是非递减，把桶中的元素按照桶的下标从小到大一个个放到 expected 数组内，然后再比较 expected 数组和 heights 数组，有不同的，则说明需要移动。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">heightChecker</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">101</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> height : heights) &#123;<br>            map[height]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] expected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (map[i] != <span class="hljs-number">0</span>) &#123;<br>                expected[index++] = i;<br>                map[i]--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (expected[i] != heights[i]) &#123;<br>                diff++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>sort</tag>
      
      <tag>bucket sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 948. Bag of Tokens</title>
    <link href="/posts/3870056761.html"/>
    <url>/posts/3870056761.html</url>
    
    <content type="html"><![CDATA[<p>You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] donates the value of tokeni.</p><p>Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):</p><p>Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score.<br>Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score.<br>Return the maximum possible score you can achieve after playing any number of tokens.</p><p>Example 1:<br>Input: tokens &#x3D; [100], power &#x3D; 50<br>Output: 0<br>Explanation: Since your score is 0 initially, you cannot play the token face-down. You also cannot play it face-up since your power (50) is less than tokens[0] (100).</p><p>Example 2:<br>Input: tokens &#x3D; [200,100], power &#x3D; 150<br>Output: 1<br>Explanation: Play token1 (100) face-up, reducing your power to 50 and increasing your score to 1.<br>There is no need to play token0, since you cannot play it face-up to add to your score. The maximum score achievable is 1.</p><p>Example 3:<br>Input: tokens &#x3D; [100,200,300,400], power &#x3D; 200<br>Output: 2<br>Explanation: Play the tokens in this order to get a score of 2:<br>Play token0 (100) face-up, reducing power to 100 and increasing score to 1.<br>Play token3 (400) face-down, increasing power to 500 and reducing score to 0.<br>Play token1 (200) face-up, reducing power to 300 and increasing score to 1.<br>Play token2 (300) face-up, reducing power to 0 and increasing score to 2.<br>The maximum score achievable is 2.</p><p>Constraints:<br>0 &lt;&#x3D; tokens.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; tokens[i], power &lt; 104</p><p>令牌放置。</p><blockquote><p>给你一堆令牌，规则是令牌上tokens[i] 代表一个能量值P，每个令牌最多使用一次，使用的方法如下<br>如果你至少有 token[i] 点能量，可以将令牌置为正面朝上，失去 token[i] 点能量，并得到 1 分。<br>如果我们至少有 1 分，可以将令牌置为反面朝上，获得 token[i] 点能量，并失去 1 分。<br>在使用任意数量的令牌后，返回我们可以得到的最大分数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是排序 + 双指针。注意题目，因为无论 token 的值是多少，得分都是 1；当你需要用分数兑换能量的时候，每次只需要消耗一个分数，但是得到的 token 数量是可大可小的。由此想到需要对 tokens 数组排序。</p><p>将 input 排序，这样 token 值最小的会在数组最左边，token 值最大的会在最右边。设置两个指针从两边往中间逼近，如果当前你的能量 power &gt;&#x3D; tokens[left]，说明你有多余的能量，可以拿来换分数；如果不满足这个条件，则需要看看手里目前分数是否 &gt; 0，来换取一个当前最大的能量 power（在 right 指针那里）；如果这两个条件都不满足则退出 while 循环，返回你的分数。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - sort<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bagOfTokensScore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] tokens, <span class="hljs-type">int</span> power)</span> &#123;<br>        Arrays.sort(tokens);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> tokens.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (power &gt;= tokens[left]) &#123;<br>                power -= tokens[left++];<br>                score++;<br>                res = Math.max(res, score);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">1</span>) &#123;<br>                power += tokens[right--];<br>                score--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 456. 132 Pattern</title>
    <link href="/posts/1414183880.html"/>
    <url>/posts/1414183880.html</url>
    
    <content type="html"><![CDATA[<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai,<br>aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list<br>of n numbers as input and checks whether there is a 132 pattern in the list.</p><p>Note: n will be less than 15,000.</p><p>Example 1:<br>Input: [1, 2, 3, 4]<br>Output: False<br>Explanation: There is no 132 pattern in the sequence.</p><p>Example 2:<br>Input: [3, 1, 4, 2]<br>Output: True<br>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p><p>Example 3:<br>Input: [-1, 3, 2, 0]<br>Output: True<br>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0]<br>and [-1, 2, 0].</p><p>132 模式。</p><blockquote>给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。<p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</p><p>进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/132-pattern">https://leetcode-cn.com/problems/132-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-treemap"><a href="#思路一-treemap" class="headerlink" title="思路一 - treemap"></a>思路一 - treemap</h2><p>我这里提供两种思路，一种是 treemap，一种是单调栈。这题如果没练过，面试当下大概率是想不出来的。</p><p>treemap 的做法，需要遍历两遍数组。第一次遍历 input 数组，统计每个数字出现了几次，用 treemap&lt;key, count&gt; 记录好。再一次遍历 input 数组，此时遇到一个数字，就从 treemap 中减去这个数字的 count，直到把这个数字在 treemap 中的 key 移除为止。在第二次遍历的过程中，记录一个最小值 min。如果在过程中发现有一个数字 num 比 min 大，同时在 treemap 中可以找到另一个数字既严格大于 min（treemap.higherKey(min)），又小于当前的 num，则说明找到了这个 132 模式。其中 treemap 的 higherKey() 函数是表示找一个严格大于当前数字的 key，注意它和 ceilingKey() 的区别。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - treemap 找 higherKey 的时间复杂度<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        TreeMap&lt;Integer, Integer&gt; treemap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            treemap.put(num, treemap.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> treemap.get(num);<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>                treemap.put(num, count - <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                treemap.remove(num);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (num &lt;= min) &#123;<br>                min = num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// min is 1</span><br>                <span class="hljs-comment">// num is 3</span><br>                <span class="hljs-comment">// target is 2</span><br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> treemap.higherKey(min);<br>                <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; target &lt; num) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-单调栈"><a href="#思路二-单调栈" class="headerlink" title="思路二 - 单调栈"></a>思路二 - 单调栈</h2><p>第二种方法是单调栈，而且是<code>从后往前</code>遍历数组。遍历过程中，记录一个变量 second 表示中间那个数字。因为这个数字需要出现在 1 和 3 之后，所以从后往前遍历是说得通的。对于任何一个数字<code>nums[i]</code>，都无条件把他放入 stack 中。当 stack 不为空的时候，判断当前数字 <code>nums[i]</code> 是否大于 <code>stack.peek()</code>，若大于则 <code>stack.pop()</code> 并且把 pop 出来的元素赋给 second。此时 pop 出来的元素因为是比较靠后的，所以其实 second 记录的是 132 模式里的那个 2。我们试图找一个 3 之后最大的 2，这样会留更多余地给 1。所以再往前扫描的时候，一旦发现有 nums[i] &lt; mid 则 return true。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() &lt; num) &#123;<br>                second = Math.max(second, stack.pollLast());<br>            &#125;<br>            stack.offerLast(num);<br>            <span class="hljs-keyword">if</span> (num &lt; second) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>treemap</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1615. Maximal Network Rank</title>
    <link href="/posts/3640301902.html"/>
    <url>/posts/3640301902.html</url>
    
    <content type="html"><![CDATA[<p>There is an infrastructure of n cities with some number of roads connecting these cities. Each roads[i] &#x3D; [ai, bi] indicates that there is a bidirectional road between cities ai and bi.</p><p>The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.</p><p>The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.</p><p>Given the integer n and the array roads, return the maximal network rank of the entire infrastructure.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/09/21/ex1.png" alt="Example 1"><br>Input: n &#x3D; 4, roads &#x3D; [[0,1],[0,3],[1,2],[1,3]]<br>Output: 4<br>Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/09/21/ex2.png" alt="Example 2"><br>Input: n &#x3D; 5, roads &#x3D; [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]<br>Output: 5<br>Explanation: There are 5 roads that are connected to cities 1 or 2.</p><p>Example 3:<br>Input: n &#x3D; 8, roads &#x3D; [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]<br>Output: 5<br>Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.</p><p>Constraints:<br>2 &lt;&#x3D; n &lt;&#x3D; 100<br>0 &lt;&#x3D; roads.length &lt;&#x3D; n * (n - 1) &#x2F; 2<br>roads[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; ai, bi &lt;&#x3D; n-1<br>ai !&#x3D; bi<br>Each pair of cities has at most one road connecting them.</p><p>最大网络秩。</p><blockquote>n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。<p>两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。</p><p>整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。</p><p>给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-network-rank">https://leetcode-cn.com/problems/maximal-network-rank</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意如上，本质上是在找 input 里两点之间最大的网络秩 rank。这是一道图论的题，注意每条给出的边都是无向的所以对于一条边上的两个点来说，他们的 rank 都各自 + 1。思路是首先用一个数组 edges 记录每个点各自的 rank 是多少，每遇到一条边，这条边的两端的点的 rank 都各自 + 1；同时我们需要一个二维的邻接矩阵 adj，这里我选择用 boolean，因为我们只需要记录两点之间是否是邻接点即可。</p><p>我们遍历一遍 roads 数组之后，我们可以把 edges 数组和 adj 矩阵都统计完毕。之后我们再用两个 for loop 遍历这 n 个点，看看每两个不同的点之间的 rank sum。注意如果两点是能直接相连的，他们在邻接矩阵 adj 里就会是 true，此时 rank 需要减一。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalNetworkRank</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] roads)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (roads == <span class="hljs-literal">null</span> || roads.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">boolean</span>[][] adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; roads.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> roads[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> roads[i][<span class="hljs-number">1</span>];<br>            edges[from]++;<br>            edges[to]++;<br>            adj[from][to] = <span class="hljs-literal">true</span>;<br>            adj[to][from] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                rank = edges[i] + edges[j] - (adj[i][j] == <span class="hljs-literal">true</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                res = Math.max(res, rank);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 218. The Skyline Problem</title>
    <link href="/posts/3875926335.html"/>
    <url>/posts/3875926335.html</url>
    
    <content type="html"><![CDATA[<p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.</p><p>The geometric information of each building is given in the array buildings where buildings[i] &#x3D; [lefti, righti, heighti]:</p><p>lefti is the x coordinate of the left edge of the ith building.<br>righti is the x coordinate of the right edge of the ith building.<br>heighti is the height of the ith building.<br>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p><p>The skyline should be represented as a list of “key points” sorted by their x-coordinate in the form [[x1,y1],[x2,y2],…]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.</p><p>Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […,[2 3],[4 5],[7 5],[11 5],[12 7],…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […,[2 3],[4 5],[12 7],…]</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt="Example 1"><br>Input: buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]<br>Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]<br>Explanation:<br>Figure A shows the buildings of the input.<br>Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.</p><p>Example 2:<br>Input: buildings &#x3D; [[0,2,3],[2,5,3]]<br>Output: [[0,3],[5,0]]</p><p>Constraints:<br>1 &lt;&#x3D; buildings.length &lt;&#x3D; 104<br>0 &lt;&#x3D; lefti &lt; righti &lt;&#x3D; 231 - 1<br>1 &lt;&#x3D; heighti &lt;&#x3D; 231 - 1<br>buildings is sorted by lefti in non-decreasing order.</p><p>天际线问题。</p><blockquote>城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。<p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] &#x3D; [lefti, righti, heighti] 表示：</p><p>lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。</p><p>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/the-skyline-problem">https://leetcode.cn/problems/the-skyline-problem</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，首先，天际线都是一些横的线段，但是最后要求的输出不是线段，而是一些点的坐标。这些点都是一些水平线段的左端点；同时这些点一定是在高度有变化的坐标发生的，但是也分情况，如果高度变大，那么输出的点是高度更大的点；如果高度是变小的，那么输出的点是高度更小的。</p><p>思路是扫描线 + 最大堆。因为 input buildings 的形式是 [left, right, height]，表示的是每一个房顶的左边缘，右边缘和高度。我们首先将 input buildings 放入一个 list <code>lines</code>，做一个转换，把每个房子的左边缘和右边缘的高度拆分出来，这样我在 <code>lines</code> 里面存的都是一些边缘和他们各自的高度。但是为了区分左边缘和右边缘，我把左边缘的高度暂时标记成负数。最后我再把 <code>lines</code> 按照高度做一个排序，这样左边缘会相对靠前（都是负数）；如果边缘下标一样，高度更高的靠前。注意这个地方很巧妙地用负数区分了左边缘的高度和右边缘的高度，在排序的时候也确保在遍历左边缘的时候，会先处理高度更高的左边缘，而遇到右边缘的时候，会先处理高度更高的。同时我们需要一个最大堆 maxHeap 和一个变量 preHighest 记录之前最高的高度是多少。</p><p>再次遍历 <code>lines</code>，当遇到一个左边缘的时候（&lt; 0），我们把他放到最大堆，但如果是一个右边缘，说明当前这个右边缘所在的矩形处理完了，我们直接从最大堆抛弃这个边。此时如果堆顶元素 curMax 跟之前一个最大高度 preMax 不同的话，堆顶元素 curMax 就是一条天际线的起点，他的下标就是当前遍历到的左边缘的下标。把这个结果加入结果集之后，记得更新 preMax</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">getSkyline</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] buildings)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;<span class="hljs-type">int</span>[]&gt; lines = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// [left/right, height]</span><br>        <span class="hljs-comment">// 注意矩形左边界的高度被设定为负数了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : buildings) &#123;<br>            lines.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; b[<span class="hljs-number">0</span>], -b[<span class="hljs-number">2</span>] &#125;);<br>            lines.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; b[<span class="hljs-number">1</span>], b[<span class="hljs-number">2</span>] &#125;);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 靠左的在前，或者更高的在前</span><br>        Collections.sort(lines, (a, b) -&gt; a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>] ? a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br>        maxHeap.offer(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : lines) &#123;<br>            <span class="hljs-comment">// 左边界 -&gt; 加入高度</span><br>            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                maxHeap.offer(-p[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 右边界 -&gt; 移除高度</span><br>                maxHeap.remove(p[<span class="hljs-number">1</span>]);<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> maxHeap.peek();<br>            <span class="hljs-keyword">if</span> (curMax != preHeight) &#123;<br>                res.add(Arrays.asList(p[<span class="hljs-number">0</span>], curMax));<br>                preHeight = curMax;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>heap</tag>
      
      <tag>line sweep</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 611. Valid Triangle Number</title>
    <link href="/posts/3398385201.html"/>
    <url>/posts/3398385201.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.<br>Example 1:<br>Input: nums &#x3D; [2,2,3,4]<br>Output: 3<br>Explanation: Valid combinations are:<br>2,3,4 (using the first 2)<br>2,3,4 (using the second 2)<br>2,2,3<br>Example 2:<br>Input: nums &#x3D; [4,2,3,4]<br>Output: 4<br>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p><p>有效三角形的个数。</p><blockquote><p>给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的思路有点类似 3sum。因为是要找能组成三角形的三条边，所以一定要满足 a + b &gt; c，其中两条边的和要大于第三条边。所以思路是先 sort input数组（a &lt; b &lt; c），然后从数组末端开始扫描，把当前遍历到的数字当做三角形的最长的边 c，然后再用 two pointer 找另外两条边 a 和 b。找的方式是，如果 a + b &gt; c 则说明当 c 是最长边的时候，abc 这个组合是满足题意的，res +&#x3D; b - a。为什么 a - b 之间的所有组合都能累加进去是因为这里我们考虑的是 b 和 c 不变的情况下，把 a 右移的情况，计算完这些情况之后 b 左移；如果 a + b &lt; c 的话，那么只能是 a 右移，因为长度不够。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2) - worst case<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">triangleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// System.out.println(Arrays.toString(nums));</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; nums[i]) &#123;<br>                    <span class="hljs-comment">// System.out.println(nums[left] + &quot;, &quot; + nums[right] + &quot;, &quot; + nums[i]);</span><br>                    count += right - left;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">259. 3Sum Smaller<br>611. Valid Triangle Number<br>2563. Count the Number of Fair Pairs<br>2824. Count Pairs Whose Sum is Less than Target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 229. Majority Element II</title>
    <link href="/posts/3803898530.html"/>
    <url>/posts/3803898530.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array of size n, find all elements that appear more than ⌊ n&#x2F;3 ⌋ times.</p><p>Example 1:<br>Input: nums &#x3D; [3,2,3]<br>Output: [3]</p><p>Example 2:<br>Input: nums &#x3D; [1]<br>Output: [1]</p><p>Example 3:<br>Input: nums &#x3D; [1,2]<br>Output: [1,2]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>Follow up: Could you solve the problem in linear time and in O(1) space?</p><p>多数元素 II。</p><blockquote><p>给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;3 ⌋ 次的元素。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟版本一差不多，区别在于这道题是在数组里找所有出现次数大于 1&#x2F;3 数组长度的元素。</p><p>题目要求时间 O(n)，空间 O(1)，所以思路还是投票法。对于一个数组，最多只有两个元素的出现次数超过数组长度的三分之一，所以我们这里创建两个 candidate。首先我们将这两个 candidate 初始化为 0（因为有 test case 是数组长度小于 2 的所以不能设置为 nums[0], nums[1]），然后遍历数组，按照版本一的做法，统计这两个 candidate 的出现次数。这一题需要遍历两次 input 数组，第二次遍历的时候是在验证找到的两个 candidate 是否出现次数真的大于数组长度的三分之一，若是则加入结果集。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 题目要求<br>空间O(1) - 题目要求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == candidate1) &#123;<br>                count1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == candidate2) &#123;<br>                count2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count1 == <span class="hljs-number">0</span>) &#123;<br>                candidate1 = num;<br>                count1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count2 == <span class="hljs-number">0</span>) &#123;<br>                candidate2 = num;<br>                count2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count1--;<br>                count2--;<br>            &#125;<br>        &#125;<br><br>        count1 = <span class="hljs-number">0</span>;<br>        count2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == candidate1) &#123;<br>                count1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == candidate2) &#123;<br>                count2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count1 &gt; nums.length / <span class="hljs-number">3</span>) &#123;<br>            res.add(candidate1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count2 &gt; nums.length / <span class="hljs-number">3</span>) &#123;<br>            res.add(candidate2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (nums === <span class="hljs-literal">null</span> || nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> candidate1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> candidate2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> count1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> count2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (num === candidate1) &#123;<br>            count1++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num === candidate2) &#123;<br>            count2++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count1 === <span class="hljs-number">0</span>) &#123;<br>            candidate1 = num;<br>            count1++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count2 === <span class="hljs-number">0</span>) &#123;<br>            candidate2 = num;<br>            count2++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count1--;<br>            count2--;<br>        &#125;<br>    &#125;<br><br>    count1 = <span class="hljs-number">0</span>;<br>    count2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (num === candidate1) &#123;<br>            count1++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num === candidate2) &#123;<br>            count2++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count1 &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">3</span>)) &#123;<br>        res.<span class="hljs-title function_">push</span>(candidate1);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count2 &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">3</span>)) &#123;<br>        res.<span class="hljs-title function_">push</span>(candidate2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">169. Majority Element<br>229. Majority Element II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 979. Distribute Coins in Binary Tree</title>
    <link href="/posts/209886719.html"/>
    <url>/posts/209886719.html</url>
    
    <content type="html"><![CDATA[<p>You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.</p><p>In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.</p><p>Return the minimum number of moves required to make every node have exactly one coin.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree1.png" alt="Example 1"><br>Input: root &#x3D; [3,0,0]<br>Output: 2<br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/01/18/tree2.png" alt="Example 2"><br>Input: root &#x3D; [0,3,0]<br>Output: 3<br>Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.</p><p>Constraints:<br>The number of nodes in the tree is n.<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>0 &lt;&#x3D; Node.val &lt;&#x3D; n<br>The sum of all Node.val is n.</p><p>在二叉树中分配硬币。</p><blockquote>给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。</p><p>返回使每个结点上只有一枚硬币所需的移动次数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree">https://leetcode.cn/problems/distribute-coins-in-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是后序遍历。这道题的后续遍历不太容易想到，因为最后要求的东西跟你在后序遍历里往父节点送的信息是不一样的。</p><p>这里有几个细节需要想明白，</p><ol><li><p>因为我们最后要求的是硬币的移动次数，所以我们不需要把树变成图，对于没有硬币的节点，我们只需要让他往自己的父节点送出“我和我的左右子树一共需要X个硬币”这个信息即可。</p></li><li><p>对于硬币不足的节点，他往父节点送的那个值是负的；但是对于硬币很多的节点，他往父节点送的那个值是正的。</p></li><li><p>res 统计的是硬币移动的步数，跟某个节点需要多少个硬币无关，所以在累加的时候要取绝对值。</p></li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>helper(root);<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> helper(root.left);<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> helper(root.right);<br>res += Math.abs(left) + Math.abs(right);<br><span class="hljs-comment">// 当前位置只要留一个金币，所以往父节点返回的是剩下所有金币的个数</span><br><span class="hljs-keyword">return</span> root.val + left + right - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1291. Sequential Digits</title>
    <link href="/posts/1079351292.html"/>
    <url>/posts/1079351292.html</url>
    
    <content type="html"><![CDATA[<p>An integer has sequential digits if and only if each digit in the number is one more than the previous digit.</p><p>Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.</p><p>Example 1:<br>Input: low &#x3D; 100, high &#x3D; 300<br>Output: [123,234]</p><p>Example 2:<br>Input: low &#x3D; 1000, high &#x3D; 13000<br>Output: [1234,2345,3456,4567,5678,6789,12345]</p><p>Constraints:<br>10 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 10^9</p><p>顺次数。</p><blockquote><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。<br>请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个下限 low 和一个上限 high，请输出一个有序的 list，list 里面是所有介于 low 和 high 之间的数字，同时数字满足每一位上的数字都比前一位上的数字大 1 。这道题有三种做法。暴力枚举，DFS和BFS。因为数据量的关系，所以这道题我觉得无论是什么做法，时间复杂度都是O(1)，空间复杂度都是O(n)，因为要输出的是一个list。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - 因为在 low 和 high 之间的数字个数是有限的<br>空间O(1) - 因为在 low 和 high 之间的数字个数是有限的</p><h2 id="思路一-暴力枚举"><a href="#思路一-暴力枚举" class="headerlink" title="思路一 - 暴力枚举"></a>思路一 - 暴力枚举</h2><p>枚举虽然是暴力，但是由于最后答案本身就不是很多，所以代码也能过。具体的思路是，首先创建一个字符串“123456789”，按位遍历这个字符串，以在指针i上的数字作为开头，并尝试生成后面更大的数字。如果生成的数字大于high了就停止。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">sequentialDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456789&quot;</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; s.length() - i + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(j, j + i));<br>                <span class="hljs-keyword">if</span> (num &gt; high) &#123;<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (num &gt;= low) &#123;<br>                    res.add(num);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-DFS"><a href="#思路二-DFS" class="headerlink" title="思路二 - DFS"></a>思路二 - DFS</h2><p>DFS的做法也是从1到9开始确定第一位上的数字。同时需要一个变量target记录已经生成的数字，那么下一个要被生成的数字就是target * 10 + start。举例，假设第一位start &#x3D; 1，此时的target也是1；当遍历到下一层的时候，start &#x3D; 2，target &#x3D; 10 + 2 &#x3D; 12；再下一层的时候，start &#x3D; 3，target &#x3D; 120 + 3 &#x3D; 123。以此类推。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">sequentialDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            dfs(res, i, <span class="hljs-number">0</span>, low, high);<br>        &#125;<br>        Collections.sort(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; res, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (target &gt;= low &amp;&amp; target &lt;= high) &#123;<br>            res.add(target);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (start &gt; <span class="hljs-number">9</span> || target &gt; high) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(res, start + <span class="hljs-number">1</span>, target * <span class="hljs-number">10</span> + start, low, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路三-BFS"><a href="#思路三-BFS" class="headerlink" title="思路三 - BFS"></a>思路三 - BFS</h2><p>BFS的做法跟DFS类似，也是先拿到第一个数字，用queue去筛一遍，如果在范围内就加到结果集。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">sequentialDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            queue.offer(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">if</span> (target &gt;= low &amp;&amp; target &lt;= high) &#123;<br>                res.add(target);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> target % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (tail &lt; <span class="hljs-number">9</span> &amp;&amp; target &lt;= high) &#123;<br>                queue.offer(target * <span class="hljs-number">10</span> + tail + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>enumeration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 421. Maximum XOR of Two Numbers in an Array</title>
    <link href="/posts/2693420280.html"/>
    <url>/posts/2693420280.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 &lt;&#x3D; i &lt;&#x3D; j &lt; n.<br>Example 1:<br>Input: nums &#x3D; [3,10,5,25,2,8]<br>Output: 28<br>Explanation: The maximum result is 5 XOR 25 &#x3D; 28.<br>Example 2:<br>Input: nums &#x3D; [14,70,53,83,49,91,36,80,92,51,66,70]<br>Output: 127<br>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p><p>数组中两个数的最大异或值。</p><blockquote><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我这里提供一个位运算的做法，大部分内容参考了<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/li-yong-yi-huo-yun-suan-de-xing-zhi-tan-xin-suan-f/" title="这个帖子">这个帖子</a>。首先复习一下异或运算规则：两个二进制的数字，同一个位置上的数字不同，XOR 为 1；数字相同的时候，XOR 为 0。所以这里如果要找 XOR 最大的结果，最好能找到两个数字，他们的二进制表达最好在每一位上都不同。而且 XOR 是具有交换律的，如果你有 a ^ b &#x3D; c，你同时可以得到 a ^ c &#x3D; b 和 b ^ c &#x3D; a。假如 a 和 b 是来自于 nums 的数字的话，我们为了要使 c 最大，我们可以试图去找一个前缀很大的数字 a 和一个前缀很小的数字 b，这样他们做 XOR 运算的时候才有可能使 c 的前缀更大。</p><p>这里我们创建一个mask去判断每个二进制数字的前缀。mask是由10000…000到11111…111（32位）。随着mask的变大，比如从10000到11111（我这里暂时用5位表示），如果nums里面的数字跟mask比较的时候，他们的前缀里面也包含1的话，在做AND运算的时候，会得到这些前缀。此时我们在找前缀的同时，把这些前缀存到一个hashset里。每一个mask都会与input数组里面的每一个数字做AND运算，得到一个前缀，set里最终留下的是所有unique的前缀。</p><p>此时再创建一个mask叫做temp，也是从1 - 31逐渐增加1的个数。这里我理解temp就是在猜最后XOR的结果，然后往回套，看hashset是否存在两个数字a和b满足a ^ b &#x3D; temp。判断的方式是对于hashset里面的某个元素a，如果满足a ^ temp &#x3D; b，同时b也在hashset中，则表明找到了一个有效的temp。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">// 先确定高位，再确定低位（有点贪心算法的意思），才能保证这道题的最大性质</span><br><span class="hljs-comment">// 一位接着一位去确定这个数位的大小</span><br><span class="hljs-comment">// 利用性质： a ^ b = c ，则 a ^ c = b，且 b ^ c = a</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-comment">// 注意点1：注意保留前缀的方法，mask 是这样得来的</span><br><span class="hljs-comment">// 用异或也是可以的 mask = mask ^ (1 &lt;&lt; i);</span><br>mask = mask | (<span class="hljs-number">1</span> &lt;&lt; i);<br><span class="hljs-comment">// System.out.println(&quot;mask is &quot; + Integer.toBinaryString(mask));</span><br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br><span class="hljs-comment">// 注意点2：这里使用 &amp; ，保留前缀的意思（从高位到低位）</span><br>set.add(num &amp; mask);<br>&#125;<br><br><span class="hljs-comment">// 这里先假定第 n 位为 1 ，前 n-1 位 res 为之前迭代求得</span><br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> res | (<span class="hljs-number">1</span> &lt;&lt; i);<br>System.out.println(<span class="hljs-string">&quot;temp is &quot;</span> + Integer.toBinaryString(temp));<br><span class="hljs-keyword">for</span> (Integer prefix : set) &#123;<br><span class="hljs-keyword">if</span> (set.contains(prefix ^ temp)) &#123;<br>res = temp;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二刷我再提供一个前缀树的做法，我参考了<a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/solutions/778291/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-h-n9m9/?envType=daily-question&envId=2023-11-04">这个帖子</a>。难得官方写了一篇好帖子。</p><p>对于一个数字，我们可以用一个长度为 32 的二进制数字来表达。如果我们从高位到低位把每个位置上的 digit 放入一棵字典树（这里其实只有 0 和 1 两种情况所以是二叉树），那么对于某个数字 x 而言，如果我要找和他做 XOR 操作结果更大的数字，那么我只要尽量去找每一个 digit 上都与 x 不同的数字即可，这个概念平移到这棵二叉树里，就是在每个 node 上，如果 x 在这个位置上是 1，那么我就尽量去往 0 的那个分支上走，反之如果 x 在这个位置上是 0，那么我就尽量去往 1 的那个分支上走。</p><p>具体到这道题，对于某个数字 nums[i]，我会先把前 i - 1 个数字的二进制表达都放到字典树里，那么我在遍历当前这个数字 nums[i] 的时候，我就可以找到与他做 XOR 运算能得到的最大结果是多少。</p><p>时间O(nlogc) - n 个数字，每个数字被插入字典树的复杂度为O(logc)<br>空间O(nlogc)<br>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HIGH_BIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>add(nums[i - <span class="hljs-number">1</span>]);<br>x = Math.max(x, check(nums[i]));<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> HIGH_BIT; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (bit == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span>) &#123;<br>cur.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>&#125;<br>cur = cur.left;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (cur.right == <span class="hljs-literal">null</span>) &#123;<br>cur.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>&#125;<br>cur = cur.right;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> HIGH_BIT; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> (num &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 如果当前位是0，我们则应该去找1</span><br><span class="hljs-comment">// 反之也是一样，这样XOR的结果才会更大</span><br><span class="hljs-comment">// 如果当前是0，应该往右子树走</span><br><span class="hljs-comment">// 但如果右子树为空，则只能往左子树走</span><br><span class="hljs-keyword">if</span> (bit == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>cur = cur.right;<br>x = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cur = cur.left;<br>x = x * <span class="hljs-number">2</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>cur = cur.left;<br>x = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cur = cur.right;<br>x = x * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>bit manipulation</tag>
      
      <tag>trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 299. Bulls and Cows</title>
    <link href="/posts/2672063042.html"/>
    <url>/posts/2672063042.html</url>
    
    <content type="html"><![CDATA[<p>You are playing the Bulls and Cows game with your friend.</p><p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p><p>The number of “bulls”, which are digits in the guess that are in the correct position.<br>The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.<br>Given the secret number secret and your friend’s guess guess, return the hint for your friend’s guess.</p><p>The hint should be formatted as “xAyB”, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.</p><p>Example 1:<br>Input: secret &#x3D; “1807”, guess &#x3D; “7810”<br>Output: “1A3B”<br>Explanation: Bulls are connected with a ‘|’ and cows are underlined:<br>“1807”<br> |<br>“7810”</p><p>Example 2:<br>Input: secret &#x3D; “1123”, guess &#x3D; “0111”<br>Output: “1A1B”<br>Explanation: Bulls are connected with a ‘|’ and cows are underlined:<br>“1123” “1123”<br> | or |<br>“0111” “0111”<br>Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.</p><p>Constraints:<br>1 &lt;&#x3D; secret.length, guess.length &lt;&#x3D; 1000<br>secret.length &#x3D;&#x3D; guess.length<br>secret and guess consist of digits only.</p><p>猜数字游戏。</p><blockquote><p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：</p><p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p><p>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），<br>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。<br>给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。</p><p>提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。</p><p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bulls-and-cows">https://leetcode-cn.com/problems/bulls-and-cows</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题不涉及任何算法，需要用到 hashmap。用一个 for loop 遍历 secret 和 guess，当在同一位置上的数字相同时，就 bulls++，说明在同样位置找到了正确的字母；但是当同一位置上的字母不同的时候，则分别用两个数组记录 secret 和 guess 这个位置上出现的数字分别是什么。input 遍历完之后，再遍历一遍刚才的 num 数组，在数组中相同位置上的次数，取较小的那个，记为 cows。最后再把字符串按规则拼接好输出即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHint</span><span class="hljs-params">(String secret, String guess)</span> &#123;<br>        <span class="hljs-type">int</span>[] map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span>[] map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> secret.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bulls</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cows</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> secret.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> guess.charAt(i);<br>            <span class="hljs-keyword">if</span> (s == g) &#123;<br>                bulls++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map1[s - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>                map2[g - <span class="hljs-string">&#x27;0&#x27;</span>]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(map1[i], map2[i]);<br>            cows += min;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> bulls + <span class="hljs-string">&quot;A&quot;</span> + cows + <span class="hljs-string">&quot;B&quot;</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1022. Sum of Root To Leaf Binary Numbers</title>
    <link href="/posts/3650823632.html"/>
    <url>/posts/3650823632.html</url>
    
    <content type="html"><![CDATA[<p>You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.</p><p>For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.<br>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers.</p><p>The test cases are generated so that the answer fits in a 32-bits integer.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt="Example 1"><br>Input: root &#x3D; [1,0,1,0,1,0,1]<br>Output: 22<br>Explanation: (100) + (101) + (110) + (111) &#x3D; 4 + 5 + 6 + 7 &#x3D; 22</p><p>Example 2:<br>Input: root &#x3D; [0]<br>Output: 0</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 1000].<br>Node.val is 0 or 1.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前序遍历，几乎和 129 题一样。只不过这里的数字是二进制的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRootToLeaf</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        helper(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum = sum * <span class="hljs-number">2</span> + node.val;<br>        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) &#123;<br>            res += sum;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        helper(node.left, sum);<br>        helper(node.right, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">129. Sum Root to Leaf Numbers<br>1022. Sum of Root To Leaf Binary Numbers<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 875. Koko Eating Bananas</title>
    <link href="/posts/3212402937.html"/>
    <url>/posts/3212402937.html</url>
    
    <content type="html"><![CDATA[<p>Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.</p><p>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour.</p><p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.</p><p>Return the minimum integer K such that she can eat all the bananas within H hours.</p><p>Example 1:<br>Input: piles &#x3D; [3,6,7,11], H &#x3D; 8<br>Output: 4</p><p>Example 2:<br>Input: piles &#x3D; [30,11,23,4,20], H &#x3D; 5<br>Output: 30</p><p>Example 3:<br>Input: piles &#x3D; [30,11,23,4,20], H &#x3D; 6<br>Output: 23</p><p>Constraints:<br>1 &lt;&#x3D; piles.length &lt;&#x3D; 10^4<br>piles.length &lt;&#x3D; H &lt;&#x3D; 10^9<br>1 &lt;&#x3D; piles[i] &lt;&#x3D; 10^9</p><p>爱吃香蕉的珂珂。</p><blockquote>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。<p>珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/koko-eating-bananas">https://leetcode.cn/problems/koko-eating-bananas</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是二分法，而且这道题属于是在答案上二分的类型。这里题目的限制条件的最后一条规定了 piles[i] 不会大于 10 的九次方，所以二分法的上界我直接就取了 10^9。这里二分是在分猴子吃香蕉的速度，这是最后要求的答案。二分法得到某一个速度 mid 之后，去计算吃掉所有香蕉需要花费的时间。这里我们需要额外写一个函数去做计算时间的工作。在这个计算时间的函数里，对于某一堆香蕉，如果香蕉数 % 速度 不等于 0，那么意味着时间需要 + 1。例子，比如吃的速度是 3，但是香蕉有 10 个，那么就必须分 4 个小时吃完。注意因为题目要我们计算的是最小速度，所以如果计算出来的时间小于 H 则说明速度快了，需要往左半边走，减慢速度；反之则往右半边走，加快速度。二分法的 while 循环退出的那一刻，low 就是满足题意的最小速度。同时注意二分法的左指针初始化不能为 0，因为这里是对吃香蕉的速度做二分，如果涉及 0，计算时间的时候是会报错的，除法分母不能为 0。</p><p>二刷我把 getHour 函数改成 long 型了，因为官方加了新的 case。整形是过不去的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mlogn) - logn的部分是在做二分，乘以 m 是因为每得到一个速度之后都要带回 piles 去计算时间<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Java实现一"><a href="#Java实现一" class="headerlink" title="Java实现一"></a>Java实现一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> H)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> getHour(piles, mid);<br>            <span class="hljs-keyword">if</span> (hour &lt;= H) &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getHour</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> speed)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : piles) &#123;<br>            res += p / speed;<br>            <span class="hljs-keyword">if</span> (p % speed != <span class="hljs-number">0</span>) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Java实现二"><a href="#Java实现二" class="headerlink" title="Java实现二"></a>Java实现二</h3><p>我再提供一个左闭右开的二分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>);<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> helper(piles, mid);<br>            <span class="hljs-comment">// 如果耗时太多，说明速度太慢，需要移动左指针</span><br>            <span class="hljs-comment">// 反之移动右指针</span><br>            <span class="hljs-keyword">if</span> (hour &gt; h) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] piles, <span class="hljs-type">int</span> speed)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : piles) &#123;<br>            res += p / speed;<br>            <span class="hljs-keyword">if</span> (p % speed != <span class="hljs-number">0</span>) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">410. Split Array Largest Sum<br>774. Minimize Max Distance to Gas Station<br>875. Koko Eating Bananas<br>1011. Capacity To Ship Packages In N Days<br>1060. Missing Element in Sorted Array<br>1231. Divide Chocolate<br>1283. Find the Smallest Divisor Given a Threshold<br>1482. Minimum Number of Days to Make m Bouquets<br>1539. Kth Missing Positive Number<br>1870. Minimum Speed to Arrive on Time<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>binary search on answer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 223. Rectangle Area</title>
    <link href="/posts/2125874500.html"/>
    <url>/posts/2125874500.html</url>
    
    <content type="html"><![CDATA[<p>Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.</p><p>The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2).</p><p>The second rectangle is defined by its bottom-left corner (bx1, by1) and its top-right corner (bx2, by2).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png" alt="Example 1"><br>Rectangle Area<br>Input: ax1 &#x3D; -3, ay1 &#x3D; 0, ax2 &#x3D; 3, ay2 &#x3D; 4, bx1 &#x3D; 0, by1 &#x3D; -1, bx2 &#x3D; 9, by2 &#x3D; 2<br>Output: 45</p><p>Example 2:<br>Input: ax1 &#x3D; -2, ay1 &#x3D; -2, ax2 &#x3D; 2, ay2 &#x3D; 2, bx1 &#x3D; -2, by1 &#x3D; -2, bx2 &#x3D; 2, by2 &#x3D; 2<br>Output: 16</p><p>Constraints:<br>-104 &lt;&#x3D; ax1 &lt;&#x3D; ax2 &lt;&#x3D; 104<br>-104 &lt;&#x3D; ay1 &lt;&#x3D; ay2 &lt;&#x3D; 104<br>-104 &lt;&#x3D; bx1 &lt;&#x3D; bx2 &lt;&#x3D; 104<br>-104 &lt;&#x3D; by1 &lt;&#x3D; by2 &lt;&#x3D; 104</p><p>矩形面积。</p><blockquote><p>给你 二维 平面上两个 由直线构成且边与坐标轴平行&#x2F;垂直 的矩形，请你计算并返回两个矩形覆盖的总面积。</p><p>每个矩形由其 左下 顶点和 右上 顶点坐标表示：</p><p>第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。<br>第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/rectangle-area">https://leetcode.cn/problems/rectangle-area</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给两个矩形的左下角的坐标和右上角的坐标，请你返回由这两个矩形组成的多边形的面积。</p><p>思路是先计算两个矩形各自的面积，再计算两者重叠的部分，最后用两个矩形各自的面积 - 两者重叠的部分即可。各自计算两个长方形的面积这个很好处理，但是如何计算重叠部分的面积呢？这个题不要想复杂了，可以就参照题目给的例子来计算重叠部分的面积。对于这个重叠的部分，左下角的横坐标是A和E的较大值，右上角的横坐标是C和G的较小值，所以重叠部分的长是Math.min(ax2, bx2) - Math.max(ax1, bx1)。同理，重叠部分的高 &#x3D; Math.min(ay2, by2) - Math.max(ay1, by1)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeArea</span><span class="hljs-params">(<span class="hljs-type">int</span> ax1, <span class="hljs-type">int</span> ay1, <span class="hljs-type">int</span> ax2, <span class="hljs-type">int</span> ay2, <span class="hljs-type">int</span> bx1, <span class="hljs-type">int</span> by1, <span class="hljs-type">int</span> bx2, <span class="hljs-type">int</span> by2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">areaA</span> <span class="hljs-operator">=</span> (ax2 - ax1) * (ay2 - ay1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">areaB</span> <span class="hljs-operator">=</span> (bx2 - bx1) * (by2 - by1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">overlap</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(ax1, bx1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(ax2, bx2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> Math.min(ay2, by2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> Math.max(ay1, by1);<br>        <span class="hljs-keyword">if</span> (right &gt; left &amp;&amp; top &gt; bottom) &#123;<br>            overlap = (right - left) * (top - bottom);<br>        &#125;<br>        <span class="hljs-keyword">return</span> areaA + areaB - overlap;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">223. Rectangle Area<br>836. Rectangle Overlap<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>geometry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 429. N-ary Tree Level Order Traversal</title>
    <link href="/posts/4008872034.html"/>
    <url>/posts/4008872034.html</url>
    
    <content type="html"><![CDATA[<p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p><p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="Example 1"><br>Input: root &#x3D; [1,null,3,2,4,null,5,6]<br>Output: [[1],[3,2,4],[5,6]]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="Example 2"><br>Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p><p>Constraints:<br>The height of the n-ary tree is less than or equal to 1000<br>The total number of nodes is between [0, 104]</p><p>N 叉树的层序遍历。<br>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。<br>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然是层序遍历，那么方法一定是 BFS 跑不了了。如果对层序遍历不熟悉，建议先做一下 102 题和 107 题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n^2) - output</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public List&lt;Node&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(cur.val);<br>                <span class="hljs-keyword">for</span> (Node node : cur.children) &#123;<br>                    queue.offer(node);<br>                &#125;<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">102. Binary Tree Level Order Traversal<br>107. Binary Tree Level Order Traversal II<br>429. N-ary Tree Level Order Traversal<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>590. N-ary Tree Postorder Traversal</title>
    <link href="/posts/3703104611.html"/>
    <url>/posts/3703104611.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of an n-ary tree, return the postorder traversal of its nodes’ values.</p><p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="Example 1"><br>Input: root &#x3D; [1,null,3,2,4,null,5,6]<br>Output: [5,6,3,2,4,1]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="Example 2"><br>Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 104].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>The height of the n-ary tree is less than or equal to 1000.</p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><p>N 叉树的后序遍历。</p><blockquote><p>给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。<br>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的 followup 依然是问是否能用迭代的做法实现。我这里把迭代和递归的做法都练习了一下。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>迭代和递归的做法复杂度一样<br>时间O(n)<br>空间O(n)</p><h2 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            res.add(<span class="hljs-number">0</span>, cur.val);<br>            <span class="hljs-keyword">if</span> (cur.children != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (Node child : cur.children) &#123;<br>                    stack.push(child);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        helper(res, root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Integer&gt; res, Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Node child : root.children) &#123;<br>            helper(res, child);<br>        &#125;<br>        res.add(root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
      <tag>n-ary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 622. Design Circular Queue</title>
    <link href="/posts/234289577.html"/>
    <url>/posts/234289577.html</url>
    
    <content type="html"><![CDATA[<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called “Ring Buffer”.</p><p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p><p>Implement the MyCircularQueue class:<br>MyCircularQueue(k) Initializes the object with the size of the queue to be k.<br>int Front() Gets the front item from the queue. If the queue is empty, return -1.<br>int Rear() Gets the last item from the queue. If the queue is empty, return -1.<br>boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.<br>boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.<br>boolean isEmpty() Checks whether the circular queue is empty or not.<br>boolean isFull() Checks whether the circular queue is full or not.<br>You must solve the problem without using the built-in queue data structure in your programming language. </p><p>Example 1:<br>Input<br>[“MyCircularQueue”, “enQueue”, “enQueue”, “enQueue”, “enQueue”, “Rear”, “isFull”, “deQueue”, “enQueue”, “Rear”]<br>[[3], [1], [2], [3], [4], [], [], [], [4], []]<br>Output<br>[null, true, true, true, false, 3, true, true, true, 4]</p><p>Explanation<br>MyCircularQueue myCircularQueue &#x3D; new MyCircularQueue(3);<br>myCircularQueue.enQueue(1); &#x2F;&#x2F; return True<br>myCircularQueue.enQueue(2); &#x2F;&#x2F; return True<br>myCircularQueue.enQueue(3); &#x2F;&#x2F; return True<br>myCircularQueue.enQueue(4); &#x2F;&#x2F; return False<br>myCircularQueue.Rear();     &#x2F;&#x2F; return 3<br>myCircularQueue.isFull();   &#x2F;&#x2F; return True<br>myCircularQueue.deQueue();  &#x2F;&#x2F; return True<br>myCircularQueue.enQueue(4); &#x2F;&#x2F; return True<br>myCircularQueue.Rear();     &#x2F;&#x2F; return 4</p><p>Constraints:<br>1 &lt;&#x3D; k &lt;&#x3D; 1000<br>0 &lt;&#x3D; value &lt;&#x3D; 1000<br>At most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull.</p><p>设计循环队列。</p><blockquote>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><p>MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/design-circular-queue">https://leetcode-cn.com/problems/design-circular-queue</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路还是比较直观的，既然是环形队列，说明一定是只能使用固定大小的内存。为了达到这个题的练习目的，这道题我用数组实现。创建一个长度为 K 的数组，同时创建几个变量，front, rear是数组前后的两个指针，代表enque和deque的位置，len 记录数组目前的长度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(k)</p><h2 id="代码-数组实现"><a href="#代码-数组实现" class="headerlink" title="代码 - 数组实现"></a>代码 - 数组实现</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rear</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFull()) &#123;<br>            rear = (rear + <span class="hljs-number">1</span>) % a.length;<br>            a[rear] = val;<br>            len++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isEmpty()) &#123;<br>            front = (front + <span class="hljs-number">1</span>) % a.length;<br>            len--;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> isEmpty() ? -<span class="hljs-number">1</span> : a[front];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Rear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> isEmpty() ? -<span class="hljs-number">1</span> : a[rear];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> len == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> len == a.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码-链表实现"><a href="#代码-链表实现" class="headerlink" title="代码 - 链表实现"></a>代码 - 链表实现</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    Node next;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br>    Node head, tail;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.k = k;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count == <span class="hljs-built_in">this</span>.k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count == <span class="hljs-number">0</span>) &#123;<br>            head = tail = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.next = newNode;<br>            tail = tail.next;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.count++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-built_in">this</span>.head.next;<br>        <span class="hljs-built_in">this</span>.count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Rear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tail.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count == <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count == k;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyCircularQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyCircularQueue obj = new MyCircularQueue(k);</span><br><span class="hljs-comment"> * boolean param_1 = obj.enQueue(value);</span><br><span class="hljs-comment"> * boolean param_2 = obj.deQueue();</span><br><span class="hljs-comment"> * int param_3 = obj.Front();</span><br><span class="hljs-comment"> * int param_4 = obj.Rear();</span><br><span class="hljs-comment"> * boolean param_5 = obj.isEmpty();</span><br><span class="hljs-comment"> * boolean param_6 = obj.isFull();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">146. LRU Cache<br>460. LFU Cache<br>622. Design Circular Queue<br>641. Design Circular Deque<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>design</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 373. Find K Pairs with Smallest Sums</title>
    <link href="/posts/1953746004.html"/>
    <url>/posts/1953746004.html</url>
    
    <content type="html"><![CDATA[<p>You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.</p><p>Define a pair (u, v) which consists of one element from the first array and one element from the second array.</p><p>Return the k pairs (u1, v1), (u2, v2), …, (uk, vk) with the smallest sums.</p><p>Example 1:<br>Input: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3<br>Output: [[1,2],[1,4],[1,6]]<br>Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</p><p>Example 2:<br>Input: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2<br>Output: [[1,1],[1,1]]<br>Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</p><p>Constraints:<br>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 109<br>nums1 and nums2 both are sorted in non-decreasing order.<br>1 &lt;&#x3D; k &lt;&#x3D; 104<br>k &lt;&#x3D; nums1.length * nums2.length</p><p>查找和最小的 K 对数字。</p><blockquote><p>给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。</p><p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。</p><p>找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums">https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-暴力解"><a href="#思路一-暴力解" class="headerlink" title="思路一 - 暴力解"></a>思路一 - 暴力解</h2><p>因为 input 数组是有序的，所以直觉上你会往双指针的思路上靠，但是后来发觉是不行的。为什么不行呢？看第二个例子，一开始你肯定是两个数组各自的第一个元素 (<code>nums1[0]</code> 和 <code>nums2[0]</code>) 拿出来组成第一个 pair，但是之后呢，你怎么决定到底要移动哪个数组的指针呢？并不是说因着你用过了 nums1[i] 你就需要移动 i，同理，并不是说你用过了 nums2[j] 你就要移动 j。同时注意 i 指针和 j 指针可以指向同一个下标。可以想象一个极端的例子，如果 nums1 的第一个元素非常非常小，然后 nums2 里面的元素都很大，很可能这 K 个 pair 里面都有 nums1 的这第一个元素。</p><p>正确的思路是用 priority queue 创建一个 pair 中两个数的和的最小堆，最后弹出 K 个 pair 即可。但是这个做法相当于是两层 for 循环的暴力解，会超时。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogk)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums1 == <span class="hljs-literal">null</span> || nums2 == <span class="hljs-literal">null</span> || nums1.length == <span class="hljs-number">0</span> || nums2.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; (a[<span class="hljs-number">0</span>] + a[<span class="hljs-number">1</span>]) - (b[<span class="hljs-number">0</span>] + b[<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; Math.min(k, nums2.length); j++) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; nums1[i], nums2[j] &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (k != <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            list.add(cur[<span class="hljs-number">0</span>]);<br>            list.add(cur[<span class="hljs-number">1</span>]);<br>            res.add(list);<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// TLE by August 2022</span><br></code></pre></td></tr></table></figure><h2 id="思路二-最大堆"><a href="#思路二-最大堆" class="headerlink" title="思路二 - 最大堆"></a>思路二 - 最大堆</h2><p>优化的思路是改成一个最大堆。还是先把所有的 pair 放入 priority queue 中，当这个优先队列的 size 小于 K 的时候，直接加入即可；但是当这个优先队列的 size 大于等于 K 了，但是此时还有元素需要加进去的时候，比较一下堆顶元素的 sum 和要加进去的元素的 sum 谁更大，抛弃掉更大的那个元素。最后优先队列里剩下前 K 小的元素。将这些元素再加入结果集中输出即可。可惜这个做法现在因为加了新的testcase，也会超时。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogk)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>                (a, b) -&gt; (nums1[a[<span class="hljs-number">0</span>]] + nums2[a[<span class="hljs-number">1</span>]]) - (nums1[b[<span class="hljs-number">0</span>]] + nums2[b[<span class="hljs-number">1</span>]]));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, <span class="hljs-number">0</span> &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; res.size() &lt; k) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            res.add(Arrays.asList(nums1[a], nums2[b]));<br>            <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> &lt; nums2.length) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; a, b + <span class="hljs-number">1</span> &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路三-最小堆"><a href="#思路三-最小堆" class="headerlink" title="思路三 - 最小堆"></a>思路三 - 最小堆</h2><p>[2022年8月更新] 这里我再提供一个不超时的方法，大体思路也是用最小堆实现归并排序，类似 23 和 378 题。注意题目给的条件，两个数组都是各自有序的，那么假如对于一个来自 nums1 的数字 u1 而言，他可以和 nums2 里面每个数字 vx 都形成一个 pair，并且他们的和也是有序的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[ [u1, v1], [u1, v2], [u1, v3], [u1, v4], ...[u1, vn-1], [u1, vn] ]<br></code></pre></td></tr></table></figure><p>那么对于在 nums1 里的每个数字，他都可以和 nums2 里所有的数字组成这样一个有序的数组。所以这个题目就可以转化为对多个有序的数组进行归并排序并找出其中最小的 K 个元素。如下这个矩阵里，每一行的 pair sum 是从小到大排列的，每一列也是从小到大排列的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">[ [u1, v1], [u1, v2], [u1, v3], [u1, v4], ...[u1, vn-1], [u1, vn] ]<br>[ [u2, v1], [u2, v2], [u2, v3], [u2, v4], ...[u2, vn-1], [u2, vn] ]<br>[ [u3, v1], [u3, v2], [u3, v3], [u3, v4], ...[u3, vn-1], [u3, vn] ]<br>……………………………………………………………………<br>[ [um - 1, v1], [um - 1, v2], [um - 1, v3], [um - 1, v4], ...[um - 1, vn-1], [um - 1, vn] ]<br>[ [um, v1], [um, v2], [um, v3], [um, v4], ...[um, vn-1], [um, vn] ]<br></code></pre></td></tr></table></figure><p>我参考了<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/2286318/jiang-qing-chu-wei-shi-yao-yi-kai-shi-ya-i0dj">这个帖子</a>。具体的做法是创建一个<code>最小堆</code>，里面存的是<code>[i, j, nums1[i] + nums[j]]</code>。初始化的时候，我们把所有的来自 nums1 的下标与 0 打包，放到最小堆里，模拟的是矩阵里第一列的内容。</p><p>全局最小的元素应该是 <code>[u1, v1]</code>，这个没什么疑问。但是最小堆中下一个元素是什么呢？有可能是 <code>[u1, v2]</code>，也有可能是<code>[u2, v1]</code>，但是这会导致一个问题：当我们拿到 <code>[u1, v2]</code> 的时候，我们会把 <code>[u2, v2]</code> 入堆；当<code>[u2, v1]</code> 出堆的时候，<code>[u2, v2]</code>会被再次入堆，这里需要去重。</p><p>如何做去重的工作呢？可以用 hashset，但是帖子里提供了一个很巧妙的思路。我们先将所有的 [u1, v1]、[u2, v1]、[u3, v1] 等等都入堆，然后每次出堆的时候，只增加 v 的值，比如当我们从最小堆中弹出 <code>[u1, v1]</code> 的时候，入堆的元素是<code>[u1, v2]</code>，而不是 <code>[u2, v1]</code>。这样就可以做到去重。</p><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(klogk)<br>空间O(n)</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">kSmallestPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(k, nums1.length); i++) &#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; nums1[i] + nums2[<span class="hljs-number">0</span>], i, <span class="hljs-number">0</span> &#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (res.size() &lt; k) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>            res.add(Arrays.asList(nums1[i], nums2[j]));<br>            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; nums2.length) &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; nums1[i] + nums2[j + <span class="hljs-number">1</span>], i, j + <span class="hljs-number">1</span> &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/solutions/2286318/jiang-qing-chu-wei-shi-yao-yi-kai-shi-ya-i0dj</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">373. Find K Pairs with Smallest Sums<br>378. Kth Smallest Element in a Sorted Matrix<br>719. Find K-th Smallest Pair Distance<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 437. Path Sum III</title>
    <link href="/posts/2893620560.html"/>
    <url>/posts/2893620560.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="Example 1"><br>Input: root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8<br>Output: 3<br>Explanation: The paths that sum to 8 are shown.</p><p>Example 2:<br>Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>Output: 3</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 1000].<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><p>路径总和 III。</p><blockquote><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/path-sum-iii">https://leetcode.cn/problems/path-sum-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意和前两个版本类似，但是这个题找的路径和，起点可以不是根节点，问满足路径和为 sum 的路径有多少。</p><p>思路是前缀和。利用前缀和的思路，递归统计你遍历到的子树上的前缀和 presum 是多少，并将这个前缀和存入 hashmap。其他的部分就是很常规的前序遍历。注意最后一个 case 会导致 Integer 越界，需要用 long 型。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 树有 n 个节点<br>空间O(n) - hashmap</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        HashMap&lt;Long, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        helper(root, <span class="hljs-number">0L</span>, targetSum, map);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> curSum, <span class="hljs-type">int</span> targetSum, HashMap&lt;Long, Integer&gt; map)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        curSum += root.val;<br>        <span class="hljs-keyword">if</span> (map.containsKey(curSum - targetSum)) &#123;<br>            count += map.get(curSum - targetSum);<br>        &#125;<br>        map.put(curSum, map.getOrDefault(curSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        helper(root.left, curSum, targetSum, map);<br>        helper(root.right, curSum, targetSum, map);<br>        map.put(curSum, map.get(curSum) - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">112. Path Sum<br>113. Path Sum II<br>437. Path Sum III<br>1457. Pseudo-Palindromic Paths in a Binary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 529. Minesweeper</title>
    <link href="/posts/221433062.html"/>
    <url>/posts/221433062.html</url>
    
    <content type="html"><![CDATA[<p>Let’s play the minesweeper game (Wikipedia, online game)!</p><p>You are given an m x n char matrix board representing the game board where:</p><p>‘M’ represents an unrevealed mine,<br>‘E’ represents an unrevealed empty square,<br>‘B’ represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),<br>digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and<br>‘X’ represents a revealed mine.</p><p>You are also given an integer array click where click &#x3D; [clickr, clickc] represents the next click position among all the unrevealed squares (‘M’ or ‘E’).</p><p>Return the board after revealing this position according to the following rules:</p><ol><li>The range of the input matrix’s height and width is [1,50].</li><li>The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square.</li><li>The input board won’t be a stage when game is over (some mines have been revealed).</li><li>For simplicity, not mentioned rules <span style="color:red">should be ignored in this problem</span>. For example, you don’t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li></ol><p>Example 1:<br>Input: </p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[[<span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;M</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;]]<br></code></pre></td></tr></table></figure><p>Click : [3,0]</p><p>Output: </p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[[<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;M</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;]]<br></code></pre></td></tr></table></figure><p>Explanation:<br><img src="https://assets.leetcode.com/uploads/2023/08/09/untitled.jpeg" alt="Example 1"></p><p>Example 2:<br>Input: </p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[[<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;M</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;]]<br></code></pre></td></tr></table></figure><p>Click : [1,2]</p><p>Output: </p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[[<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;E</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;X</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;1</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;],<br> [<span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;, <span class="hljs-symbol">&#x27;B</span>&#x27;]]<br></code></pre></td></tr></table></figure><p>Explanation:<br><img src="https://assets.leetcode.com/uploads/2023/08/09/untitled-2.jpeg" alt="Example 2"></p><p>Note:<br>The range of the input matrix’s height and width is [1,50].<br>The click position will only be an unrevealed square (‘M’ or ‘E’), which also means the input board contains at least one clickable square.</p><p>The input board won’t be a stage when game is over (some mines have been revealed).</p><p>For simplicity, not mentioned rules should be ignored in this problem. For example, you don’t need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</p><p>扫雷游戏。</p><blockquote>让我们一起来玩扫雷游戏！<p>给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中：</p><p>‘M’ 代表一个 未挖出的 地雷，<br>‘E’ 代表一个 未挖出的 空方块，<br>‘B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，<br>数字（’1’ 到 ‘8’）表示有多少地雷与这块 已挖出的 方块相邻，<br>‘X’ 则表示一个 已挖出的 地雷。<br>给你一个整数数组 click ，其中 click &#x3D; [clickr, clickc] 表示在所有 未挖出的 方块（’M’ 或者 ‘E’）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。</p><p>根据以下规则，返回相应位置被点击后对应的盘面：</p><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’ 。<br>如果一个 没有相邻地雷 的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的 未挖出 方块都应该被递归地揭露。<br>如果一个 至少与一个地雷相邻 的空方块（’E’）被挖出，修改它为数字（’1’ 到 ‘8’ ），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回盘面。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minesweeper">https://leetcode.cn/problems/minesweeper</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>游戏本身我们小时候应该都玩过，我这里提炼以下题目里面的字母和规则吧。</p><p>M - 未发现的雷<br>E - 未发现的空白方块<br>B - 发现的空白方块<br>数字 1 - 8<br>X - 发现了的雷</p><p>这个题我做的时候个人觉得规则解释的不是非常明确，虽然题目说了没有提到的规则可以被忽略（Note 4）。题目给的是二维矩阵 board 和其中的某一个坐标 click。如果当前 click 位置上点开是个雷，把他 mark 成 X，然后直接就返回 board 了。例子二把周围的八个坐标 mark 成了 1，但是如果你只是 mark 了雷而不 mark 那些 1，也是可以的。另外，比如第一个例子，点开的坐标背后是一个B，但是实际题目要求你是递归地遍历完整个 board，这个跟我们小时候玩游戏的时候有一点区别，因为他点一次，直接就要求你把整个 board 的结果返回了。但是雷正上方的那个坐标却依然保持了 E。这个坐标保持E的原因是在于 DFS 遍历的时候先找到了雷所以就直接返回 board 了，还没来得及去看那个坐标。</p><p>回到这道题的解题思路上。既然题目提示了 recursively，那么我们试着用 DFS 做。不过这道题不同于一般的 DFS 题，需要遍历当前坐标周围的八个邻居。</p><p>如果当前坐标是雷，标记成X，立马返回 board<br>如果当前坐标不是雷，遍历其八个邻居，计算一下有几个雷，把雷的数量写在当前坐标上，返回 board<br>如果当前坐标是 blank&#x2F;E，则把当前坐标改成 B，然后递归去看他的八个邻居</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[][] updateBoard(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span>[] click) &#123;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> click[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> click[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;M&#x27;</span> || board[i][j] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>            board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>            <span class="hljs-keyword">return</span> board;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nums</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; board[x][y] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br>                nums++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// mark the number of bombs</span><br>        <span class="hljs-keyword">if</span> (nums &gt; <span class="hljs-number">0</span>) &#123;<br>            board[i][j] = (<span class="hljs-type">char</span>) (nums + <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">return</span> board;<br>        &#125;<br><br>        <span class="hljs-comment">// if no bomb, mark it blank</span><br>        board[i][j] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; board[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>                updateBoard(board, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; x, y &#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 417. Pacific Atlantic Water Flow</title>
    <link href="/posts/30844639.html"/>
    <url>/posts/30844639.html</url>
    
    <content type="html"><![CDATA[<p>There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island’s left and top edges, and the Atlantic Ocean touches the island’s right and bottom edges.</p><p>The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).</p><p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell’s height is less than or equal to the current cell’s height. Water can flow from any cell adjacent to an ocean into the ocean.</p><p>Return a 2D list of grid coordinates result where result[i] &#x3D; [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" alt="Example 1"><br>Input: heights &#x3D; [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]<br>Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]<br>Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:<br>[0,4]: [0,4] -&gt; Pacific Ocean<br>       [0,4] -&gt; Atlantic Ocean<br>[1,3]: [1,3] -&gt; [0,3] -&gt; Pacific Ocean<br>       [1,3] -&gt; [1,4] -&gt; Atlantic Ocean<br>[1,4]: [1,4] -&gt; [1,3] -&gt; [0,3] -&gt; Pacific Ocean<br>       [1,4] -&gt; Atlantic Ocean<br>[2,2]: [2,2] -&gt; [1,2] -&gt; [0,2] -&gt; Pacific Ocean<br>       [2,2] -&gt; [2,3] -&gt; [2,4] -&gt; Atlantic Ocean<br>[3,0]: [3,0] -&gt; Pacific Ocean<br>       [3,0] -&gt; [4,0] -&gt; Atlantic Ocean<br>[3,1]: [3,1] -&gt; [3,0] -&gt; Pacific Ocean<br>       [3,1] -&gt; [4,1] -&gt; Atlantic Ocean<br>[4,0]: [4,0] -&gt; Pacific Ocean<br>       [4,0] -&gt; Atlantic Ocean<br>Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.</p><p>Example 2:<br>Input: heights &#x3D; [[1]]<br>Output: [[0,0]]<br>Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.</p><p>Constraints:<br>m &#x3D;&#x3D; heights.length<br>n &#x3D;&#x3D; heights[r].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; heights[r][c] &lt;&#x3D; 105</p><p>太平洋大西洋水流问题。</p><blockquote>有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。</p><p>岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p><p>返回网格坐标 result 的 2D 列表 ，其中 result[i] &#x3D; [ri, ci] 表示雨水从单元格 (ri, ci) 流动 既可流向太平洋也可流向大西洋 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/pacific-atlantic-water-flow">https://leetcode.cn/problems/pacific-atlantic-water-flow</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个二维矩阵，矩阵里的数字表示水的高度。矩阵的边缘是太平洋和大西洋。水流遵循高处往低处流的原则，求这个矩阵里面哪些坐标上的水能同时流动到太平洋和大西洋。</p><p>这一题也属于 flood fill 类的题目。但是这个题的做法非常巧妙，可以试着从矩阵的边缘往中间找，看看最远能找到矩阵内的哪些坐标。这些被找到的坐标上的水一定能流到两个海洋里。比如左边缘和上边缘是太平洋，就可以找 i &#x3D;&#x3D; 0 和 j &#x3D;&#x3D; 0 的坐标去做 dfs，并记录有哪些坐标能被遍历到。同理，右边缘和下边缘是大西洋，可以找 i &#x3D;&#x3D; m - 1 和 j &#x3D;&#x3D; n - 1 的坐标去做 dfs，并记录哪些坐标能被找到。在两次 dfs 中都被找到的坐标，则是可以同时流向两个大洋的。</p><p>同时这一题在做 dfs 的时候，也跟329题类似，需要记录一个 prev 值，以判断当前坐标上的水的深度和之前遍历的坐标上的水的深度谁高谁低。因为只有高度有区别的两个坐标，才有可能实现水的流动。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">boolean</span>[][] pacific;<br>    <span class="hljs-type">boolean</span>[][] atlantic;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pacificAtlantic</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>        m = heights.length;<br>        n = heights[<span class="hljs-number">0</span>].length;<br>        pacific = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        atlantic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// pacific</span><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>                    dfs(heights, pacific, i, j, heights[i][j]);<br>                &#125;<br><br>                <span class="hljs-comment">// atlantic</span><br>                <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span> || j == n - <span class="hljs-number">1</span>) &#123;<br>                    dfs(heights, atlantic, i, j, heights[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;<br>                    res.add(Arrays.asList(i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights, <span class="hljs-type">boolean</span>[][] ocean, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> prev)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || ocean[i][j] || heights[i][j] &lt; prev) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ocean[i][j] = <span class="hljs-literal">true</span>;<br>        dfs(heights, ocean, i - <span class="hljs-number">1</span>, j, heights[i][j]);<br>        dfs(heights, ocean, i + <span class="hljs-number">1</span>, j, heights[i][j]);<br>        dfs(heights, ocean, i, j - <span class="hljs-number">1</span>, heights[i][j]);<br>        dfs(heights, ocean, i, j + <span class="hljs-number">1</span>, heights[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">329. Longest Increasing Path in a Matrix<br>417. Pacific Atlantic Water Flow<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 329. Longest Increasing Path in a Matrix</title>
    <link href="/posts/1731916655.html"/>
    <url>/posts/1731916655.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.</p><p>From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" alt="Example 1"><br>Input: matrix &#x3D; [[9,9,4],[6,6,8],[2,1,1]]<br>Output: 4<br>Explanation: The longest increasing path is [1, 2, 6, 9].</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" alt="Example 2"><br>Input: matrix &#x3D; [[3,4,5],[3,2,6],[2,2,1]]<br>Output: 4<br>Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p><p>Example 3:<br>Input: matrix &#x3D; [[1]]<br>Output: 1</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 231 - 1</p><p>矩阵中的最长递增路径。</p><blockquote>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix">https://leetcode.cn/problems/longest-increasing-path-in-a-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个二维矩阵，找出最长的递增路径。例子应该很好地解释了什么叫做最长的递增路径。</p><p>这道题也是偏 flood fill 那一类的题。因为路径是连续的且只是往上下左右四个方向，所以需要再创建一个和 matrix 同样 size 的二维数组来记录遍历的结果，否则会超时。二维数组内每个坐标上记录的值的意思是遍历到这个点 (x, y) 能得到的最长路径是多少。</p><p>还是应用 dfs 的模板，但是在设计 dfs 函数的时候记得加一个额外的二维数组记录结果。其余的部分可参见代码。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn) - 额外数组缓存结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        m = matrix.length;<br>        n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (memo[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    res = Math.max(res, dfs(matrix, memo, i, j, Integer.MIN_VALUE));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span>[][] memo, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> prev)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || matrix[i][j] &lt;= prev) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][j];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(matrix, memo, i, j - <span class="hljs-number">1</span>, matrix[i][j]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(matrix, memo, i, j + <span class="hljs-number">1</span>, matrix[i][j]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> dfs(matrix, memo, i - <span class="hljs-number">1</span>, j, matrix[i][j]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> dfs(matrix, memo, i + <span class="hljs-number">1</span>, j, matrix[i][j]);<br>        <span class="hljs-keyword">return</span> memo[i][j] = max(left, right, up, down) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.max(a, Math.max(b, Math.max(c, d)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">329. Longest Increasing Path in a Matrix<br>417. Pacific Atlantic Water Flow<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>memorization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1100. Find K-Length Substrings With No Repeated Characters</title>
    <link href="/posts/36462718.html"/>
    <url>/posts/36462718.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s and an integer k, return the number of substrings in s of length k with no repeated characters.</p><p>Example 1:<br>Input: s &#x3D; “havefunonleetcode”, k &#x3D; 5<br>Output: 6<br>Explanation: There are 6 substrings they are: ‘havef’,’avefu’,’vefun’,’efuno’,’etcod’,’tcode’.</p><p>Example 2:<br>Input: s &#x3D; “home”, k &#x3D; 5<br>Output: 0<br>Explanation: Notice k can be larger than the length of s. In this case, it is not possible to find any substring.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s consists of lowercase English letters.<br>1 &lt;&#x3D; k &lt;&#x3D; 104</p><p>长度为 K 的无重复字符子串。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="滑动窗口模板实现"><a href="#滑动窗口模板实现" class="headerlink" title="滑动窗口模板实现"></a>滑动窗口模板实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numKLenSubstrNoRepeats</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (len &lt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (end &lt; len) &#123;<br>            <span class="hljs-keyword">while</span> (set.contains(s.charAt(end))) &#123;<br>                set.remove(s.charAt(start));<br>                start++;<br>            &#125;<br>            set.add(s.charAt(end));<br>            end++;<br>            <span class="hljs-keyword">if</span> (end - start == k) &#123;<br>                res++;<br>                set.remove(s.charAt(start));<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="固定窗口模板实现"><a href="#固定窗口模板实现" class="headerlink" title="固定窗口模板实现"></a>固定窗口模板实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numKLenSubstrNoRepeats</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s.length() &lt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.size() == k) &#123;<br>            res++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(i - k);<br>            map.put(c2, map.get(c2) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (map.get(c2) == <span class="hljs-number">0</span>) &#123;<br>                map.remove(c2);<br>            &#125;<br>            map.put(c1, map.getOrDefault(c1, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (map.size() == k) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// sliding window with fixed size</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sliding window</tag>
      
      <tag>sliding window with fixed size</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 904. Fruit Into Baskets</title>
    <link href="/posts/3089028489.html"/>
    <url>/posts/3089028489.html</url>
    
    <content type="html"><![CDATA[<p>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.</p><p>You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:</p><p>You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.</p><p>Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</p><p>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</p><p>Given the integer array fruits, return the maximum number of fruits you can pick.</p><p>Example 1:<br>Input: fruits &#x3D; [1,2,1]<br>Output: 3<br>Explanation: We can pick from all 3 trees.</p><p>Example 2:<br>Input: fruits &#x3D; [0,1,2,2]<br>Output: 3<br>Explanation: We can pick from trees [1,2,2].<br>If we had started at the first tree, we would only pick from trees [0,1].</p><p>Example 3:<br>Input: fruits &#x3D; [1,2,3,2,2]<br>Output: 4<br>Explanation: We can pick from trees [2,3,2,2].<br>If we had started at the first tree, we would only pick from trees [1,2].</p><p>Constraints:<br>1 &lt;&#x3D; fruits.length &lt;&#x3D; 105<br>0 &lt;&#x3D; fruits[i] &lt; fruits.length</p><p>水果成篮。</p><blockquote><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/fruit-into-baskets">https://leetcode.cn/problems/fruit-into-baskets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的糖衣写的很模糊，讲的直白一点，这个题是给你一个数组，数组代表一排树，每个坐标上的值 tree[i] 代表树的类型，而不是树上果子的数量。只允许你收集两种树上的果子，每棵树上你只能拿一个果子，请问你最多能收集多少果子。所以实际问的是只能收集两种果子的情况下（只能有两种不同元素的情况下），如何能使你收集的这个子数组最长。返回的是能收集的最长的长度。因为这个数组的长度越长，能收集到的果子越多。比如例子三，[1,2,3,2,2]，收集的是 2 和 3 两种果子，组成的最长子串的长度是 4。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">totalFruit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] fruits)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; fruits.length) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> fruits[end];<br>            map.put(cur, map.getOrDefault(cur, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            end++;<br>            <span class="hljs-keyword">while</span> (map.keySet().size() &gt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">typeToRemove</span> <span class="hljs-operator">=</span> fruits[start];<br>                map.put(typeToRemove, map.get(typeToRemove) - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (map.get(typeToRemove) == <span class="hljs-number">0</span>) &#123;<br>                    map.remove(typeToRemove);<br>                &#125;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 785. Is Graph Bipartite</title>
    <link href="/posts/493219567.html"/>
    <url>/posts/493219567.html</url>
    
    <content type="html"><![CDATA[<p>There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:</p><p>There are no self-edges (graph[u] does not contain u).</p><p>There are no parallel edges (graph[u] does not contain duplicate values).</p><p>If v is in graph[u], then u is in graph[v] (the graph is undirected).</p><p>The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.</p><p>A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.</p><p>Return true if and only if it is bipartite.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt="Example 1"><br>Input: graph &#x3D; [[1,2,3],[0,2],[0,1,3],[0,2]]<br>Output: false<br>Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt="Example 2"><br>Input: graph &#x3D; [[1,3],[0,2],[1,3],[0,2]]<br>Output: true<br>Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.</p><p>Constraints:<br>graph.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>0 &lt;&#x3D; graph[u].length &lt; n<br>0 &lt;&#x3D; graph[u][i] &lt;&#x3D; n - 1<br>graph[u] does not contain u.<br>All the values of graph[u] are unique.<br>If graph[u] contains v, then graph[v] contains u.</p><p>判断二分图。</p><blockquote>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：不存在自环（graph[u] 不包含 u）。不存在平行边（graph[u] 不包含重复值）。如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。<p>如果图是二分图，返回 true ；否则，返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/is-graph-bipartite">https://leetcode.cn/problems/is-graph-bipartite</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是涂色法，只是涂色的方式不同。涂色法大致的思路是，当你遍历 graph 里面的节点的时候，当遇到某一个节点，如果他没有被染色，你就试图给他染成某一种颜色，但是对于这个点的所有邻居节点，需要给他们染成一个别的颜色以区分开。照着这个思路，你需要确保邻居节点被染成不同的颜色。如果遍历结束，所有节点都被染色成功，则说明是一个二分图；如果在染色过程中发现有节点已经被染色但是染色错误，则这个图不是二分图。这里我提供 BFS 和 DFS 两种实现。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(V+E) - V是节点数，E是边数<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="BFS实现"><a href="#BFS实现" class="headerlink" title="BFS实现"></a>BFS实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-type">int</span>[] color = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (graph[i].length != <span class="hljs-number">0</span> &amp;&amp; color[i] == <span class="hljs-number">0</span>) &#123;<br>                color[i] = <span class="hljs-number">1</span>;<br>                Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>                queue.offer(i);<br>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nei : graph[cur]) &#123;<br>                        <span class="hljs-keyword">if</span> (color[nei] == <span class="hljs-number">0</span>) &#123;<br>                            color[nei] = color[cur] == <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>                            queue.offer(nei);<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[nei] == color[cur]) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS实现"><a href="#DFS实现" class="headerlink" title="DFS实现"></a>DFS实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBipartite</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-type">int</span>[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (colors[i] == <span class="hljs-number">0</span> &amp;&amp; !dfs(graph, colors, i, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span>[] colors, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> color)</span> &#123;<br>        colors[node] = color;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nei : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (colors[nei] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!dfs(graph, colors, nei, -color)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colors[nei] == color) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">785. Is Graph Bipartite<br>886. Possible Bipartition<br>1129. Shortest Path with Alternating Colors<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1512. Number of Good Pairs</title>
    <link href="/posts/3395820766.html"/>
    <url>/posts/3395820766.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums, return the number of good pairs.</p><p>A pair (i, j) is called good if nums[i] &#x3D;&#x3D; nums[j] and i &lt; j.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,1,1,3]<br>Output: 4<br>Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.</p><p>Example 2:<br>Input: nums &#x3D; [1,1,1,1]<br>Output: 6<br>Explanation: Each pair in the array are good.</p><p>Example 3:<br>Input: nums &#x3D; [1,2,3]<br>Output: 0</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><p>好数对的数目。</p><blockquote>给你一个整数数组 nums 。<p>如果一组数字 (i,j) 满足 nums[i] &#x3D;&#x3D; nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p><p>返回好数对的数目。</p></blockquote><h2 id="思路一-暴力解"><a href="#思路一-暴力解" class="headerlink" title="思路一 - 暴力解"></a>思路一 - 暴力解</h2><p>暴力解很好想，就是类似于 two sum 一样的两层 for 循环。由于数据量不是很大，这个思路是不超时的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == nums[j]) &#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-hashmap"><a href="#思路二-hashmap" class="headerlink" title="思路二 - hashmap"></a>思路二 - hashmap</h2><p>优化的思路是用 hashmap。每遇到一个数字，先去 hashmap 里看他是否存在，如果存在，拿到存在的次数，比如某个数字 X 之前 2 次，那么当我们第 3 次遇到他的时候，就往结果累加 2，因为当前这个 X 可以和之前两次 X 分别配对。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.getOrDefault(num, <span class="hljs-number">0</span>);<br>            res += count;<br>            map.put(num, count + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 430. Flatten a Multilevel Doubly Linked List</title>
    <link href="/posts/2281211084.html"/>
    <url>/posts/2281211084.html</url>
    
    <content type="html"><![CDATA[<p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.</p><p>Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.</p><p>Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<br>Output: [1,2,3,7,8,11,12,9,10,4,5,6]<br>Explanation: The multilevel linked list in the input is shown.<br>After flattening the multilevel linked list it becomes:<br><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg" alt="Example 1"></p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg" alt="Example 2"><br>Input: head &#x3D; [1,2,null,3]<br>Output: [1,3,2]<br>Explanation: The multilevel linked list in the input is shown.<br>After flattening the multilevel linked list it becomes:<br><img src="https://assets.leetcode.com/uploads/2021/11/24/list.jpg" alt="Example 2"></p><p>Example 3:<br>Input: head &#x3D; []<br>Output: []<br>Explanation: There could be empty list in the input.</p><p>Constraints:<br>The number of Nodes will not exceed 1000.<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">How the multilevel linked list is represented in test cases:<br>We use the multilevel linked list from Example 1 above:<br> 1---2---3---4---5---6--NULL<br>         |<br>         7---8---9---10--NULL<br>             |<br>             11--12--NULL<br>The serialization of each level is as follows:<br>[1,2,3,4,5,6,null]<br>[7,8,9,10,null]<br>[11,12,null]<br>To serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:<br>[1,    2,    3, 4, 5, 6, null]<br>             |<br>[null, null, 7,    8, 9, 10, null]<br>                   |<br>[            null, 11, 12, null]<br>Merging the serialization of each level and removing trailing nulls we obtain:<br>[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<br></code></pre></td></tr></table></figure><p>扁平化多级双向链表。</p><blockquote><p>你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 子指针 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 多层数据结构 。</p><p>给定链表的头节点 head ，将链表 扁平化 ，以便所有节点都出现在单层双链表中。让 curr 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 curr 之后 和 curr.next 之前 。</p><p>返回 扁平列表的 head 。列表中的节点必须将其 所有 子指针设置为 null 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list">https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是请你将这个多维的链表转化成一个一维的链表。</p><p>我参考了<a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/discuss/150321/Easy-Understanding-Java-beat-95.7-with-Explanation">discussion的最高票答案</a>，无需额外空间。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node prev;</span><br><span class="hljs-comment">    public Node next;</span><br><span class="hljs-comment">    public Node child;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">flatten</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        dfs(head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-keyword">if</span> (cur.child != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 拿到child的尾结点</span><br>                <span class="hljs-type">Node</span> <span class="hljs-variable">childTail</span> <span class="hljs-operator">=</span> dfs(cur.child);<br>                cur.next = cur.child;<br>                cur.child.prev = cur;<br>                cur.child = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果有下一个节点，则把下一个节点接到child的尾结点上</span><br>                <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>                    childTail.next = next;<br>                    next.prev = childTail;<br>                &#125;<br>                last = childTail;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果没有 child，则当前节点就是当前链表的最后节点</span><br>                last = cur;<br>            &#125;<br>            <span class="hljs-comment">// 继续处理下一个节点（注意：如果有 child，则 current.next 已经被修改）</span><br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">114. Flatten Binary Tree to Linked List<br>430. Flatten a Multilevel Doubly Linked List<br>897. Increasing Order Search Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 763. Partition Labels</title>
    <link href="/posts/3622449764.html"/>
    <url>/posts/3622449764.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p><p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</p><p>Return a list of integers representing the size of these parts.</p><p>Example 1:<br>Input: s &#x3D; “ababcbacadefegdehijhklij”<br>Output: [9,7,8]<br>Explanation:<br>The partition is “ababcbaca”, “defegde”, “hijhklij”.<br>This is a partition so that each letter appears in at most one part.<br>A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits s into less parts.</p><p>Example 2:<br>Input: s &#x3D; “eccbbbbdec”<br>Output: [10]</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 500<br>s consists of lowercase English letters.</p><p>划分字母区间。</p><blockquote>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/partition-labels">https://leetcode.cn/problems/partition-labels</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是贪心 + 双指针。首先遍历一次字符串，将每个字符最后一次出现的 index 记录下来。再遍历一次字符串，这一次需要用到两个指针，start 指针一开始在字符串的起始部位，end 指针一点点随着 i 指针往后走，每次看到一个字母，end 就更新为当前遍历到的所有字母中间的最后一个出现的位置。如果在某一个 i 发现这是当前字母最后一次出现的位置，则说明当前 i 位置上这个字母之后再也不可能遇到，可以开始分割 input 了，(start, i)，然后下一个分段则是从 i + 1 开始。</p><p>这里我引用<a href="https://leetcode.cn/problems/partition-labels/solution/763-hua-fen-zi-mu-qu-jian-ji-lu-zui-yuan-wei-zhi-y/">一个截图</a>以帮助理解。我们用 end 指针扫描字符串的时候，比如一开始的 a，我们根据 last 数组可知最后一次出现 a 的下标是 8，我们就可以将 end 指针更新到 8 的位置。如果在下标 1 - 8 之间有其他字母的最后一次出现位置的下标 &gt; 8 的话，我们还需要再更新 end 指针的位置，这样才能确保 start - end 之间所有的字母在同一个被分割的片段里。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            end = Math.max(end, map[c - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                res.add(end - start + <span class="hljs-number">1</span>);<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1503. Last Moment Before All Ants Fall Out of a Plank</title>
    <link href="/posts/2043097135.html"/>
    <url>/posts/2043097135.html</url>
    
    <content type="html"><![CDATA[<p>We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with speed 1 unit per second. Some of the ants move to the left, the other move to the right.</p><p>When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions doesn’t take any additional time.</p><p>When an ant reaches one end of the plank at a time t, it falls out of the plank imediately.</p><p>Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right. Return the moment when the last ant(s) fall out of the plank.</p><p>Example 1:<br>Input: n &#x3D; 4, left &#x3D; [4,3], right &#x3D; [0,1]<br>Output: 4<br>Explanation: In the image above:<br>-The ant at index 0 is named A and going to the right.<br>-The ant at index 1 is named B and going to the right.<br>-The ant at index 3 is named C and going to the left.<br>-The ant at index 4 is named D and going to the left.<br>Note that the last moment when an ant was on the plank is t &#x3D; 4 second, after that it falls imediately out of the plank. (i.e. We can say that at t &#x3D; 4.0000000001, there is no ants on the plank).</p><p>Example 2:<br>Input: n &#x3D; 7, left &#x3D; [], right &#x3D; [0,1,2,3,4,5,6,7]<br>Output: 7<br>Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.</p><p>Example 3:<br>Input: n &#x3D; 7, left &#x3D; [0,1,2,3,4,5,6,7], right &#x3D; []<br>Output: 7<br>Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.</p><p>Example 4:<br>Input: n &#x3D; 9, left &#x3D; [5], right &#x3D; [4]<br>Output: 5<br>Explanation: At t &#x3D; 1 second, both ants will be at the same intial position but with different direction.</p><p>Example 5:<br>Input: n &#x3D; 6, left &#x3D; [6], right &#x3D; [0]<br>Output: 6</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 10^4<br>0 &lt;&#x3D; left.length &lt;&#x3D; n + 1<br>0 &lt;&#x3D; left[i] &lt;&#x3D; n<br>0 &lt;&#x3D; right.length &lt;&#x3D; n + 1<br>0 &lt;&#x3D; right[i] &lt;&#x3D; n<br>1 &lt;&#x3D; left.length + right.length &lt;&#x3D; n + 1<br>All values of left and right are unique, and each value can appear only in one of the two arrays.</p><p>所有蚂蚁掉下来前的最后一刻。</p><blockquote><p>有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。<br>当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。<br>而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。<br>给你一个整数 n 和两个整数数组 left 以及 right 。两个数组分别标识向左或者向右移动的蚂蚁在 t &#x3D; 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是问蚂蚁最多需要多长时间才能完全离开面板。如果你想通了，思路很简单。题意规定当蚂蚁相遇的时候，两只蚂蚁需要向各自相反方向走，这个规则乍一看其实会让你感觉是不是会增加一个蚂蚁离开面板的时间，其实是不会的，题目也是这样说的。当两只蚂蚁 a 和 b 相遇，你可以将 a 和 b 相互调换一下位置，相当于是两者直接各自擦肩而过了。LeetCode 中还有几道题也用到这个思想，很有用。</p><p>知道这个结论之后，这道题瞬间就变成了<code>所有向左走的蚂蚁中最右边的那一只从木板上掉下来的时刻</code>和<code>所有向右走的蚂蚁中最左边的那一只从木板上掉下来的时刻</code>的较大值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLastMoment</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right)</span> &#123;<br>Arrays.sort(left);<br>Arrays.sort(right);<br><span class="hljs-keyword">if</span> (left.length == <span class="hljs-number">0</span> &amp;&amp; right.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (left.length == <span class="hljs-number">0</span> &amp;&amp; right.length != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> n - right[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (left.length != <span class="hljs-number">0</span> &amp;&amp; right.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> left[left.length - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> Math.max(left[left.length - <span class="hljs-number">1</span>], n - right[<span class="hljs-number">0</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">left</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">right</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getLastMoment = <span class="hljs-keyword">function</span> (<span class="hljs-params">n, left, right</span>) &#123;<br>left.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>right.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(left);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(right);<br><span class="hljs-keyword">if</span> (!left.<span class="hljs-property">length</span> &amp;&amp; !right.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!left.<span class="hljs-property">length</span> &amp;&amp; right.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">return</span> n - right[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (left.<span class="hljs-property">length</span> &amp;&amp; !right.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">return</span> left[left.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left[left.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>], n - right[<span class="hljs-number">0</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>brainteaser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 271. Encode and Decode Strings</title>
    <link href="/posts/2813401652.html"/>
    <url>/posts/2813401652.html</url>
    
    <content type="html"><![CDATA[<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p><p>Machine 1 (sender) has the function:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">string</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">vector&lt;<span class="hljs-built_in">string</span>&gt; strs</span>) &#123;<br>  <span class="hljs-comment">// ... your code</span><br>  <span class="hljs-keyword">return</span> encoded_string;<br>&#125;<br><span class="hljs-title class_">Machine</span> <span class="hljs-number">2</span> (receiver) has the <span class="hljs-attr">function</span>:<br>vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title function_">decode</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>) &#123;<br>  <span class="hljs-comment">//... your code</span><br>  <span class="hljs-keyword">return</span> strs;<br>&#125;<br></code></pre></td></tr></table></figure><p>So Machine 1 does:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">string encoded_string <span class="hljs-operator">=</span> encode(strs)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>and Machine 2 does:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">vector&lt;string&gt; strs2 <span class="hljs-operator">=</span> decode(encoded_string)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>strs2 in Machine 2 should be the same as strs in Machine 1.</p><p>Implement the encode and decode methods.</p><p>You are not allowed to solve the problem using any serialize methods (such as eval).</p><p>Example 1:<br>Input: dummy_input &#x3D; [“Hello”,”World”]<br>Output: [“Hello”,”World”]<br>Explanation:<br>Machine 1:<br>Codec encoder &#x3D; new Codec();<br>String msg &#x3D; encoder.encode(strs);<br>Machine 1 —msg—&gt; Machine 2</p><p>Machine 2:<br>Codec decoder &#x3D; new Codec();<br>String[] strs &#x3D; decoder.decode(msg);</p><p>Example 2:<br>Input: dummy_input &#x3D; [“”]<br>Output: [“”]</p><p>Constraints:<br>1 &lt;&#x3D; strs.length &lt;&#x3D; 200<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200<br>strs[i] contains any possible characters out of 256 valid ASCII characters.</p><p>Follow up: Could you write a generalized algorithm to work on any possible set of characters?</p><p>字符串的编码与解码。</p><blockquote><p>请你设计一个算法，可以将一个 字符串列表 编码成为一个 字符串。这个编码后的字符串是可以通过网络进行高效传送的，并且可以在接收端被解码回原来的字符串列表。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于 input 给的字符串列表，我们可以把他压缩成这种形式</p><blockquote><p>单词长度size + ‘,’ + 单词</p></blockquote><p>那么对于一个单词列表 [hello, world, hello, world] 而言，他将会被压缩成这个样子。</p><blockquote><p>5,hello5,world5,hello5,world</p></blockquote><p>所以当我们试着再把这个字符串变回 字符串列表 的时候，我们可以用 string.indexOf(‘,’) 找到每一个逗号的位置，找到逗号之后，当前位置到逗号 [i, comma) 就是单词的长度 size，[comma + 1, comma + 1 + size) 则是单词本身。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><br>    <span class="hljs-comment">// Encodes a list of strings to a single string.</span><br>    <span class="hljs-comment">// hello,world,hello,world</span><br>    <span class="hljs-comment">// 5,hello5,world5,hello5,world</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">encode</span><span class="hljs-params">(List&lt;<span class="hljs-type">String</span>&gt; strs)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> <span class="hljs-type">word</span> : strs) &#123;<br>            <span class="hljs-type">int</span> size = <span class="hljs-type">word</span>.<span class="hljs-built_in">length</span>();<br>            sb.<span class="hljs-built_in">append</span>(size).<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-built_in">append</span>(<span class="hljs-type">word</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes a single string to a list of strings.</span><br>    <span class="hljs-comment">// hello,world,hello,world</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-title">decode</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        List&lt;<span class="hljs-type">String</span>&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-type">int</span> comma = s.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;,&#x27;</span>, i);<br>            <span class="hljs-type">int</span> size = Integer.<span class="hljs-built_in">valueOf</span>(s.<span class="hljs-built_in">substring</span>(i, comma));<br>            res.<span class="hljs-built_in">add</span>(s.<span class="hljs-built_in">substring</span>(comma + <span class="hljs-number">1</span>, comma + <span class="hljs-number">1</span> + size));<br>            i = comma + <span class="hljs-number">1</span> + size;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec = new Codec();</span><br><span class="hljs-comment">// codec.decode(codec.encode(strs));</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Encodes a list of strings to a single string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;string[]&#125; strs</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;string&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> encode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(strs)</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> sb = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> str of strs) &#123;<br>        sb.push(str.length);<br>        sb.push(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        sb.push(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decodes a single string to a list of strings.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;string&#125; s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;string[]&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> decode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(s)</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; s.length) &#123;<br>        <span class="hljs-keyword">let</span> slash = s.indexOf(<span class="hljs-string">&#x27;/&#x27;</span>, i);<br>        <span class="hljs-keyword">let</span> len = parseInt(s.substring(i, slash));<br>        <span class="hljs-keyword">let</span> str = s.substring(slash + <span class="hljs-number">1</span>, slash + <span class="hljs-number">1</span> + len);<br>        res.push(str);<br>        i = slash + <span class="hljs-number">1</span> + len;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your functions will be called as such:</span><br><span class="hljs-comment"> * decode(encode(strs));</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">38. Count and Say<br>271. Encode and Decode Strings<br>443. String Compression<br>604. Design Compressed String Iterator<br>1313. Decompress Run-Length Encoded List<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>string</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 38. Count and Say</title>
    <link href="/posts/2946513692.html"/>
    <url>/posts/2946513692.html</url>
    
    <content type="html"><![CDATA[<p>The count-and-say sequence is a sequence of digit strings defined by the recursive formula:<br>countAndSay(1) &#x3D; “1”<br>countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.<br>To determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.</p><p>For example, the saying and conversion for digit string “3322251”:<br>Given a positive integer n, return the nth term of the count-and-say sequence.</p><p>Example 1:<br>Input: n &#x3D; 1<br>Output: “1”<br>Explanation: This is the base case.</p><p>Example 2:<br>Input: n &#x3D; 4<br>Output: “1211”<br>Explanation:<br>countAndSay(1) &#x3D; “1”<br>countAndSay(2) &#x3D; say “1” &#x3D; one 1 &#x3D; “11”<br>countAndSay(3) &#x3D; say “11” &#x3D; two 1’s &#x3D; “21”<br>countAndSay(4) &#x3D; say “21” &#x3D; one 2 + one 1 &#x3D; “12” + “11” &#x3D; “1211”</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 30</p><p>外观数列。</p><blockquote>给定一个正整数 n ，输出外观数列的第 n 项。「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。你可以将其视作是由递归公式定义的数字字符串序列：countAndSay(1) = "1"countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。前五项如下：1.     12.     113.     214.     12115.     111221第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。<p>例如，数字字符串 “3322251” 的描述如下图：</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-and-say">https://leetcode-cn.com/problems/count-and-say</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是按规则模拟&#x2F;打表。<br>题目给的例子其实不太对，因为题目中规定了 n 最多到 30，例子给的 3322251 只是演示一下读这个数字的规则。</p><p>题目的定义是 countAndSay(n) 是对 countAndSay(n - 1) 的描述，所以我们可以从 1 开始一直遍历到 n，看看这个描述到底是什么。首先第一个数字一定是 1，所以可以先用一个变量 res 记录下来，然后之后的数字都依据遍历第一个数字的结果来记录。直接看代码应该可以懂。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - 因为 N 的范围只到 30，所以只要算 30 次即可<br>空间O(n) - 用了一个stringbuilder记录中间结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (pos &lt; str.length()) &#123;<br><span class="hljs-keyword">while</span> (pos &lt; str.length() &amp;&amp; str.charAt(pos) == str.charAt(start)) &#123;<br>pos++;<br>&#125;<br>sb.append(Integer.toString(pos - start)).append(str.charAt(start));<br>start = pos;<br>&#125;<br>str = sb.toString();<br>&#125;<br><span class="hljs-keyword">return</span> str;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">38.</span> <span class="hljs-built_in">Count</span> <span class="hljs-variable">and</span> <span class="hljs-variable">Say</span><br><span class="hljs-number">271.</span> <span class="hljs-built_in">Encode</span> <span class="hljs-variable">and</span> <span class="hljs-variable">Decode</span> <span class="hljs-variable">Strings</span><br><span class="hljs-number">443.</span> <span class="hljs-built_in">String</span> <span class="hljs-variable">Compression</span><br><span class="hljs-number">604.</span> <span class="hljs-variable">Design</span> <span class="hljs-variable">Compressed</span> <span class="hljs-built_in">String</span> <span class="hljs-variable">Iterator</span><br><span class="hljs-number">1313.</span> <span class="hljs-variable">Decompress</span> <span class="hljs-built_in">Run</span><span class="hljs-operator">-</span><span class="hljs-built_in">Length</span> <span class="hljs-variable">Encoded</span> <span class="hljs-built_in">List</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 332. Reconstruct Itinerary</title>
    <link href="/posts/562898964.html"/>
    <url>/posts/562898964.html</url>
    
    <content type="html"><![CDATA[<p>You are given a list of airline tickets where tickets[i] &#x3D; [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p><p>All of the tickets belong to a man who departs from “JFK”, thus, the itinerary must begin with “JFK”. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p><p>For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="Example 1"><br>Input: tickets &#x3D; [[“MUC”,”LHR”],[“JFK”,”MUC”],[“SFO”,”SJC”],[“LHR”,”SFO”]]<br>Output: [“JFK”,”MUC”,”LHR”,”SFO”,”SJC”]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" alt="Example 2"><br>Input: tickets &#x3D; [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>Output: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>Explanation: Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”] but it is larger in lexical order.</p><p>Constraints:<br>1 &lt;&#x3D; tickets.length &lt;&#x3D; 300<br>tickets[i].length &#x3D;&#x3D; 2<br>fromi.length &#x3D;&#x3D; 3<br>toi.length &#x3D;&#x3D; 3<br>fromi and toi consist of uppercase English letters.<br>fromi !&#x3D; toi</p><p>重新安排行程。</p><blockquote><p>给你一份航线列表 tickets ，其中 tickets[i] &#x3D; [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><p>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p><p>例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。<br>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/reconstruct-itinerary">https://leetcode.cn/problems/reconstruct-itinerary</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 DFS。这是一个图论的问题，首先要做的是把图建起来，会用到 hashmap 创建邻接表。同时因为题目要求按字符自然排序返回最小的行程组合，所以会需要用到 priority queue 来帮助排序，这样字典序最小的下一个地点会在堆顶。建图的时候需要遍历 tickets，把出发地 from 当做 key 存入 hashmap，把所有的目的地 to 存入 pq。接着再用 dfs，从始发地 JFK 去遍历，遍历的时候，先从 pq 里弹出下一个目的地，然后再递归找目的地的目的地。递归完成之后将地点放入 stack。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Map&lt;String, PriorityQueue&lt;String&gt;&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        buildGraph(tickets, g);<br>        Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        dfs(g, stack, <span class="hljs-string">&quot;JFK&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            res.add(stack.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildGraph</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets, Map&lt;String, PriorityQueue&lt;String&gt;&gt; g)</span> &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> ticket.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> ticket.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!g.containsKey(from)) &#123;<br>                g.put(from, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;());<br>            &#125;<br>            g.get(from).offer(to);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Map&lt;String, PriorityQueue&lt;String&gt;&gt; g, Deque&lt;String&gt; stack, String from)</span> &#123;<br>        PriorityQueue&lt;String&gt; arrivals = g.get(from);<br>        <span class="hljs-keyword">while</span> (arrivals != <span class="hljs-literal">null</span> &amp;&amp; !arrivals.isEmpty()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> arrivals.poll();<br>            dfs(g, stack, to);<br>        &#125;<br>        stack.push(from);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>graph</tag>
      
      <tag>topological sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 279. Perfect Squares</title>
    <link href="/posts/2932573575.html"/>
    <url>/posts/2932573575.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer n, return the least number of perfect square numbers that sum to n.</p><p>A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.</p><p>Example 1:<br>Input: n &#x3D; 12<br>Output: 3<br>Explanation: 12 &#x3D; 4 + 4 + 4.</p><p>Example 2:<br>Input: n &#x3D; 13<br>Output: 2<br>Explanation: 13 &#x3D; 4 + 9.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 104</p><p>完全平方数。</p><blockquote><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/perfect-squares">https://leetcode.cn/problems/perfect-squares</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数字 N，请你返回最少的需要几个<strong>完全平方数</strong>的加和的个数。比如第一个例子，12 是由三个 4 组成，4 也是完全平方数。</p><p>思路是动态规划。首先说一下暴力解，这个题的暴力解是从 1 到 N 一个个看这个数字本身是否是一个完全平方数，如果 N 本身就是完全平方数，那么结果自然是 1；如果 N 不是完全平方数，那么可以试着从 1 开始，用 N 减去每个数的平方，看看需要几个完全平方数才能得到 N。举个例子，比如找 15 好了，第一个完全平方数是 1，需要 15 个 1；第二个完全平方数是 4，需要 3 个 4 + 3 个 1 &#x3D; 一共 6 个数字。</p><p>其实动态规划的思路是从暴力解延伸出来的，只是我们用了一个额外的数组记录了之前的结果。首先创建一个长度为 N + 1 的数组记录 dp 的结果，并且 dp[0] &#x3D; 1。从 i &#x3D; 1 开始，一直遍历到 N。当遇到一个新的数字 N 的时候，需要再次从 1 开始遍历，看看当前的这个数字 i 是否整体或者部分能被某一个更小的数的平方代替。比如遍历到 7 的时候，我们发现 7 是可以被一个 2 的平方和三个 1 的平方代替的，所以 DP 的转移方程是</p><blockquote><p>dp[i] &#x3D; Math.min(dp[i], dp[i - j * j] + 1);</p></blockquote><p>这里j的范围是[1, i)<br>最后返回的是dp[n]</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            dp[i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j * j &lt;= i; j++) &#123;<br>                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numSquares = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br><span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>dp[i] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j++) &#123;<br>dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>math</tag>
      
      <tag>knapsack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1014. Best Sightseeing Pair</title>
    <link href="/posts/2429104856.html"/>
    <url>/posts/2429104856.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.</p><p>The score of a pair (i &lt; j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.</p><p>Return the maximum score of a pair of sightseeing spots.</p><p>Example 1:<br>Input: values &#x3D; [8,1,5,2,6]<br>Output: 11<br>Explanation: i &#x3D; 0, j &#x3D; 2, values[i] + values[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</p><p>Example 2:<br>Input: values &#x3D; [1,2]<br>Output: 2</p><p>Constraints:<br>2 &lt;&#x3D; values.length &lt;&#x3D; 5 * 104<br>1 &lt;&#x3D; values[i] &lt;&#x3D; 1000</p><p>最佳观光组合。</p><blockquote>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。<p>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要我们求的是 <code>values[i] + values[j] + i - j</code> 的最大值，可以试着稍微转变一下，实际求的是 <code>values[i] + i + values[j] - j</code> 的最大值。<code>values[i] + i</code> 的部分，可以把他视作一个整体，只要找这个整体的最大值就好了；但是对于这个部分，<code>values[j] - j</code>，因为题目要求 i 要小于 j，所以 j 的范围只能从 1 开始，可以在得到当前 <code>values[i] + i</code> 的最大值之后，再累加上去，看看整体的最大值是多少。</p><p>这个题有点像买卖股票那一类的题，要找的 i 一定要在 j 的左边。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxScoreSightseeingPair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values)</span> &#123;<br>        <span class="hljs-comment">// values[i] + values[j] + i - j = values[i] + i + values[j] - j</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> values.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> values[<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> leftMax + values[j] - j;<br>            res = Math.max(res, sum);<br>            leftMax = Math.max(leftMax, values[j] + j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 787. Cheapest Flights Within K Stops</title>
    <link href="/posts/498273672.html"/>
    <url>/posts/498273672.html</url>
    
    <content type="html"><![CDATA[<p>There are n cities connected by some number of flights. You are given an array flights where flights[i] &#x3D; [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.</p><p>You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-3drawio.png" alt="Example 1"><br>Input: n &#x3D; 4, flights &#x3D; [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src &#x3D; 0, dst &#x3D; 3, k &#x3D; 1<br>Output: 700<br>Explanation:<br>The graph is shown above.<br>The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 &#x3D; 700.<br>Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-1drawio.png" alt="Example 2"><br>Input: n &#x3D; 3, flights &#x3D; [[0,1,100],[1,2,100],[0,2,500]], src &#x3D; 0, dst &#x3D; 2, k &#x3D; 1<br>Output: 200<br>Explanation:<br>The graph is shown above.<br>The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 &#x3D; 200.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-stops-2drawio.png" alt="Example 3"><br>Input: n &#x3D; 3, flights &#x3D; [[0,1,100],[1,2,100],[0,2,500]], src &#x3D; 0, dst &#x3D; 2, k &#x3D; 0<br>Output: 500<br>Explanation:<br>The graph is shown above.<br>The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>0 &lt;&#x3D; flights.length &lt;&#x3D; (n * (n - 1) &#x2F; 2)<br>flights[i].length &#x3D;&#x3D; 3<br>0 &lt;&#x3D; fromi, toi &lt; n<br>fromi !&#x3D; toi<br>1 &lt;&#x3D; pricei &lt;&#x3D; 104<br>There will not be any multiple flights between two cities.<br>0 &lt;&#x3D; src, dst, k &lt; n<br>src !&#x3D; dst</p><p>K 站中转内最便宜的航班。</p><blockquote><p>有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] &#x3D; [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。</p><p>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/cheapest-flights-within-k-stops">https://leetcode.cn/problems/cheapest-flights-within-k-stops</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-dijkstra-超时"><a href="#思路一-dijkstra-超时" class="headerlink" title="思路一 - dijkstra, 超时"></a>思路一 - dijkstra, 超时</h2><p>这个思路对，但是现在会超时。</p><p>大致思路是 dijkstra 算法。首先创建一个邻接矩阵，记录每两个城市之间的 price。然后创建一个关于 price 的最小堆，把（目前所花费的cost，下一个要去到的城市，剩余步数）放入这个最小堆，同时一开始的时候放入的初始值是（0, 起点city, K + 1）。这样遍历的时候，每次从最小堆 pop 出来一个元素，查看这个元素的下一个遍历到的 city 是否是最终的 dst，如果是，则返回 price；如果不是，同时剩余步数 &gt; 0 的话，则遍历邻接表里面所有跟当前这个 city 有连通的部分，加入最小堆。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] f : flights) &#123;<br>            g[f[<span class="hljs-number">0</span>]][f[<span class="hljs-number">1</span>]] = f[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// &lt;price, source, stop&gt;</span><br>        <span class="hljs-comment">// 因为K是允许中转的次数所以实际可以遍历到K + 1个城市</span><br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">0</span>, src, K + <span class="hljs-number">1</span> &#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">remainStops</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (city == dst) &#123;<br>                <span class="hljs-keyword">return</span> price;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (remainStops &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                    <span class="hljs-keyword">if</span> (g[city][i] != <span class="hljs-number">0</span>) &#123;<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; price + g[city][i], i, remainStops - <span class="hljs-number">1</span> &#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-Dijkstra-剪枝"><a href="#思路二-Dijkstra-剪枝" class="headerlink" title="思路二 - Dijkstra + 剪枝"></a>思路二 - Dijkstra + 剪枝</h2><p>二刷我再提供一个不会超时的 BFS 的思路。既然是超时那么一定需要剪枝。我们思考一下对什么情况是可以剪枝的。我们可以创建一个额外的数组，记录走到每个 city 的 cost 是多少。我们还是正常创建图和做 BFS 遍历。当我们发现一条路径 from - to 的时候，我们看一下 to 这个城市是否已经被访问过，如果被访问过，看一下他之前记录的 cost 是多少，如果目前的 cost 大于之前记录的 cost，或者目前的 cost 甚至都大于走到 dst 的 cost 了，则不需要再看了，这条路径一定不是最优解。这个思路就相当于是在满足只能经过 k 个城市的同时，我们要看一下经过这 k 个城市的代价是多少，比如如果有任何一个方案走到某个中间城市的代价大于之前的方案的话，则当前这个方案就不需要再看了。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(V + E)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 建立邻接表</span><br>        <span class="hljs-type">int</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] flight : flights) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> flight[<span class="hljs-number">2</span>];<br>            g[from][to] = cost;<br>        &#125;<br><br>        <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(res, Integer.MAX_VALUE);<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; src, <span class="hljs-number">0</span> &#125;);<br>        <span class="hljs-comment">// 经过K个站点 = 经过K + 1条边</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k + <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span>[] cur = queue.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">to</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; to &lt; n; to++) &#123;<br>                    <span class="hljs-keyword">if</span> (g[from][to] != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">newCost</span> <span class="hljs-operator">=</span> cost + g[from][to];<br>                        <span class="hljs-keyword">if</span> (newCost &lt; res[to] &amp;&amp; newCost &lt; res[dst]) &#123;<br>                            res[to] = newCost;<br>                            <span class="hljs-keyword">if</span> (to != dst) &#123;<br>                                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; to, newCost &#125;);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[dst] == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : res[dst];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>heap</tag>
      
      <tag>graph</tag>
      
      <tag>dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 392. Is Subsequence</title>
    <link href="/posts/2699056563.html"/>
    <url>/posts/2699056563.html</url>
    
    <content type="html"><![CDATA[<p>Given two strings s and t, return true if s is a subsequence of t, or false otherwise.</p><p>A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not).</p><p>Example 1:<br>Input: s &#x3D; “abc”, t &#x3D; “ahbgdc”<br>Output: true</p><p>Example 2:<br>Input: s &#x3D; “axc”, t &#x3D; “ahbgdc”<br>Output: false</p><p>Constraints:<br>0 &lt;&#x3D; s.length &lt;&#x3D; 100<br>0 &lt;&#x3D; t.length &lt;&#x3D; 104<br>s and t consist only of lowercase English letters.<br>Follow up: Suppose there are lots of incoming s, say s1, s2, …, sk where k &gt;&#x3D; 109, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?</p><p>判断子序列。</p><blockquote><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。<br>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。<br>进阶：<br>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？<br>致谢：<br>特别感谢 @pbrother 添加此问题并且创建所有测试用例。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/is-subsequence">https://leetcode.cn/problems/is-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一，双指针"><a href="#思路一，双指针" class="headerlink" title="思路一，双指针"></a>思路一，双指针</h2><p>双指针，一个扫描 s，一个扫描 t。如果碰到同样的字母则两个指针都++，否则只移动 t 的指针。t 扫描完毕之后如果 s 没有到末尾则 return false。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(t.length())<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == s.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二，动态规划"><a href="#思路二，动态规划" class="headerlink" title="思路二，动态规划"></a>思路二，动态规划</h2><p>设 dp[i][j] 为 s 以 i 结尾的子串是否是 t 以 j 结尾的子串的 subsequence。首先 corner case 是当 s 为空的时候，dp[0][j] &#x3D; true。其次开始扫描，如果匹配（s[i] &#x3D;&#x3D; t[j]），则 DP 值跟之前一位的 DP 值相同（dp[i][j] &#x3D;&#x3D; dp[i - 1][j - 1]）；如果不匹配，则 dp[i][j] &#x3D; dp[i][j - 1]。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">sLen</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">tLen</span> <span class="hljs-operator">=</span> t.length();<br><span class="hljs-keyword">if</span> (sLen &gt; tLen) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (sLen == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[sLen + <span class="hljs-number">1</span>][tLen + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tLen; j++) &#123;<br>dp[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// dp</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= sLen; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= tLen; j++) &#123;<br><span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[sLen][tLen];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">392. Is Subsequence<br>524. Longest Word in Dictionary through Deleting<br>720. Longest Word in Dictionary<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>greedy</tag>
      
      <tag>two pointer</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 300. Longest Increasing Subsequence</title>
    <link href="/posts/248222139.html"/>
    <url>/posts/248222139.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return the length of the longest strictly increasing subsequence.</p><p>Example 1:<br>Input: nums &#x3D; [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</p><p>Example 2:<br>Input: nums &#x3D; [0,1,0,3,2,3]<br>Output: 4</p><p>Example 3:<br>Input: nums &#x3D; [7,7,7,7,7,7,7]<br>Output: 1</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?</p><p>最长递增子序列。</p><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-dp"><a href="#思路一-dp" class="headerlink" title="思路一 - dp"></a>思路一 - dp</h2><p>注意子序列 subsequence 和子串 substring 的不同，子序列 subsequence 是可以断开的，只要相对顺序是上升的即可。这个题有两种做法，一是动态规划，一是动态规划基础上的二分。Longest Increasing Subsequence (LIS) 也是一类常考的题型。</p><p>首先是动态规划。设 dp[i] 是以 nums[i] 为结尾的子序列的最大长度。首先初始化的时候，dp 数组的每一个元素都是 1，因为如果以当前元素为结尾，不看其他元素的话，子序列最大长度就是 1。</p><p>更新 dp 数组的方法是用双指针，用一个指针 i 去遍历 input 的时候，同时设置另一个指针 j 扫描 j - i 的范围，如果在 j - i 的范围中有数字 nums[j] &lt; nums[i]，则 dp[i] &#x3D; Math.max(dp[i], dp[j] + 1)</p><p>最后要找的结果是 dp 数组中的最大值。<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/">动图帮助理解</a>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-comment">// 初始化为1，因为每个以nums[i]结尾的子数组的长度都起码是1</span><br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-在dp上的二分查找"><a href="#思路二-在dp上的二分查找" class="headerlink" title="思路二 - 在dp上的二分查找"></a>思路二 - 在dp上的二分查找</h2><p>dp 基础上的二分法。创建一个和 input 等长的 input 数组 dp，这个 dp 数组是我们维护的一个 tails 列表，其中每个元素 tails[k] 的值代表长度为 k + 1 的子序列尾部元素的值。</p><p>把第一个数字放入 dp 数组，从第二个数字开始，用二分法去找到这个数字应该被放入的位置。这里的 dp 数组记录的是实打实的数字，注意最后 dp 数组中的结果可能并不一定是一个正确的子序列，但是长度是对的。</p><p>遍历input，</p><ul><li>如果遇到的数字比 DP 数组里面最大的数字还要大，就加到 DP 数组的末端，len++，这也是唯一扩大 DP 数组 size 的办法</li><li>如果遇到的数字小于 DP 数组中的最大数字，则需要将这个数字通过二分法的方式放到 DP 数组中他该存在的位置，但是只能替换，而不是插入。<ul><li>举个例子，如果你现在有数组[1, 3, 5]，当你遇到一个4的时候，你只有通过把 5 替换成 4，才有可能将数组的最大值变小，从而有机会在数组的最后加入更多的值</li></ul></li></ul><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// dp数组的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 找到第一个大于等于nums[i]的index在哪里</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> helper(dp, index, nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; dp[pos]) &#123;<br>                dp[pos] = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pos &gt; index) &#123;<br>                index++;<br>                dp[index] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (dp[mid] == val) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[mid] &lt; val) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
      <tag>LIS</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 198. House Robber</title>
    <link href="/posts/812805143.html"/>
    <url>/posts/812805143.html</url>
    
    <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).<br>Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</p><p>Example 2:<br>Input: nums &#x3D; [2,7,9,3,1]<br>Output: 12<br>Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).<br>Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p><p>打家劫舍。</p><blockquote>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是动态规划。这是一道动态规划的入门题目。</p><p>题目给定了数组 nums，既然是要计算偷所有房子的最大受益，我们暂且设有 n 个房子，所以这个问题转换为偷 n 个房子的最大受益是多少。同时既然是动态规划的题，那么<a href="https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/">我们需要分四步走</a>。</p><ul><li>定义子问题</li><li>写出子问题的递推关系</li><li>确定 DP 数组的计算顺序</li><li>空间优化（可选）</li></ul><p>这里为了计算偷 n 个房子的收益，我们可以试图先求子问题偷前 k 个房子的收益，因为前 k 个房子是 n 个房子的子问题且规模较小。</p><p>接下来我们来看子问题的递推关系。因为题目规定了不能偷相邻的两个房子，所以只有两种偷法，对于下标为 0, 1, 2, … k 这些房子而言，我们可以</p><ul><li>偷前 k - 1 座房子，最后一座房子不偷</li><li>偷最后一座房子和第 k - 2 座，跳过 k - 1 座不偷</li></ul><p>此时我们需要判断的是这两种方案哪一种收益更大。dp[i] 的定义是如果偷前 i 个房子得到的最大收益是多少。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现 - DP自下而上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实现 - DP自上而下，需要用到备忘录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= nums.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i];<br>        &#125;<br>        <span class="hljs-comment">// 偷当前房子或者偷下一个房子</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(nums[i] + helper(nums, i + <span class="hljs-number">2</span>), helper(nums, i + <span class="hljs-number">1</span>));<br>        memo[i] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dp自上而下</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">198. House Robber<br>740. Delete and Earn<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>recursion</tag>
      
      <tag>memorization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 886. Possible Bipartition</title>
    <link href="/posts/1466336335.html"/>
    <url>/posts/1466336335.html</url>
    
    <content type="html"><![CDATA[<p>We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.</p><p>Given the integer n and the array dislikes where dislikes[i] &#x3D; [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.</p><p>Example 1:<br>Input: n &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]<br>Output: true<br>Explanation: The first group has [1,4], and the second group has [2,3].</p><p>Example 2:<br>Input: n &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]<br>Output: false<br>Explanation: We need at least 3 groups to divide them. We cannot put them in two groups.</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 2000<br>0 &lt;&#x3D; dislikes.length &lt;&#x3D; 104<br>dislikes[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; ai &lt; bi &lt;&#x3D; n<br>All the pairs of dislikes are unique.</p><p>可能的二分法。</p><blockquote>给定一组 n 人（编号为 1, 2, ..., n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。<p>给定整数 n 和数组 dislikes ，其中 dislikes[i] &#x3D; [ai, bi] ，表示不允许将编号为 ai 和 bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/possible-bipartition">https://leetcode.cn/problems/possible-bipartition</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数字 n 代表有 n 个人，还有一个二维数组 dislikes，代表每两个人之间的 dislike 关系。请返回是否有可能将 n 个人分成两组。</p><p>这个题实际是在考能否将一个图的所有节点分成两组。思路还是染色法，类似 785 题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(V + E) - V是节点数，E是边数<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>BFS 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">possibleBipartition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] dislikes)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            g.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dislikes) &#123;<br>            g.get(d[<span class="hljs-number">0</span>]).add(d[<span class="hljs-number">1</span>]);<br>            g.get(d[<span class="hljs-number">1</span>]).add(d[<span class="hljs-number">0</span>]);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (colors[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            queue.offer(i);<br>            colors[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nei : g.get(cur)) &#123;<br>                    <span class="hljs-keyword">if</span> (colors[nei] == <span class="hljs-number">0</span>) &#123;<br>                        colors[nei] = -colors[cur];<br>                        queue.offer(nei);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colors[nei] == colors[cur]) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">possibleBipartition</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] dislikes)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (dislikes == <span class="hljs-literal">null</span> || dislikes.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        List&lt;List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        buildGraph(n, dislikes, graph);<br>        <span class="hljs-type">int</span>[] colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (colors[i] == <span class="hljs-number">0</span> &amp;&amp; !dfs(i, graph, colors, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] dislikes, List&lt;List&lt;Integer&gt;&gt; graph)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            graph.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dislikes) &#123;<br>            graph.get(d[<span class="hljs-number">0</span>]).add(d[<span class="hljs-number">1</span>]);<br>            graph.get(d[<span class="hljs-number">1</span>]).add(d[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, List&lt;List&lt;Integer&gt;&gt; graph, <span class="hljs-type">int</span>[] colors, <span class="hljs-type">int</span> color)</span> &#123;<br>        colors[cur] = color;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph.get(cur)) &#123;<br>            <span class="hljs-comment">// 如果发现某个邻居的颜色和自己一样，则返回false</span><br>            <span class="hljs-keyword">if</span> (colors[next] == color) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 若发现next遍历后会发现某两个邻居染色一样，也返回false</span><br>            <span class="hljs-keyword">if</span> (colors[next] == <span class="hljs-number">0</span> &amp;&amp; !dfs(next, graph, colors, -color)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">785. Is Graph Bipartite<br>886. Possible Bipartition<br>1129. Shortest Path with Alternating Colors<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 259. 3Sum Smaller</title>
    <link href="/posts/1916472686.html"/>
    <url>/posts/1916472686.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &lt;&#x3D; i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.<br>Example 1:<br>Input: nums &#x3D; [-2,0,1,3], target &#x3D; 2<br>Output: 2<br>Explanation: Because there are two triplets which sums are less than 2:<br>[-2,0,1]<br>[-2,0,3]</p><p>Example 2:<br>Input: nums &#x3D; [], target &#x3D; 0<br>Output: 0</p><p>Example 3:<br>Input: nums &#x3D; [0], target &#x3D; 0<br>Output: 0<br>Constraints:<br>n &#x3D;&#x3D; nums.length<br>0 &lt;&#x3D; n &lt;&#x3D; 3500<br>-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>-100 &lt;&#x3D; target &lt;&#x3D; 100</p><p>较小的三数之和。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路跟 3sum 差不多，但是这个题要找的是有多少种组合能满足三数之和小于 target。思路还是先固定一个数字，然后另两个数字是通过双指针逼近的方式做。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threeSumSmaller</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>Arrays.sort(nums);<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; target) &#123;<br>res += right - left;<br>left++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">259. 3Sum Smaller<br>611. Valid Triangle Number<br>2563. Count the Number of Fair Pairs<br>2824. Count Pairs Whose Sum is Less than Target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 394. Decode String</title>
    <link href="/posts/83895672.html"/>
    <url>/posts/83895672.html</url>
    
    <content type="html"><![CDATA[<p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].</p><p>The test cases are generated so that the length of the output will never exceed 105.</p><p>Example 1:<br>Input: s &#x3D; “3[a]2[bc]”<br>Output: “aaabcbc”</p><p>Example 2:<br>Input: s &#x3D; “3[a2[c]]”<br>Output: “accaccacc”</p><p>Example 3:<br>Input: s &#x3D; “2[abc]3[cd]ef”<br>Output: “abcabccdcdcdef”</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 30<br>s consists of lowercase English letters, digits, and square brackets ‘[]’.<br>s is guaranteed to be a valid input.<br>All the integers in s are in the range [1, 300].</p><p>字符串解码。</p><blockquote>给定一个经过编码的字符串，返回它解码后的字符串。<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/decode-string">https://leetcode.cn/problems/decode-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是用 stack。需要用到两个 stack，numStack 记录所有出现的数字，strStack 记录所有出现的 string。</p><p>当遇到字母的时候，先用一个 StringBuilder sb 暂时记录下来；</p><p>当遇到数字的时候，先记录数字（因为有可能不止一个 digit），记录好了之后就放入 numStack 栈保存；</p><p>当遇到左括号的时候就把 sb 放入 strStack，意思是数字之前的字符串可以先存下来，然后我们把 sb 清空，依然用 sb 去记录括号里面的内容</p><p>当遇到右括号的时候<br>从 strStack 中 pop 出一个元素，设为 prev，这个元素是之前已经结算好的部分<br>从 numStack 中 pop 出一个元素，这是左括号之前的那个乘数<br>比如如果乘数是 3 的话，那么我们此时需要把 sb 中的内容 append 到 prev 中三次</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs nix">跑一个例子说明。比如 <span class="hljs-number">3</span>[a]<span class="hljs-number">2</span>[bc]。首先我遇到数字 <span class="hljs-number">3</span>，我就把他放入 numStack。这里如果不止一个 digit，我们需要一位一位去看，得到那个数字，再放入 numStack。<br><br><span class="hljs-params">numStack:</span> [<span class="hljs-number">3</span>]<br><br><span class="hljs-params">strStack:</span> []<br><br><span class="hljs-params">res:</span> <span class="hljs-string">&quot;&quot;</span><br><br>接着我遇到左括号，如果之前有字符串的部分，我就需要放入 strStack，然后生成一个新的 StringBuilder，然后用这个新的 StringBuilder 去统计括号内的部分，直到我们遇到右括号。按照这个例子，括号内我们能得到的部分就是 <span class="hljs-string">&quot;a&quot;</span>。此时我们遇到右括号了，可以进行结算了。结算的规则是，因为有括号就意味着需要做乘法，所以我们弹出 numStack 顶端的元素（<span class="hljs-number">3</span>），这是我们需要重复的次数；同时我们把 strStack 顶端的元素弹出（空），把当前括号内统计的这一段子串 append 到之前结果的尾部。这里的思路是我们每遇到一个右括号我们就把括号内的东西结算，然后 append 到之前已经结算好的部分的尾部。所以这部分做完之后<br><br><span class="hljs-params">numStack:</span> []<br><br><span class="hljs-params">strStack:</span> []<br><br><span class="hljs-params">res:</span> <span class="hljs-string">&quot;aaa&quot;</span><br><br>接着我们又遇到 <span class="hljs-number">2</span>，将他入栈，<span class="hljs-params">numStack:</span> [<span class="hljs-number">2</span>]。<br><br><span class="hljs-number">2</span> 后边是个左括号，此时我们要把已经记录好的字符串入栈，避免丢失，此时<br><br><span class="hljs-params">numStack:</span> [<span class="hljs-number">2</span>]<br><br><span class="hljs-params">strStack:</span> [<span class="hljs-string">&quot;aaa&quot;</span>]<br><br><span class="hljs-params">res:</span> <span class="hljs-string">&quot;&quot;</span><br><br>此时我们统计<span class="hljs-number">2</span>后面的字符串的部分，<br><br><span class="hljs-params">numStack:</span> [<span class="hljs-number">2</span>]<br><br><span class="hljs-params">strStack:</span> [<span class="hljs-string">&quot;aaa&quot;</span>]<br><br><span class="hljs-params">res:</span> <span class="hljs-string">&quot;bc&quot;</span><br><br>当我们遇到最后那个右括号的时候，我们再次做结算的动作，将 strStack 栈顶元素弹出，与当前记录好的字符串合并。res <span class="hljs-operator">=</span> strStack 栈顶元素 <span class="hljs-operator">+</span> 当前记录好的字符串。对于这个例子，就是<br><br>aaa <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> bc <span class="hljs-operator">=</span> aaa <span class="hljs-operator">+</span> bcbc <span class="hljs-operator">=</span> aaabcbc<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        Stack&lt;Integer&gt; numStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        Stack&lt;String&gt; strStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                strStack.push(sb.toString());<br>                sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(strStack.pop());<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> numStack.pop();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; count; j++) &#123;<br>                    prev.append(sb);<br>                &#125;<br>                sb = prev;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; Character.isDigit(s.charAt(i + <span class="hljs-number">1</span>))) &#123;<br>                    num = num * <span class="hljs-number">10</span> + s.charAt(i + <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                numStack.push(num);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> decodeString = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (s === <span class="hljs-literal">null</span> || s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> numStack = [];<br><span class="hljs-keyword">let</span> strStack = [];<br><span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">let</span> len = s.<span class="hljs-property">length</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-keyword">let</span> c = s.<span class="hljs-title function_">charAt</span>(i);<br><span class="hljs-keyword">if</span> (c === <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>strStack.<span class="hljs-title function_">push</span>(res);<br>res = <span class="hljs-string">&#x27;&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br><span class="hljs-keyword">let</span> num = numStack.<span class="hljs-title function_">pop</span>();<br><span class="hljs-keyword">let</span> temp = strStack.<span class="hljs-title function_">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>temp += res;<br>&#125;<br>res = temp;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(c)) &#123;<br><span class="hljs-keyword">let</span> num = <span class="hljs-title class_">Number</span>(c);<br><span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; len &amp;&amp; !<span class="hljs-built_in">isNaN</span>(s.<span class="hljs-title function_">charAt</span>(i + <span class="hljs-number">1</span>))) &#123;<br>num = num * <span class="hljs-number">10</span> + <span class="hljs-title class_">Number</span>(s.<span class="hljs-title function_">charAt</span>(i + <span class="hljs-number">1</span>));<br>i++;<br>&#125;<br>numStack.<span class="hljs-title function_">push</span>(num);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res += c;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
      <tag>javacript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 91. Decode Ways</title>
    <link href="/posts/770184420.html"/>
    <url>/posts/770184420.html</url>
    
    <content type="html"><![CDATA[<p>You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:</p><p>“1” -&gt; ‘A’<br>“2” -&gt; ‘B’<br>…</p><p>“25” -&gt; ‘Y’<br>“26” -&gt; ‘Z’</p><p>However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (“2” and “5” vs “25”).</p><p>For example, “11106” can be decoded into:<br>“AAJF” with the grouping (1, 1, 10, 6)<br>“KJF” with the grouping (11, 10, 6)<br>The grouping (1, 11, 06) is invalid because “06” is not a valid code (only “6” is valid).<br>Note: there may be strings that are impossible to decode.</p><p>Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.</p><p>The test cases are generated so that the answer fits in a 32-bit integer.</p><p>Example 1:<br>Input: s &#x3D; “12”<br>Output: 2</p><p>Explanation:<br>“12” could be decoded as “AB” (1 2) or “L” (12).</p><p>Example 2:<br>Input: s &#x3D; “226”<br>Output: 3</p><p>Explanation:<br>“226” could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p><p>Example 3:<br>Input: s &#x3D; “06”<br>Output: 0</p><p>Explanation:<br>“06” cannot be mapped to “F” because of the leading zero (“6” is different from “06”). In this case, the string is not a valid encoding, so return 0.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s contains only digits and may contain leading zero(s).</p><p>解码方法。</p><blockquote><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：<br>“1” -&gt; ‘A’</p><p>“2” -&gt; ‘B’</p><p>…</p><p>“25” -&gt; ‘Y’</p><p>“26” -&gt; ‘Z’</p><p>然而，在 解码 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（”2” 和 “5” 与 “25”）。</p><p>例如，”11106” 可以映射为：<br>“AAJF” ，将消息分组为 (1, 1, 10, 6)<br>“KJF” ，将消息分组为 (11, 10, 6)<br>消息不能分组为 (1, 11, 06) ，因为 “06” 不是一个合法编码（只有 “6” 是合法的）。<br>注意，可能存在无法解码的字符串。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。如果没有合法的方式解码整个字符串，返回 0。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是动态规划，这是一道类似爬楼梯那一类的题目。这个题 dp[i] 的定义是前 i 个数字能产生的解码方法的总数。因为解码是从数字到字母，所以有效的数字就只能在 1 到 26 之间，所以</p><ul><li>如果 input 有 leading zero 的话，直接返回 0，无法解码</li><li>中间过程中，在遍历到位置 i 的时候，需要看<code>(i - 1, i)</code>和<code>(i - 2, i)</code>是否能组成一个有效的数字</li><li>如果 (i - 1, i) 在 1 - 9 之间，则说明当前位置上的数字可以组成一个有效的一位数</li><li>如果 (i - 2, i) 在 10 - 26 之间，则说明当前位置上的数字可以和前面一个数字组成一个有效的两位数</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDecodings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span> || s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 空字符串</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 第一个字符不是0时有1种解码方式</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> s.charAt(i - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> s.charAt(i - <span class="hljs-number">2</span>);<br><br>            <span class="hljs-comment">// 如果当前这一位是0，他不能单独解码</span><br>            <span class="hljs-comment">// 只有和前一位组成10或20时才能解码</span><br>            <span class="hljs-comment">// [1, 2, 0]</span><br>            <span class="hljs-keyword">if</span> (one &gt;= <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; one &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br><br>            <span class="hljs-comment">// 两位字符解码（10~26）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (two - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (one - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">10</span> &amp;&amp; num &lt;= <span class="hljs-number">26</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> numDecodings = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> n = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">let</span> first = s.<span class="hljs-title function_">substring</span>(i - <span class="hljs-number">1</span>, i);<br>        <span class="hljs-keyword">let</span> second = s.<span class="hljs-title function_">substring</span>(i - <span class="hljs-number">2</span>, i);<br>        <span class="hljs-keyword">if</span> (first &gt;= <span class="hljs-number">1</span> &amp;&amp; first &lt;= <span class="hljs-number">9</span>) &#123;<br>            dp[i] += dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (second &gt;= <span class="hljs-number">10</span> &amp;&amp; second &lt;= <span class="hljs-number">26</span>) &#123;<br>            dp[i] += dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1277. Count Square Submatrices with All Ones</title>
    <link href="/posts/1405682268.html"/>
    <url>/posts/1405682268.html</url>
    
    <content type="html"><![CDATA[<p>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</p><p>Example 1:<br>Input: matrix &#x3D;<br>[<br>  [0,1,1,1],<br>  [1,1,1,1],<br>  [0,1,1,1]<br>]<br>Output: 15<br>Explanation:<br>There are 10 squares of side 1.<br>There are 4 squares of side 2.<br>There is  1 square of side 3.<br>Total number of squares &#x3D; 10 + 4 + 1 &#x3D; 15.</p><p>Example 2:<br>Input: matrix &#x3D;<br>[<br>  [1,0,1],<br>  [1,1,0],<br>  [1,1,0]<br>]<br>Output: 7<br>Explanation:<br>There are 6 squares of side 1.<br>There is 1 square of side 2.<br>Total number of squares &#x3D; 6 + 1 &#x3D; 7.</p><p>Constraints:<br>1 &lt;&#x3D; arr.length &lt;&#x3D; 300<br>1 &lt;&#x3D; arr[0].length &lt;&#x3D; 300<br>0 &lt;&#x3D; arr[i][j] &lt;&#x3D; 1</p><p>统计全为1的正方形子矩阵。</p><blockquote><p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟221题非常类似，给你一个只有 0 和 1 的二维矩阵，请你统计其中完全由 1 组成的正方形子矩阵的个数。思路是动态规划。动态规划的定义是 dp[i][j] 代表的是由 (i, j) 为右下角组成的矩形的个数。这个定义跟 221 题几乎一样，221 题的定义是以 (i, j) 为右下角组成的最大矩形的边长。为什么这个右下角的坐标也能定义能组成的矩形的个数呢，因为比如给你一个 2x2 的矩阵，如果矩阵内的 4 个位置都是 1 的话，右下角的坐标也是 1，这样由这个右下角的 1 能组成的矩形有两个，一个是 1x1 的，一个是 2x2 的。这一题的状态转移方程也是在看当前坐标的左边，右边和左上角的 dp 值，以决定当前坐标的 dp 值。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1) - 因为是原地修改了矩阵的值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSquares</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span> &amp;&amp; matrix[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] = min(<br>                        matrix[i - <span class="hljs-number">1</span>][j],<br>                        matrix[i][j - <span class="hljs-number">1</span>],<br>                        matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br>                    ) + <span class="hljs-number">1</span>;<br>                &#125;<br>                res += matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.min(a, Math.min(b, c));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">84. Largest Rectangle in Histogram<br>85. Maximal Rectangle<br>221. Maximal Square<br>1277. Count Square Submatrices with All Ones<br>1504. Count Submatrices With All Ones<br>1727. Largest Submatrix With Rearrangements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 901. Online Stock Span</title>
    <link href="/posts/480506829.html"/>
    <url>/posts/480506829.html</url>
    
    <content type="html"><![CDATA[<p>Design an algorithm that collects daily price quotes for some stock and returns the span of that stock’s price for the current day.</p><p>The span of the stock’s price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.</p><p>For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.<br>Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.<br>Implement the StockSpanner class:<br>StockSpanner() Initializes the object of the class.<br>int next(int price) Returns the span of the stock’s price given that today’s price is price.</p><p>Example 1:<br>Input<br>[“StockSpanner”, “next”, “next”, “next”, “next”, “next”, “next”, “next”]<br>[[], [100], [80], [60], [70], [60], [75], [85]]<br>Output<br>[null, 1, 1, 1, 2, 1, 4, 6]</p><p>Explanation<br>StockSpanner stockSpanner &#x3D; new StockSpanner();<br>stockSpanner.next(100); &#x2F;&#x2F; return 1<br>stockSpanner.next(80);  &#x2F;&#x2F; return 1<br>stockSpanner.next(60);  &#x2F;&#x2F; return 1<br>stockSpanner.next(70);  &#x2F;&#x2F; return 2<br>stockSpanner.next(60);  &#x2F;&#x2F; return 1<br>stockSpanner.next(75);  &#x2F;&#x2F; return 4, because the last 4 prices (including today’s price of 75) were less than or equal to today’s price.<br>stockSpanner.next(85);  &#x2F;&#x2F; return 6</p><p>Constraints:<br>1 &lt;&#x3D; price &lt;&#x3D; 105<br>At most 104 calls will be made to next.</p><p>股票价格跨度。</p><blockquote>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。<p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/online-stock-span">https://leetcode-cn.com/problems/online-stock-span</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为这道题的数据会到十的五次方，所以暴力解 n 方的思路应该是会超时的。O(n) 级别的思路是用单调栈。具体实现是用单调栈放两个东西，<code>&#123;价钱，股票当日价格的跨度res&#125;</code>。遍历 input 的数组，当 stack 为空的时候，就直接入栈；当 stack 不为空，需要查看栈顶元素是否小于等于当前要入栈的 price，如果是的话就弹出栈顶元素，并把栈顶元素的 res 累加到当前要入栈的元素的 res 里去。</p><p>注意如果问的这个跨度是不连续的，则无法用单调栈的思路做了。</p><p>这里补充一个为什么能想到单调栈里放的是<code>&#123;价钱，股票当日价格的跨度res&#125;</code>这个组合。比如题目给的例子<code>[100, 80, 60, 70, 60, 75, 85]</code>，一开始我们走到 100,80,60 都是递减的，所以直到 60，股价小于等于当前这一天的天数都是 0。然后我们走到70，此时我们发现70前面有一个60是小于70的，那么此时我就可以将60那天的结果（有多少天股价小于60）累加到70身上。因为股价小于60的天数一定也是小于等于70的。所以这道题的单调栈对于任何一天的股价而言，都是无条件入栈的，只是弹出的时候是有技巧的。当我们发现某一天 A 的股价大于栈顶那天 B 的股价的时候，就可以往外弹了，同时把所有小于 B 的股价的天数累加到 A 身上，意思是因为 B 天股价已经小于 A 天了，所以 如果有 X 天的股价是小于 B 那天的股价的，那么这些天的股价也必然小于 A 天。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - worse case<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    Deque&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peekLast()[<span class="hljs-number">0</span>] &lt;= price) &#123;<br>            res += stack.pollLast()[<span class="hljs-number">1</span>];<br>        &#125;<br>        stack.offerLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; price, res &#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your StockSpanner object will be instantiated and called as such:</span><br><span class="hljs-comment"> * StockSpanner obj = new StockSpanner();</span><br><span class="hljs-comment"> * int param_1 = obj.next(price);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1371. Find the Longest Substring Containing Vowels in Even Counts</title>
    <link href="/posts/1395124195.html"/>
    <url>/posts/1395124195.html</url>
    
    <content type="html"><![CDATA[<p>Given the string s, return the size of the longest substring containing each vowel an even number of times. That is, ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’ must appear an even number of times.</p><p>Example 1:<br>Input: s &#x3D; “eleetminicoworoep”<br>Output: 13<br>Explanation: The longest substring is “leetminicowor” which contains two each of the vowels: e, i and o and zero of the vowels: a and u.</p><p>Example 2:<br>Input: s &#x3D; “leetcodeisgreat”<br>Output: 5<br>Explanation: The longest substring is “leetc” which contains two e’s.</p><p>Example 3:<br>Input: s &#x3D; “bcbcbc”<br>Output: 6<br>Explanation: In this case, the given string “bcbcbc” is the longest because all vowels: a, e, i, o and u appear zero times.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 5 x 10^5<br>s contains only lowercase English letters.</p><p>每个元音包含偶数次的最长子字符串。</p><blockquote>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个字符串 s，请你返回其中包含元音字母次数为偶数次的最长的子串。题意还算比较直观，注意最后得到的子串里面，每个出现的元音字母的出现次数都必须各自为偶数，同时这里的偶数次也可以是 0 次。</p><p>这个题因为 test case 的数据量很大的关系所以一般的暴力解是过不了的。先说一下暴力解的思路吧，创建一个 hashmap 记录五个元音字母的出现次数，用追击型的 two pointer 去扫描 input 字符串，然后看子串里面每个出现的元音字母的出现次数是否都各自为偶数。</p><p>这个题的最优解是有点类似 560 题前缀和的思路，统计在两个指针 [start, end] 之间出现的元音字母的出现次数。这里有一个数学定理需要记住，就是奇数 - 奇数 &#x3D; 偶数，偶数 - 偶数 &#x3D; 偶数。所以在按照前缀和的思路找字母出现次数的时候只要在 [start, end] 之间出现的次数为偶数即可。</p><p>如何知道出现次数为偶数呢？这里会用到位运算。因为只有五个元音字母，所以可以创建一个 5 位数的 bit mask，分别代表 aeiou。比如当遇到a的时候，就只把1左移一位（从右往左看），遇到e就把1左移两位，遇到i就把1左移三位，遇到o就把1左移三位，遇到u就把1左移四位。</p><p>遍历 input 的时候，当遇到某一个元音字母的时候，就把 1 左移若干位，然后跟 cur 做异或操作 XOR。因为 XOR 的操作是两数相同结果为 0，所以某一个字母遇到两次，则这一位上的数字为 0。跑一个例子吧，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">input: abcadf<br><br>cur = 0 (00000)，把这个mask存入hashmap，表示第一次出现 00000 这个mask的地方在下标为 -1 的地方<br><br>一开始遍历到a, bit mask = 00001, cur ^ 00001 = 00001，此时用hashmap记录一下&lt;00001, i&gt;，意思是第一次出现 00001 这个mask的地方在下标为 i 的地方<br><br>遍历到b, c的时候，因为不是元音字母所以直接跳过<br><br>当遇到第二个a的时候，cur ^ 00001 = 00001 ^ 00001 = 00000，mask又变回 00000 ，此时因为这个mask在hashmap里面已经有了，所以可以结算一下长度。<br><br>照着这个思路，可以计算出所有不同mask形成的最长的子串，输出最长的那个即可<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - hashmap</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                cur ^= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;e&#x27;</span>) &#123;<br>                cur ^= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;i&#x27;</span>) &#123;<br>                cur ^= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;o&#x27;</span>) &#123;<br>                cur ^= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>                cur ^= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>);<br>            &#125;<br>            map.putIfAbsent(cur, i);<br>            res = Math.max(res, i - map.get(cur));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// aeiou</span><br><span class="hljs-comment">// 11111</span><br><span class="hljs-comment">// 00000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>prefix sum</tag>
      
      <tag>string</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 567. Permutation in String</title>
    <link href="/posts/1930154022.html"/>
    <url>/posts/1930154022.html</url>
    
    <content type="html"><![CDATA[<p>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.</p><p>In other words, return true if one of s1’s permutations is the substring of s2.</p><p>Example 1:<br>Input: s1 &#x3D; “ab”, s2 &#x3D; “eidbaooo”<br>Output: true<br>Explanation: s2 contains one permutation of s1 (“ba”).</p><p>Example 2:<br>Input: s1 &#x3D; “ab”, s2 &#x3D; “eidboaoo”<br>Output: false</p><p>Constraints:<br>1 &lt;&#x3D; s1.length, s2.length &lt;&#x3D; 104<br>s1 and s2 consist of lowercase English letters.</p><p>字符串的排列。</p><blockquote>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<p>换句话说，s1 的排列之一是 s2 的 子串 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/permutation-in-string">https://leetcode-cn.com/problems/permutation-in-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给两个字符串 s1 和 s2，s1 较短，请问 s2 中是否包含 s1 的某个排列。还是典型的 sliding window 的解法，首先创建一个 hashmap，统计 s1 中出现的字母和次数的情况，然后设置两个 pointer start 和 end，夹住 s2 开始扫描，counter 变量初始化的时候记录的是 s1 的长度，这个 counter 虽然一开始是以长度初始化，但是实际记录的是在 s1 中出现过的字母的个数，包括重复的。遍历的时候，如果 end 碰到的是 s1 中存在的字母且 counter &gt; 0，则 counter–。当 counter &#x3D;&#x3D; 0 的时候，说明此时这个区间内已经收集了所有 s1 需要的字母了。同时我们需要检查一下这个区间的长度是否等于 s1 的长度，如果等于，这个区间才是 s1 的 permutation。</p><p>代码模板参见 <mark>76 题</mark>，这是一道滑动窗口的经典题。这道题唯一跟 76 题不同的地方是只要在 s2 中找到 s1 的某一个排列，就直接 return true 了，不一定需要扫描完整个 s2。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s1.length();<br><span class="hljs-comment">// 统计s1中字母的个数</span><br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s1.toCharArray()) &#123;<br>            map[c]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s2.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s2.charAt(end);<br>            <span class="hljs-keyword">if</span> (map[c1] &gt; <span class="hljs-number">0</span>) &#123;<br>                counter--;<br>            &#125;<br>            map[c1]--;<br>            end++;<br>            <span class="hljs-keyword">while</span> (counter == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (end - start == len) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s2.charAt(start);<br>                map[c2]++;<br>                <span class="hljs-keyword">if</span> (map[c2] &gt; <span class="hljs-number">0</span>) &#123;<br>                    counter++;<br>                &#125;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 152. Maximum Product Subarray</title>
    <link href="/posts/3029431765.html"/>
    <url>/posts/3029431765.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, find a subarray that has the largest product, and return the product.</p><p>The test cases are generated so that the answer will fit in a 32-bit integer.</p><p>Example 1:<br>Input: nums &#x3D; [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.</p><p>Example 2:<br>Input: nums &#x3D; [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>The product of any subarray of nums is guaranteed to fit in a 32-bit integer.</p><p>乘积最大子数组。</p><blockquote>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<p>测试用例的答案是一个 32-位 整数。</p><p>子数组 是数组的连续子序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-product-subarray">https://leetcode.cn/problems/maximum-product-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给你一个整数数组<code>nums</code>，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>这个题跟 53 题很像，53 题问的是加和最大的子数组，这个题问的是乘积最大的子数组。思路依然是动态规划，这里 dp[i] 的含义是以 num[i] 结尾的子数组的最大值是多少。初始值是 nums[0]，状态转移方程分如下几种情况，因为数组中会存在负数所以需要记录两个变量，一个是 max 一个是 min，记录遍历到当前位置 i 的时候，局部的最大值和最小值。记录最小值的原因是有可能下一个数字又是负数的话，再乘以这个最小值，会比之前记录到的最大值还要大。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> max;<br>            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);<br>            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);<br>            res = Math.max(res, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">53. Maximum Subarray<br>152. Maximum Product Subarray<br>918. Maximum Sum Circular Subarray<br>978. Longest Turbulent Subarray<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 227. Basic Calculator II</title>
    <link href="/posts/3147143763.html"/>
    <url>/posts/3147143763.html</url>
    
    <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string contains only non-negative integers, +, -, *, &#x2F; operators and empty spaces . The integer division should truncate toward zero.</p><p>Example 1:<br>Input: “3+2*2”<br>Output: 7</p><p>Example 2:<br>Input: “ 3&#x2F;2 “<br>Output: 1</p><p>Example 3:<br>Input: “ 3+5 &#x2F; 2 “<br>Output: 5</p><p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p><p>基本计算器 II。</p><blockquote>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<p>整数除法仅保留整数部分。</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。</p><p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/basic-calculator-ii">https://leetcode.cn/problems/basic-calculator-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟版本一基本一样，多了乘法和除法的操作但是省去了括号，同时需要跳过中间遇到的空格。有了乘法和除法的话，计算就需要有优先级。思路依然是用 stack，也是按字符遍历 input，遇到乘号和除号的时候需要把栈顶元素 pop 出来，先计算乘法&#x2F;除法，把计算后的结果再放入栈内。如果遇到一个字符既不是数字也不是空格，那么一定是一个运算符。如果遇到的是加号或者减号，则把他变成栈顶元素的正号&#x2F;负号；如果是乘号&#x2F;除号的话则进行计算，把计算结果入栈。在这道题中，运算符号是不入栈的，最后从stack弹出元素的时候，所有元素之间做的只有加法。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>num = s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + <span class="hljs-number">1</span>))) &#123;<br>num = num * <span class="hljs-number">10</span> + s.charAt(i + <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 不是数字，不是空格，又不是最后一个字符，那么只能是一个运算符号</span><br><span class="hljs-comment">// 走到最后一个位置的时候需要特判，否则是不会被入栈的</span><br><span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span> || i == s.length() - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (sign == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>stack.push(num);<br>&#125;<br><span class="hljs-keyword">if</span> (sign == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>stack.push(-num);<br>&#125;<br><span class="hljs-keyword">if</span> (sign == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>stack.push(stack.pop() * num);<br>&#125;<br><span class="hljs-keyword">if</span> (sign == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>stack.push(stack.pop() / num);<br>&#125;<br>sign = s.charAt(i);<br>num = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : stack) &#123;<br>res += i;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">224. Basic Calculator<br>227. Basic Calculator II<br>772. Basic Calculator III<br>1006. Clumsy Factorial<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 224. Basic Calculator</title>
    <link href="/posts/1544296577.html"/>
    <url>/posts/1544296577.html</url>
    
    <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p><p>Example 1:<br>Input: “1 + 1”<br>Output: 2</p><p>Example 2:<br>Input: “ 2-1 + 2 “<br>Output: 3</p><p>Example 3:<br>Input: “(1+(4+5+2)-3)+(6+8)”<br>Output: 23</p><p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p><p>基本计算器。</p><blockquote><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。<br>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/basic-calculator">https://leetcode.cn/problems/basic-calculator</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是实现一个基本的计算器来计算一个简单的字符串表达式的值。注意这个题是不需要处理乘法和除法的，只需要处理<code>加减法</code>和带<code>括号</code>的情形。</p><p>思路是用 stack。按字符逐个遍历 input，注意这道题无需处理不合法的输入，所以会轻松一些。一开始遍历的时候设置一个变量 res 和一个变量 sign 记录最后的<code>结果</code>和<code>结果的正负号</code>。注意这道题是会把运算符号以 <code>+1</code> 或 <code>-1</code> 的形式放入 stack 的，弹出的时候加减运算也是是会依赖运算符号的正负情况的。</p><p>最后着重讲一下带括号的部分，如果你遇到一个左括号，就需要把之前的 res 和 sign 加入 stack，这里顺序不能错，先加 res 再加 sign，并且把 res 和 sign 都重新设置成 0 和 1，使得他们可以继续用来记录括号内的部分的结果和正负情况。当遇到右括号的时候则开始结算括号内的结果。此时的 res 是记录了括号内的部分的结果，stack.pop() 会先弹出 sign；再弹一次的时候就得到了括号部分之前的 res，再相加就得到最终的结果了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i + <span class="hljs-number">1</span>))) &#123;<br>                    num = num * <span class="hljs-number">10</span> + s.charAt(i + <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                res += num * sign;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                sign = -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.push(res);<br>                stack.push(sign);<br>                res = <span class="hljs-number">0</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 第一次pop的是符号，第二次pop的是再之前的一个数字</span><br>                res = res * stack.pop() + stack.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">224. Basic Calculator<br>227. Basic Calculator II<br>772. Basic Calculator III<br>1006. Clumsy Factorial<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 981. Time Based Key-Value Store</title>
    <link href="/posts/3002885147.html"/>
    <url>/posts/3002885147.html</url>
    
    <content type="html"><![CDATA[<p>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key’s value at a certain timestamp.</p><p>Implement the TimeMap class:</p><ul><li>TimeMap() Initializes the object of the data structure.</li><li>void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.</li><li>String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &lt;&#x3D; timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns “”.</li></ul><p>Example 1:<br>Input<br>[“TimeMap”, “set”, “get”, “get”, “set”, “get”, “get”]<br>[[], [“foo”, “bar”, 1], [“foo”, 1], [“foo”, 3], [“foo”, “bar2”, 4], [“foo”, 4], [“foo”, 5]]<br>Output<br>[null, null, “bar”, “bar”, null, “bar2”, “bar2”]</p><p>Explanation<br>TimeMap timeMap &#x3D; new TimeMap();<br>timeMap.set(“foo”, “bar”, 1);  &#x2F;&#x2F; store the key “foo” and value “bar” along with timestamp &#x3D; 1.<br>timeMap.get(“foo”, 1);         &#x2F;&#x2F; return “bar”<br>timeMap.get(“foo”, 3);         &#x2F;&#x2F; return “bar”, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is “bar”.<br>timeMap.set(“foo”, “bar2”, 4); &#x2F;&#x2F; store the key “foo” and value “bar2” along with timestamp &#x3D; 4.<br>timeMap.get(“foo”, 4);         &#x2F;&#x2F; return “bar2”<br>timeMap.get(“foo”, 5);         &#x2F;&#x2F; return “bar2”</p><p>Constraints:<br>1 &lt;&#x3D; key.length, value.length &lt;&#x3D; 100<br>key and value consist of lowercase English letters and digits.<br>1 &lt;&#x3D; timestamp &lt;&#x3D; 107<br>All the timestamps timestamp of set are strictly increasing.<br>At most 2 * 105 calls will be made to set and get.</p><p>基于时间的键值存储。</p><blockquote>设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。<p>实现 TimeMap 类：</p><p>TimeMap() 初始化数据结构对象<br>void set(String key, String value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。<br>String get(String key, int timestamp)<br>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;&#x3D; timestamp 。<br>如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。<br>如果没有值，则返回空字符串（””）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/time-based-key-value-store">https://leetcode.cn/problems/time-based-key-value-store</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-treemap"><a href="#思路一-treemap" class="headerlink" title="思路一 - treemap"></a>思路一 - treemap</h2><p>这个题有两种思路，一是用Java的 treemap，另一种是用到 binary search。</p><p>首先第一种思路，用 treemap。因为会存在多个键值是同样的 key，但是有不同的 value 和不同的 timestamp，所以一开始比较直观的思路一定是 hashmap&lt;String, timestamp&gt;，因为 hashmap 才能存储类似这种&lt;key, value&gt;键值对的数据。其次，题目要求当找到同样的 key，同样的 value 的时候，要返回最接近 timestamp 的 value，所以想到用 treemap&lt;timestamp, String&gt;，因为 treemap 是可以自动根据 key 排序的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>treemap<ul><li>构造 treemap 的时间O(nlogn) - 每放进去一个元素就要重新排序一次</li><li>空间O(n)</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>treemap实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeMap</span> &#123;<br><span class="hljs-keyword">private</span> HashMap&lt;String, TreeMap&lt;Integer, String&gt;&gt; map;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TimeMap</span><span class="hljs-params">()</span> &#123;<br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value, <span class="hljs-type">int</span> timestamp)</span> &#123;<br>TreeMap&lt;Integer, String&gt; tmap = map.get(key);<br><span class="hljs-keyword">if</span> (tmap == <span class="hljs-literal">null</span>) &#123;<br>tmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>map.put(key, tmap);<br>&#125;<br>tmap.put(timestamp, value);<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> timestamp)</span> &#123;<br>TreeMap&lt;Integer, String&gt; tmap = map.get(key);<br><span class="hljs-keyword">if</span> (tmap == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">floorKey</span> <span class="hljs-operator">=</span> tmap.floorKey(timestamp);<br><span class="hljs-keyword">if</span> (floorKey == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> tmap.get(floorKey);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TimeMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TimeMap obj = new TimeMap();</span><br><span class="hljs-comment"> * obj.set(key,value,timestamp);</span><br><span class="hljs-comment"> * String param_2 = obj.get(key,timestamp);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="思路二-二分法"><a href="#思路二-二分法" class="headerlink" title="思路二 - 二分法"></a>思路二 - 二分法</h2><p>第二种思路是用到二分法。在不用 treemap 的前提下，我们依然需要 hashmap 存储 key 和 value（这里会是一个 list）的键值对，但是对于 value 相同但是 timestamp 不同的数据，我们可以自己创建一个类，把这个类放入 list，这样当 get key 的时候，实际上我们 get 到的是一个由 arraylist 串联好的，有相同 key 的 values。当你能得到这个 list 之后，可以根据给出的变量 timestamp 找到 list 中最接近于这个 timestamp 的键值对。因为题目给的时间戳一定是有序的所以这里我们无需再排序了。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>binary search<ul><li>时间O(logn)</li><li>空间O(n)</li></ul></li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>binary search实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    String val;<br>    <span class="hljs-type">int</span> time;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(String val, <span class="hljs-type">int</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.time = time;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeMap</span> &#123;<br>    HashMap&lt;String, List&lt;Data&gt;&gt; map;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TimeMap</span><span class="hljs-params">()</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value, <span class="hljs-type">int</span> timestamp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            map.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        map.get(key).add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(value, timestamp));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> timestamp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(map.get(key), timestamp);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Data&gt; list, <span class="hljs-type">int</span> timestamp)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (list.get(mid).time == timestamp) &#123;<br>                <span class="hljs-keyword">return</span> list.get(mid).val;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.get(mid).time &lt; timestamp) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.get(mid).time &gt; timestamp) &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">// 因为如果right &lt;= timestamp，那么right一定是更接近timestamp的时间</span><br>        <span class="hljs-keyword">if</span> (list.get(right).time &lt;= timestamp) &#123;<br>            <span class="hljs-keyword">return</span> list.get(right).val;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list.get(left).time &lt;= timestamp) &#123;<br>            <span class="hljs-keyword">return</span> list.get(left).val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TimeMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TimeMap obj = new TimeMap();</span><br><span class="hljs-comment"> * obj.set(key,value,timestamp);</span><br><span class="hljs-comment"> * String param_2 = obj.get(key,timestamp);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">981. Time Based Key-Value Store<br>2034. Stock Price Fluctuation<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>treemap</tag>
      
      <tag>binary search</tag>
      
      <tag>string</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 85. Maximal Rectangle</title>
    <link href="/posts/3456055979.html"/>
    <url>/posts/3456055979.html</url>
    
    <content type="html"><![CDATA[<p>Given a rows x cols binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="Example 1"><br>Input: matrix &#x3D; [<br>[“1”,”0”,”1”,”0”,”0”],<br>[“1”,”0”,”1”,”1”,”1”],<br>[“1”,”1”,”1”,”1”,”1”],<br>[“1”,”0”,”0”,”1”,”0”]<br>]<br>Output: 6<br>Explanation: The maximal rectangle is shown in the above picture.</p><p>Example 2:<br>Input: matrix &#x3D; [[“0”]]<br>Output: 0</p><p>Example 3:<br>Input: matrix &#x3D; [[“1”]]<br>Output: 1</p><p>Constraints:<br>rows &#x3D;&#x3D; matrix.length<br>cols &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; row, cols &lt;&#x3D; 200<br>matrix[i][j] is ‘0’ or ‘1’.</p><p>最大矩形。</p><blockquote><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个二维矩阵，求二维矩阵里面由1组成的最大矩形的面积是什么。这个题有DP和单调栈两种做法，我这里给出单调栈的解法。思路跟<a href="https://shurui91.github.io/posts/3520737794.html">84题</a>类似，你可以把每一行想象成84题的bars，跑一下第一个例子，比如我们从最后一行往上遍历，最后一行是<br>[1, 0, 0, 1, 0]</p><p>按照84题的思路，能组成的最大的矩形面积是 1。<br>接着把倒数第二行的数字叠加进来，叠加的思路是，若下一行相同位置上为0，则当前位置是1；若下一行相同位置上不为0，则当前位置 + 1。</p><p>[1, 1, 1, 1, 1]<br>[1, 0, 0, 1, 0]</p><p>得到<br>[2, 1, 1, 2, 1]</p><p>从而得到最大矩形面积是2。以此类推可以得到这个4*5的矩阵里面最大的矩形的面积。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[col];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    heights[j]++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    heights[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> helper(heights);<br>            max = Math.max(max, area);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-keyword">if</span> (heights == <span class="hljs-literal">null</span> || heights.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= heights.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> i == heights.length ? <span class="hljs-number">0</span> : heights[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; cur &lt; heights[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> heights[stack.pop()];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> height * (i - start - <span class="hljs-number">1</span>);<br>                res = Math.max(res, area);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">character[][]</span>&#125; <span class="hljs-variable">matrix</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximalRectangle = <span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> row = matrix.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> heights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(col).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                heights[j]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                heights[j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> area = <span class="hljs-title function_">helper</span>(heights);<br>        res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, area);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (heights == <span class="hljs-literal">null</span> || heights.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= heights.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> h = i == heights.<span class="hljs-property">length</span> ? <span class="hljs-number">0</span> : heights[i];<br>        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; h &lt; heights[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]]) &#123;<br>            <span class="hljs-keyword">let</span> height = heights[stack.<span class="hljs-title function_">pop</span>()];<br>            <span class="hljs-keyword">let</span> start = !stack.<span class="hljs-property">length</span> ? -<span class="hljs-number">1</span> : stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">let</span> area = height * (i - start - <span class="hljs-number">1</span>);<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, area);<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">84. Largest Rectangle in Histogram<br>85. Maximal Rectangle<br>221. Maximal Square<br>1277. Count Square Submatrices with All Ones<br>1504. Count Submatrices With All Ones<br>1727. Largest Submatrix With Rearrangements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 119. Pascal&#39;s Triangle II</title>
    <link href="/posts/2036957589.html"/>
    <url>/posts/2036957589.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle.</p><p>In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:</p><p>Example 1:<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="Example 1"><br>Input: rowIndex &#x3D; 3<br>Output: [1,3,3,1]</p><p>Example 2:<br>Input: rowIndex &#x3D; 0<br>Output: [1]</p><p>Example 3:<br>Input: rowIndex &#x3D; 1<br>Output: [1,1]</p><p>Constraints:<br>0 &lt;&#x3D; rowIndex &lt;&#x3D; 33</p><p>Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?</p><p>杨辉三角 II。</p><blockquote>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟版本一类似，也是计算杨辉三角，但是只需要输出某一行的结果即可，规定只允许使用 O(n) 级别的额外空间。</p><p>参考版本一的思路二，重复利用 list 数组即可。版本一的思路是当前 index &#x3D; j 上的数字是之前一行的 j 和 j - 1 的和。但是这道题的 followup 是只能使用固定的额外空间，按照版本一的做法是会覆盖之前的结果的。所以对于每一行，我们从右往左开始算，这样就不会覆盖之前的结果了。记得最后加上每一行的最后一个 1。</p><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>参考版本一的思路二，重复利用 list 数组即可。版本一的思路是当前 index &#x3D; j 上的数字是之前一行的 j 和 j - 1 的和。但是这道题的 followup 是只能使用固定的额外空间，按照版本一的做法是会覆盖之前的结果的。所以对于每一行，我们从右往左开始算，这样就不会覆盖之前的结果了。记得最后加上每一行的最后一个 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> &#123;<br>        List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        row.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 第一行的第一个元素是1</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= rowIndex; i++) &#123;<br>            <span class="hljs-comment">// 从后向前更新当前行，避免覆盖前一行数据</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>                row.set(j, row.get(j) + row.get(j - <span class="hljs-number">1</span>));<br>            &#125;<br>            row.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 每一行的最后一个元素是1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> row;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>这里还有一种思路，是从左往右算。我们可以把题目给的例子三角形转化一下，如果我们试着把他看做一个直角三角形，那么数字的排列会是如下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>11<br>121<br>1331<br>14641<br></code></pre></td></tr></table></figure><p>注意到除了头两行情况比较特殊，只有 1 组成，从第三行开始，中间某个位置 i 上的数字 &#x3D; 上一行同位置 i 上的数字 + 上一行 i - 1 位置上的数字。我在代码中的几个地方做了 print，参见 print 的结果。处理当前行的时候，我们先在 list 的头部加一个 1，然后对于 index j 上的数字，我们把它修改为 (index j) + (index j + 1)。注意 j 的 for 循环要小于 i，因为第 i 行只能有 i 个元素。从第三行开始，所有非零的数字都是通过上一行 index 相同的数字计算而来。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= rowIndex; i++) &#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 头部的1</span><br>            cur.add(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                cur.add(list.get(j) + list.get(j - <span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-comment">// 尾部的1</span><br>            cur.add(<span class="hljs-number">1</span>);<br>            list = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">118. Pascal&#x27;s Triangle<br>119. Pascal&#x27;s Triangle II<br>120. Triangle<br>799. Champagne Tower<br>2221. Find Triangular Sum of an Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 118. Pascal&#39;s Triangle</title>
    <link href="/posts/2757894942.html"/>
    <url>/posts/2757894942.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer numRows, return the first numRows of Pascal’s triangle.</p><p>In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown:</p><p>Example 1:<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="Example 1"><br>Input: numRows &#x3D; 5<br>Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p><p>Example 2:<br>Input: numRows &#x3D; 1<br>Output: [[1]]</p><p>Constraints:<br>1 &lt;&#x3D; numRows &lt;&#x3D; 30</p><p>杨辉三角。</p><blockquote>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</blockquote><h2 id="思路一-暴力模拟"><a href="#思路一-暴力模拟" class="headerlink" title="思路一 - 暴力模拟"></a>思路一 - 暴力模拟</h2><p>按照题意一行一行把元素写出来然后返回整个三角形。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间 O(n^2)<br>空间 O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; firstRow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        firstRow.add(<span class="hljs-number">1</span>);<br>        res.add(firstRow);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numRows; i++) &#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">// 每一行开头的1</span><br>            cur.add(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 从第二个数字开始，都是找上一行的元素</span><br>            <span class="hljs-comment">// 当前行位置 j 上的数字 = 上一行位置 j - 1 + 上一行位置 j 上的数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                cur.add(res.get(i - <span class="hljs-number">1</span>).get(j - <span class="hljs-number">1</span>) + res.get(i - <span class="hljs-number">1</span>).get(j));<br>            &#125;<br>            <span class="hljs-comment">// 记得加每行最后一个1</span><br>            cur.add(<span class="hljs-number">1</span>);<br>            res.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-固定空间"><a href="#思路二-固定空间" class="headerlink" title="思路二 - 固定空间"></a>思路二 - 固定空间</h2><p>这个三角形注意一下几点</p><ul><li>首行只有一个元素 1</li><li>每一行的第一个和最后一个元素是 1</li><li>每一行的元素个数 &#x3D; 行的 index。注意 index 是从 1 开始的</li><li>中间行位于 index j 的元素 &#x3D; 上一行位于 j - 1 的元素 + 上一行位于 j 的元素</li></ul><p>照着这个思路，我们才能以固定空间复杂度来解决这个问题。这个思路有助于版本二 119 题。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间 O(n^2)<br>空间 O(k)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java 实现二 - 固定空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            list.add(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; list.size() - <span class="hljs-number">1</span>; j++) &#123;<br>                list.set(j, list.get(j) + list.get(j + <span class="hljs-number">1</span>));<br>            &#125;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">118. Pascal&#x27;s Triangle<br>119. Pascal&#x27;s Triangle II<br>120. Triangle<br>799. Champagne Tower<br>2221. Find Triangular Sum of an Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 402. Remove K Digits</title>
    <link href="/posts/3918164212.html"/>
    <url>/posts/3918164212.html</url>
    
    <content type="html"><![CDATA[<p>Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.</p><p>Example 1:<br>Input: num &#x3D; “1432219”, k &#x3D; 3<br>Output: “1219”<br>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</p><p>Example 2:<br>Input: num &#x3D; “10200”, k &#x3D; 1<br>Output: “200”<br>Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</p><p>Example 3:<br>Input: num &#x3D; “10”, k &#x3D; 2<br>Output: “0”<br>Explanation: Remove all the digits from the number and it is left with nothing which is 0.</p><p>Constraints:<br>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 105<br>num consists of only digits.<br>num does not have any leading zeros except for the zero itself.</p><p>移掉 K 位数字。</p><blockquote>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是<code>单调栈</code>。这里我们需要思考一个问题，什么样的数字才是最小的？首先高位的数字需要尽可能的小，可以尝试用 stack，从左往右把每一位 digit push 到 stack，当 stack 不为空且<code>栈顶元素</code>比<code>当前元素</code>要大的时候，pop 出栈顶元素，直到丢弃了 k 个数字为止。因为<code>栈顶元素</code>在原数字里是高位，所以这里的思路是尽量把高位的且比较大的数字丢弃。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (k == num.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num.length(); i++) &#123;<br>            <span class="hljs-comment">// 当栈不为空且栈顶元素更大的时候，弹出栈顶元素</span><br>            <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; num.charAt(i)) &#123;<br>                stack.pop();<br>                k--;<br>            &#125;<br>            stack.push(num.charAt(i));<br>        &#125;<br><br>        <span class="hljs-comment">// 再弹出元素直到弹出k个元素</span><br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            stack.pop();<br>            k--;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            sb.append(stack.pop());<br>        &#125;<br>        sb.reverse();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// skip the leading zeros</span><br>        <span class="hljs-keyword">while</span> (index &lt; sb.length() &amp;&amp; sb.charAt(index) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> index == sb.length() ? <span class="hljs-string">&quot;0&quot;</span> : sb.substring(index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">num</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeKdigits = <span class="hljs-keyword">function</span>(<span class="hljs-params">num, k</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-literal">null</span> || num.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; stack.<span class="hljs-property">length</span> &amp;&amp; num.<span class="hljs-title function_">charAt</span>(i) &lt; stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]) &#123;<br>            stack.<span class="hljs-title function_">pop</span>();<br>            k--;<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(num.<span class="hljs-title function_">charAt</span>(i));<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        stack.<span class="hljs-title function_">pop</span>();<br>        k--;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> sb = stack.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (res &lt; sb.<span class="hljs-property">length</span> &amp;&amp; sb.<span class="hljs-title function_">charAt</span>(res) === <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res === sb.<span class="hljs-property">length</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : sb.<span class="hljs-title function_">substring</span>(res);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>greedy</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 987. Vertical Order Traversal of a Binary Tree</title>
    <link href="/posts/1348128722.html"/>
    <url>/posts/1348128722.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, calculate the vertical order traversal of the binary tree.</p><p>For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0).</p><p>The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.</p><p>Return the vertical order traversal of the binary tree.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt="Example 1"><br>Input: root &#x3D; [3,9,20,null,null,15,7]<br>Output: [[9],[3,15],[20],[7]]<br>Explanation:<br>Column -1: Only node 9 is in this column.<br>Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.<br>Column 1: Only node 20 is in this column.<br>Column 2: Only node 7 is in this column.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt="Example 2"><br>Input: root &#x3D; [1,2,3,4,5,6,7]<br>Output: [[4],[2],[1,5,6],[3],[7]]<br>Explanation:<br>Column -2: Only node 4 is in this column.<br>Column -1: Only node 2 is in this column.<br>Column 0: Nodes 1, 5, and 6 are in this column.<br>          1 is at the top, so it comes first.<br>          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.<br>Column 1: Only node 3 is in this column.<br>Column 2: Only node 7 is in this column.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt="Example 3"><br>Input: root &#x3D; [1,2,3,4,6,5,7]<br>Output: [[4],[2],[1,5,6],[3],[7]]<br>Explanation:<br>This case is the exact same as example 2, but with nodes 5 and 6 swapped.<br>Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 1000].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>二叉树的垂序遍历。</p><blockquote><p>给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。<br>对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。<br>二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。<br>返回二叉树的 垂序遍历 序列。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree">https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟 314 题非常像，但是 314 只要求我们找到横坐标一样的元素，把他们合成一组；但是这个题的题目描述写的非常不清楚，根据 test case，实际的要求是</p><ul><li>如果是正常情况，自然就是从左往右按 column 输出所有节点；在每个 column 中，节点按照自身到根节点的距离（深度）由近到远输出</li><li>如果有两个节点的偏移量相同（应该是在同一个column里或一个是左孩子一个是右孩子），而且他们之于根节点的距离（深度）也相同，那么再按照 node.val 从小到大排序，比如例子二和离子三中的 5 就在 6 的前面</li></ul><p>这里我提供一个 BFS 的做法，思路跟 314 题也很像。这里我还是需要用到两个 queue，一个存遍历的所有节点，一个存每个节点相对于根节点 root 的偏移量；我还需要一个总的 hashmap 记录不同偏移量分别都是哪些节点 和一个临时的 hashmap level 记录当前层不同偏移量分别都是哪些节点。</p><p>之后按 BFS 的思路遍历整棵树，首先我们需要记录每一层的节点个数 size，同时我们需要对同一层的节点进行一个局部的统计，用临时的 hashmap level 记录每一层的节点的偏移量和节点信息。当前层遍历完毕之后，对于这个 level，我们把所有的节点拿出来并排序，此时 level 里存的都是当前层的节点，把排序好的 list 再加入总的 hashmap 里。这个做法的巧妙之处在于我们先用 level map 存了同一层的节点并对同一偏移量的节点排好序，这样当我处理完当前层的时候，我把所有的节点先加入最后的结果集。这种做法就保证了最后结果集里，偏移量相同的节点，层数&#x2F;深度小的节点在前。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 遍历了整棵树<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">verticalTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Queue&lt;Integer&gt; dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        queue.offer(root);<br>        dis.offer(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-comment">// 统计同一层上不同偏移量都有哪些节点</span><br>            <span class="hljs-comment">// &lt;偏移量, List&lt;Integer&gt;&gt;</span><br>            HashMap&lt;Integer, List&lt;Integer&gt;&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> dis.poll();<br>                <span class="hljs-keyword">if</span> (!level.containsKey(col)) &#123;<br>                    level.put(col, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                level.get(col).add(cur.val);<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                    dis.offer(col - <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                    dis.offer(col + <span class="hljs-number">1</span>);<br>                &#125;<br>                min = Math.min(min, col);<br>                max = Math.max(max, col);<br>            &#125;<br><br>            <span class="hljs-comment">// 把每一层上的节点加入最后的hashmap</span><br>            <span class="hljs-comment">// 这样层数较低的节点会被优先加入最后的结果集</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : level.keySet()) &#123;<br>                <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>                    map.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                List&lt;Integer&gt; list = level.get(key);<br>                Collections.sort(list);<br>                map.get(key).addAll(list);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> min; i &lt;= max; i++) &#123;<br>            List&lt;Integer&gt; list = map.get(i);<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">314. Binary Tree Vertical Order Traversal<br>987. Vertical Order Traversal of a Binary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 139. Word Break</title>
    <link href="/posts/322848558.html"/>
    <url>/posts/322848558.html</url>
    
    <content type="html"><![CDATA[<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p>Note:<br>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.</p><p>Example 1:<br>Input: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.</p><p>Example 2:<br>Input: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br> Note that you are allowed to reuse a dictionary word.</p><p>Example 3:<br>Input: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false</p><p>单词拆分.</p><blockquote><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/word-break">https://leetcode.cn/problems/word-break</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 dp, dp[i] 的含义是以 index &#x3D; i 位置上那个字母结尾的字符串是否能被 list 中的单词拼接。初始化 dp[0] &#x3D; true。接下来用另外一个指针 j 去扫描 0 - i 范围内所有的的 substring。如果 dp[j] &#x3D; true &amp;&amp; substring(j, i) 也在 wordDict 存在，则dp[i] &#x3D; true。</p><p>跑一下第 1 个例子，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]<br></code></pre></td></tr></table></figure><p>DP 数组最后的输出值如下，当 i 指针遍历到 c（index &#x3D; 4），j 指针还在 0 的时候，此时因为 dp[0] &#x3D; true &amp;&amp; s.substring(j, i) &#x3D; s.substring(0, 4) &#x3D; “leet” 也存在于 wordDict，所以可以将 dp[4] 标记为 true。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[true, false, false, false, true, false, false, false, true]<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">wordDict</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> wordBreak = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, wordDict</span>) &#123;<br>    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(s.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">const</span> word = s.<span class="hljs-title function_">slice</span>(j, i);<br>            <span class="hljs-keyword">if</span> (dp[j] == <span class="hljs-literal">true</span> &amp;&amp; wordDict.<span class="hljs-title function_">includes</span>(word)) &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.<span class="hljs-property">length</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>我们注意到上一种方法可行，但是效率很低。因为 substring 函数会找到一些根本不存在于 wordDict 中的单词，比如我们可以找到 leet，但是我们再去找 leetc 是没有意义的，这样一个字母一个字母地加，效率很低。一个优化的方法是我们遍历位置的同时，第二层 for 循环遍历的是每个单词。比如一开始初始化 dp[0] &#x3D; true，然后对于 wordDict 中的每个单词 word，我要找的下一个 substring 是 s.substring(i + word.length())。这样我就可以按照当前单词的长度，对这个环节的搜索加速。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; lo &lt; n; lo++) &#123;<br>            <span class="hljs-keyword">if</span> (!dp[lo]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (String word : wordDict) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> lo + word.length();<br>                <span class="hljs-comment">// 因为substring是左闭右开的区间所以要判断hi &lt;= n</span><br>                <span class="hljs-keyword">if</span> (hi &lt;= n &amp;&amp; s.substring(lo, hi).equals(word)) &#123;<br>                    dp[hi] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 314. Binary Tree Vertical Order Traversal</title>
    <link href="/posts/3097282367.html"/>
    <url>/posts/3097282367.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the vertical order traversal of its nodes’ values. (i.e., from top to bottom, column by column).</p><p>If two nodes are in the same row and column, the order should be from left to right.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg" alt="Example 1"><br>Input: root &#x3D; [3,9,20,null,null,15,7]<br>Output: [[9],[3,15],[20],[7]]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg" alt="Example 2"><br>Input: root &#x3D; [3,9,8,4,0,1,7]<br>Output: [[4],[9],[3,0,1],[8],[7]]</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg" alt="Example 3"><br>Input: root &#x3D; [3,9,8,4,0,1,7,null,null,null,2,5]<br>Output: [[4],[9,5],[3,0,1],[8,2],[7]]</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 100].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>二叉树的垂直遍历。</p><blockquote><p>给你一个二叉树的根结点，返回其结点按 垂直方向（从上到下，逐列）遍历的结果。<br>如果两个结点在同一行和列，那么顺序则为 从左到右。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>例子应该解释的很清楚了，思路是 BFS 层序遍历，需要用到一个 index 变量记录子节点相对于根节点的偏移量，同时需要用 <strong>hashmap&lt;偏移量，相同偏移量的节点组成的list&gt;</strong> 把相同偏移量的节点放在一起。</p><p>首先 BFS 层序遍历还是跟一般的 BFS 差不多，但是这里我做了两个 queue，一个存放节点，一个存放每个节点的偏移量（注意这里实际只存了 X 坐标的偏移量，这个题是有 followup 的，987题），这样 BFS 遍历的时候，可以同时得到被遍历节点的偏移量。min 和 max 的存在是记录最左和最右的偏移量，这样最后输出 res 的时候就可以从左往右按顺序输出了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">verticalOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 记录节点之于根节点的偏移距离</span><br>        Queue&lt;Integer&gt; dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        queue.offer(root);<br>        dis.offer(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> dis.poll();<br>            <span class="hljs-keyword">if</span> (!map.containsKey(col)) &#123;<br>                map.put(col, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            &#125;<br>            map.get(col).add(cur.val);<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>                dis.offer(col - <span class="hljs-number">1</span>);<br>                min = Math.min(min, col - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>                dis.offer(col + <span class="hljs-number">1</span>);<br>                max = Math.max(max, col + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> min; i &lt;= max; i++) &#123;<br>            res.add(map.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> verticalOrder = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> queue = [];<br>    queue.<span class="hljs-title function_">push</span>([root, <span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> min = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>        <span class="hljs-keyword">let</span> node = cur[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">let</span> col = cur[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(col)) &#123;<br>            map.<span class="hljs-title function_">set</span>(col, []);<br>        &#125;<br>        map.<span class="hljs-title function_">get</span>(col).<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span>) &#123;<br>            queue.<span class="hljs-title function_">push</span>([node.<span class="hljs-property">left</span>, col - <span class="hljs-number">1</span>]);<br>            min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(min, col - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span>) &#123;<br>            queue.<span class="hljs-title function_">push</span>([node.<span class="hljs-property">right</span>, col + <span class="hljs-number">1</span>]);<br>            max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, col + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = min; i &lt;= max; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(map.<span class="hljs-title function_">get</span>(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">314. Binary Tree Vertical Order Traversal<br>987. Vertical Order Traversal of a Binary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1441. Build an Array With Stack Operations</title>
    <link href="/posts/2354514140.html"/>
    <url>/posts/2354514140.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array target and an integer n.<br>You have an empty stack with the two following operations:<br>“Push”: pushes an integer to the top of the stack.<br>“Pop”: removes the integer on the top of the stack.<br>You also have a stream of the integers in the range [1, n].<br>Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:<br>If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.<br>If the stack is not empty, pop the integer at the top of the stack.<br>If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.<br>Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.</p><p>Example 1:<br>Input: target &#x3D; [1,3], n &#x3D; 3<br>Output: [“Push”,”Push”,”Pop”,”Push”]<br>Explanation:<br>Read number 1 and automatically push in the array -&gt; [1]<br>Read number 2 and automatically push in the array then Pop it -&gt; [1]<br>Read number 3 and automatically push in the array -&gt; [1,3]</p><p>Example 2:<br>Input: target &#x3D; [1,2,3], n &#x3D; 3<br>Output: [“Push”,”Push”,”Push”]</p><p>Example 3:<br>Input: target &#x3D; [1,2], n &#x3D; 4<br>Output: [“Push”,”Push”]<br>Explanation: You only need to read the first 2 numbers and stop.</p><p>Example 4:<br>Input: target &#x3D; [2,3,4], n &#x3D; 4<br>Output: [“Push”,”Pop”,”Push”,”Push”,”Push”]</p><p>Constraints:<br>1 &lt;&#x3D; target.length &lt;&#x3D; 100<br>1 &lt;&#x3D; target[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>target is strictly increasing.</p><blockquote><p>题意是给你一个目标数组 target 和一个整数 n。每次迭代，需要从  list &#x3D; {1,2,3…, n} 中依序读取一个数字。<br>请使用下述操作来构建目标数组 target:<br>Push：从 list 中读取一个新元素， 并将其推入数组中。<br>Pop：删除数组中的最后一个元素。如果目标数组构建完成，就停止读取更多元素。<br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。请返回构建目标数组所用的操作序列。题目数据保证答案是唯一的。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations">https://leetcode-cn.com/problems/build-an-array-with-stack-operations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>用栈操作构建数组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是通过 stack 的操作，返回应该做的操作。举个例子，因为最后的结果是从 1 开始判断的，所以需要从 1 到 N 遍历每个数字，如果当前数字需要，你就会知道当前这个数字是需要 push 的；如果当前数字不需要，因为需要模拟 stack 的操作，所以需要 push 再 pop。<br>我看到美版讨论里面有个人问怎么保证答案是唯一的，他给出了这么个例子，<br>target &#x3D; [3,4], n &#x3D; 4<br>[Push, Push, Pop, Pop, Push, Push][Push, Pop, Push, Pop, Push, Push]<br>他在问既然结果是3，4，到底应该是可以连续 push 呢还是不能有连续的操作。按照题意，因为 target 的长度是固定的，所以如果你额外多 push 了东西，数组是会越界的，所以不能这么做，只能在发觉当前这个数字是不需要的时候立马就 pop 出来。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">buildArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] target, <span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; target.length) &#123;<br>            res.add(<span class="hljs-string">&quot;Push&quot;</span>);<br>            <span class="hljs-keyword">if</span> (target[j] != i) &#123;<br>                res.add(<span class="hljs-string">&quot;Pop&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 277. Find the Celebrity</title>
    <link href="/posts/1300749645.html"/>
    <url>/posts/1300749645.html</url>
    
    <content type="html"><![CDATA[<p>Suppose you are at a party with n people labeled from 0 to n - 1 and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know the celebrity, but the celebrity does not know any of them.</p><p>Now you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: “Hi, A. Do you know B?” to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p><p>You are given a helper function bool knows(a, b) that tells you whether a knows b. Implement a function int findCelebrity(n). There will be exactly one celebrity if they are at the party.</p><p>Return the celebrity’s label if there is a celebrity at the party. If there is no celebrity, return -1.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2022/01/19/g1.jpg" alt="Example 1"><br>Input: graph &#x3D; [[1,1,0],[0,1,0],[1,1,1]]<br>Output: 1<br>Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] &#x3D; 1 means person i knows person j, otherwise graph[i][j] &#x3D; 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2022/01/19/g2.jpg" alt="Example 2"><br>Input: graph &#x3D; [[1,0,1],[1,1,0],[0,1,1]]<br>Output: -1<br>Explanation: There is no celebrity.</p><p>Constraints:<br>n &#x3D;&#x3D; graph.length &#x3D;&#x3D; graph[i].length<br>2 &lt;&#x3D; n &lt;&#x3D; 100<br>graph[i][j] is 0 or 1.<br>graph[i][i] &#x3D;&#x3D; 1</p><p>Follow up: If the maximum number of allowed calls to the API knows is 3 * n, could you find a solution without exceeding the maximum number of calls?</p><p>搜寻名人。</p><blockquote>给一个API函数bool knows(a, b)，以用来判断a是否认识b，认识返回true，不认识返回false。请你尽可能少的调用这个函数。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是首先假设第一个人是名人的候选人 candidate，然后往后扫描，看这个名人是否不认识后面所有的人，期间只要有一次函数返回 false 则说明 candidate 不是名人，因为有人认识他。接着设认识 candidate 的人为 candidate，一直扫描到最后。因为存在没有名人的可能性所以还要扫描第二次来判断第一次找到的 candidate 是否真的是名人，第二次扫描的时候只要 candidate 认识任何一个人，或者有任何一个人不认识 candidate，则返回 -1，否则返回 candidate。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* The knows API is defined in the parent class Relation.</span><br><span class="hljs-comment">      boolean knows(int a, int b); */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Relation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCelebrity</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (knows(candidate, i)) &#123;<br>                candidate = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// double check</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != candidate &amp;&amp; (knows(candidate, i) || !knows(i, candidate))) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 997. Find the Town Judge</title>
    <link href="/posts/4068024640.html"/>
    <url>/posts/4068024640.html</url>
    
    <content type="html"><![CDATA[<p>In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.</p><p>If the town judge exists, then:<br>The town judge trusts nobody.<br>Everybody (except for the town judge) trusts the town judge.<br>There is exactly one person that satisfies properties 1 and 2.<br>You are given an array trust where trust[i] &#x3D; [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.</p><p>Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.</p><p>Example 1:<br>Input: n &#x3D; 2, trust &#x3D; [[1,2]]<br>Output: 2</p><p>Example 2:<br>Input: n &#x3D; 3, trust &#x3D; [[1,3],[2,3]]<br>Output: 3</p><p>Example 3:<br>Input: n &#x3D; 3, trust &#x3D; [[1,3],[2,3],[3,1]]<br>Output: -1</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 1000<br>0 &lt;&#x3D; trust.length &lt;&#x3D; 104<br>trust[i].length &#x3D;&#x3D; 2<br>All the pairs of trust are unique.<br>ai !&#x3D; bi<br>1 &lt;&#x3D; ai, bi &lt;&#x3D; n</p><p>找到小镇的法官。</p><blockquote>在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。<p>如果小镇的法官真的存在，那么：</p><p>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足属性 1 和属性 2 。<br>给定数组 trust，该数组由信任对 trust[i] &#x3D; [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。<br>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-town-judge">https://leetcode-cn.com/problems/find-the-town-judge</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题跟 277 题 find the celebrity 很类似，是一个关于图的问题，是在有向图里面找唯一的终点的。思路是做一个 hashmap 统计所有人被相信的次数。因为 trust[i] &#x3D; [a, b] 的意思是 a 相信 b，而且所有的人都相信法官，所以当遇到 trust[i] &#x3D; [a, b] 的时候，如果 b 是法官，他被相信的次数一定是++；同时 a 就一定不是法官，他被相信的次数就一定要–，因为法官不相信任何人。最后在 hashmap 里被相信次数 &#x3D; 总人数 - 1 的那个人，就一定是法官。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findJudge</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] trust)</span> &#123;<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] t : trust) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> t[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> t[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// a一定不是法官</span><br>            count[a]--;<br>            count[b]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (count[i] == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 463. Island Perimeter</title>
    <link href="/posts/1799568252.html"/>
    <url>/posts/1799568252.html</url>
    
    <content type="html"><![CDATA[<p>You are given row x col grid representing a map where grid[i][j] &#x3D; 1 represents land and grid[i][j] &#x3D; 0 represents water.</p><p>Grid cells are connected horizontally&#x2F;vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p><p>The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/10/12/island.png" alt="Example 1"><br>Input: grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]<br>Output: 16<br>Explanation: The perimeter is the 16 yellow stripes in the image above.</p><p>Example 2:<br>Input: grid &#x3D; [[1]]<br>Output: 4</p><p>Example 3:<br>Input: grid &#x3D; [[1,0]]<br>Output: 4</p><p>Constraints:<br>row &#x3D;&#x3D; grid.length<br>col &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; row, col &lt;&#x3D; 100<br>grid[i][j] is 0 or 1.<br>There is exactly one island in grid.</p><p>岛屿的周长。</p><blockquote>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。<p>网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个二维矩阵，只有 0 和 1。1 表示岛屿，0 表示水。请返回岛屿的周长。这个题虽然是 200 题的 followup，但是其实跟 BFS 或者 DFS 没什么关系。思路是遍历 input，如果当前坐标的值是 1，说明是岛屿，周长 * 4；同时判断当前坐标的右边一个位置和下面一个位置是否也是岛屿，如果是，则减去两条边，因为两个邻居各自都失去一条边。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nei</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                        nei++;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                        nei++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count * <span class="hljs-number">4</span> - nei * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">grid</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> islandPerimeter = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) &#123;<br><span class="hljs-keyword">let</span> m = grid.<span class="hljs-property">length</span>;<br><span class="hljs-keyword">let</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br><span class="hljs-keyword">let</span> islands = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> neighbors = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>islands++;<br><span class="hljs-keyword">if</span> (i &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>neighbors++;<br>&#125;<br><span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>neighbors++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> islands * <span class="hljs-number">4</span> - neighbors * <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1249. Minimum Remove to Make Valid Parentheses</title>
    <link href="/posts/2743385074.html"/>
    <url>/posts/2743385074.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s of ‘(‘ , ‘)’ and lowercase English characters.</p><p>Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string.</p><p>Formally, a parentheses string is valid if and only if:<br>It is the empty string, contains only lowercase characters, or<br>It can be written as AB (A concatenated with B), where A and B are valid strings, or<br>It can be written as (A), where A is a valid string.</p><p>Example 1:<br>Input: s &#x3D; “lee(t(c)o)de)”<br>Output: “lee(t(c)o)de”<br>Explanation: “lee(t(co)de)” , “lee(t(c)ode)” would also be accepted.</p><p>Example 2:<br>Input: s &#x3D; “a)b(c)d”<br>Output: “ab(c)d”</p><p>Example 3:<br>Input: s &#x3D; “))((“<br>Output: “”<br>Explanation: An empty string is also valid.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i] is either’(‘ , ‘)’, or lowercase English letter.</p><p>移除无效的括号。</p><blockquote>给你一个由 '('、')' 和小写字母组成的字符串 s。你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。请返回任意一个合法字符串。<p>有效「括号字符串」应当符合以下 任意一条 要求：<br>空字符串或只包含小写字母的字符串<br>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」<br>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses">https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 stack 但是这个题跟20题 valid parenthesis 还不太一样，因为不光是判断，而是最后需要返回一个有效的结果。这个题我没有用到 stack 但是用到了 stack 的思想，用一个 open 变量判断到底是左括号多还是右括号多，如果 open 小于0（右括号多）就一定不要再放右括号了。</p><p>第一次扫描 input，从左往右，append 其他字符的同时，注意不要多 append 右括号即可，也就是说如果左括号都被抵消完之后又出现右括号，则不要放入结果；第二次从右往左 scan 第一次的结果，但是因为第一次扫描的时候只是控制不能让右括号多于左括号，这时有可能左括号是有多余的，所以在第二次从右往左扫描的时候需要判断如果左括号 left 多了，就不要再加入结果集了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minRemoveToMakeValid</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">open</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>open++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (open == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>open--;<br>&#125;<br>sb.append(c);<br>&#125;<br><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sb.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (sb.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; open-- &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>res.append(sb.charAt(i));<br>&#125;<br><span class="hljs-keyword">return</span> res.reverse().toString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 84. Largest Rectangle in Histogram</title>
    <link href="/posts/3520737794.html"/>
    <url>/posts/3520737794.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers heights representing the histogram’s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="Example 1"><br>Input: heights &#x3D; [2,1,5,6,2,3]<br>Output: 10<br>Explanation: The above is a histogram where width of each bar is 1.<br>The largest rectangle is shown in the red area, which has an area &#x3D; 10 units.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="Example 2"><br>Input: heights &#x3D; [2,4]<br>Output: 4</p><p>Constraints:<br>1 &lt;&#x3D; heights.length &lt;&#x3D; 105<br>0 &lt;&#x3D; heights[i] &lt;&#x3D; 104</p><p>柱状图中最大的矩形。</p><blockquote><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数组表示一些非负整数，代表一些 bars，请你返回由这些 bar 组成的最大矩形的面积。</p><p>思路是单调栈。这个题可以用别的方法，但是复杂度都不如单调栈的思路。关于这个题本身，我参考了<a href="https://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html">这个帖子</a>，他讲的非常好，起码帮助我理解了这道题单调栈的做法。至于代码，你只要看懂这个帖子的讲解，代码一定看得懂。唯一需要注意的是为什么 for loop 要遍历完 input 数组之后再多走一步，是为了让遍历完 input 之后有一个机会停下来结算由最后一个 bar 组成的矩形的最大面积，否则如果是一直递增的 bars，遍历完是没有机会停下来结算的。</p><p>这个题为什么可以用单调栈做，并且单调栈的思想适用于什么样的题目，我觉得是比如你在一堆单调增或者单调减的数据里面突然找一个拐点，就可以尝试利用单调栈。这个还是需要多做才有感觉。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-keyword">if</span> (heights == <span class="hljs-literal">null</span> || heights.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= heights.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> i == heights.length ? <span class="hljs-number">0</span> : heights[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; h &lt; heights[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> heights[stack.pop()];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> height * (i - start - <span class="hljs-number">1</span>);<br>                res = Math.max(res, area);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">heights</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> largestRectangleArea = <span class="hljs-keyword">function</span>(<span class="hljs-params">heights</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (heights == <span class="hljs-literal">null</span> || heights.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= heights.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> h = i == heights.<span class="hljs-property">length</span> ? <span class="hljs-number">0</span> : heights[i];<br>        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; h &lt; heights[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]]) &#123;<br>            <span class="hljs-keyword">let</span> height = heights[stack.<span class="hljs-title function_">pop</span>()];<br>            <span class="hljs-keyword">let</span> start = !stack.<span class="hljs-property">length</span> ? -<span class="hljs-number">1</span> : stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">let</span> area = height * (i - start - <span class="hljs-number">1</span>);<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, area);<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h2><p>暴力解，O(n^2)，OA也勉强能过，不会超时<br>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举左边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; left &lt; len; left++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minHeight</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-comment">// 枚举右边界</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left; right &lt; len; right++) &#123;<br>                <span class="hljs-comment">// 确定高度，我们要最小的高度</span><br>                minHeight = Math.min(minHeight, heights[right]);<br>                <span class="hljs-comment">// 计算面积，我们要保留计算过的最大的面积</span><br>                area = Math.max(area, (right - left + <span class="hljs-number">1</span>) * minHeight);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">84. Largest Rectangle in Histogram<br>85. Maximal Rectangle<br>221. Maximal Square<br>1277. Count Square Submatrices with All Ones<br>1504. Count Submatrices With All Ones<br>1727. Largest Submatrix With Rearrangements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 993. Cousins in Binary Tree</title>
    <link href="/posts/4130356496.html"/>
    <url>/posts/4130356496.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise.</p><p>Two nodes of a binary tree are cousins if they have the same depth with different parents.</p><p>Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png" alt="Example 1"><br>Input: root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3<br>Output: false</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png" alt="Example 2"><br>Input: root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4<br>Output: true</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png" alt="Example 3"><br>Input: root &#x3D; [1,2,3,null,4], x &#x3D; 2, y &#x3D; 3<br>Output: false</p><p>Constraints:<br>The number of nodes in the tree is in the range [2, 100].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>Each node has a unique value.<br>x !&#x3D; y<br>x and y are exist in the tree.</p><p>二叉树的堂兄弟节点。</p><blockquote><p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。<br>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。<br>我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。<br>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道树的遍历的基础题，这里我提供 BFS 和 DFS 两种解决办法。</p><p>BFS 的做法，我们从 queue 中弹出每个元素 cur 的时候，我们要去看 cur 的左右孩子的节点值是否等于 x 和 y，如果等于，则不满足<strong>父节点不同</strong>这个条件；如果 x 和 y 在同一层被找到但是父节点不一样，则说明它们是一对堂兄弟节点。</p><p>DFS 的做法是我需要以前序遍历的方式遍历整棵树，并用几个全局变量记录 x 和 y 的深度和他们各自的父节点。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="BFS代码"><a href="#BFS代码" class="headerlink" title="BFS代码"></a>BFS代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCousins</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br>Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.offer(root);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">xflag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">yflag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-keyword">if</span> (cur.val == x) &#123;<br>xflag = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (cur.val == y) &#123;<br>yflag = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span> &amp;&amp; cur.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (cur.left.val == x &amp;&amp; cur.right.val == y) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (cur.left.val == y &amp;&amp; cur.right.val == x) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.right);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (xflag &amp;&amp; yflag) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS代码"><a href="#DFS代码" class="headerlink" title="DFS代码"></a>DFS代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">xParent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">yParent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">xDepth</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">yDepth</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCousins</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        helper(root, x, y, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span> xDepth == yDepth &amp;&amp; xParent != yParent;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> depth, TreeNode parent)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == x) &#123;<br>            xParent = parent;<br>            xDepth = depth;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val == y) &#123;<br>            yParent = parent;<br>            yDepth = depth;<br>        &#125;<br>        helper(root.left, x, y, depth + <span class="hljs-number">1</span>, root);<br>        helper(root.right, x, y, depth + <span class="hljs-number">1</span>, root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">993. Cousins in Binary Tree<br>2641. Cousins in Binary Tree II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 443. String Compression</title>
    <link href="/posts/3409524787.html"/>
    <url>/posts/3409524787.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of characters chars, compress it using the following algorithm:<br>Begin with an empty string s. For each group of consecutive repeating characters in chars:<br>If the group’s length is 1, append the character to s.<br>Otherwise, append the character followed by the group’s length.<br>The compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.<br>After you are done modifying the input array, return the new length of the array.<br>You must write an algorithm that uses only constant extra space.</p><p>Example 1:<br>Input: chars &#x3D; [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br>Output: Return 6, and the first 6 characters of the input array should be: [“a”,”2”,”b”,”2”,”c”,”3”]<br>Explanation: The groups are “aa”, “bb”, and “ccc”. This compresses to “a2b2c3”.</p><p>Example 2:<br>Input: chars &#x3D; [“a”]<br>Output: Return 1, and the first character of the input array should be: [“a”]<br>Explanation: The only group is “a”, which remains uncompressed since it’s a single character.</p><p>Example 3:<br>Input: chars &#x3D; [“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]<br>Output: Return 4, and the first 4 characters of the input array should be: [“a”,”b”,”1”,”2”].<br>Explanation: The groups are “a” and “bbbbbbbbbbbb”. This compresses to “ab12”.</p><p>Constraints:<br>1 &lt;&#x3D; chars.length &lt;&#x3D; 2000<br>chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.</p><p>字符串压缩。</p><blockquote><p>给你一个字符数组 chars ，请使用下述算法压缩：<br>从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：<br>如果这一组长度为 1 ，则将字符追加到 s 中。否则，需要向 s 追加字符，后跟这一组的长度。压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。<br>请在 修改完输入数组后 ，返回该数组的新长度。<br>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/string-compression">https://leetcode.cn/problems/string-compression</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个字符串，请按规则压缩。压缩的结果还是存在 char array 中但是最后输出的是新的 char array 的<code>长度</code>。<br>基本逻辑是要求你把连续出现多个的字母转化成字母 + 出现次数的组合。要求是不使用额外空间。这个题算是模拟，我这里解释一下我的思路吧。做一个 while 循环和一个指针，首先确保指针不能跳出 while 循环，条件自然是指针指向的 index 不能大于 input 字符串的长度。在遍历 input 的时候，如果遇到一个新的字母 c，先记下这个字母，然后往后遍历看看这个字母是否有连续出现，若有，则需要记录连续出现的次数 count。当连续出现的字符停止之后，此时可以试着将已经遍历过的部分写入 res，因为你有了 c 和他的 count，所以就可以写入 res 了。注意需要将 count 先转化成 String.valueOf 然后再转化成 charArray，才能将比如12转化成”1”, “2”这样的形式。根据题意，只要 count 不等于 1，那么这个数字（字母的出现次数）就一定要被写入最后的 char array。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1) - 题目要求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compress</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (index &lt; chars.length) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> chars[index];<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (index &lt; chars.length &amp;&amp; chars[index] == cur) &#123;<br>index++;<br>count++;<br>&#125;<br><span class="hljs-comment">// write the letter</span><br>chars[res++] = cur;<br><span class="hljs-comment">// write the occurance</span><br><span class="hljs-comment">// 如果某个字母的出现次数是不是1，就需要这样处理，因为一定要填一个数字</span><br><span class="hljs-keyword">if</span> (count != <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : String.valueOf(count).toCharArray()) &#123;<br>chars[res++] = c;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">38.</span> <span class="hljs-built_in">Count</span> <span class="hljs-variable">and</span> <span class="hljs-variable">Say</span><br><span class="hljs-number">271.</span> <span class="hljs-built_in">Encode</span> <span class="hljs-variable">and</span> <span class="hljs-variable">Decode</span> <span class="hljs-variable">Strings</span><br><span class="hljs-number">443.</span> <span class="hljs-built_in">String</span> <span class="hljs-variable">Compression</span><br><span class="hljs-number">604.</span> <span class="hljs-variable">Design</span> <span class="hljs-variable">Compressed</span> <span class="hljs-built_in">String</span> <span class="hljs-variable">Iterator</span><br><span class="hljs-number">1313.</span> <span class="hljs-variable">Decompress</span> <span class="hljs-built_in">Run</span><span class="hljs-operator">-</span><span class="hljs-built_in">Length</span> <span class="hljs-variable">Encoded</span> <span class="hljs-built_in">List</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 286. Walls and Gates</title>
    <link href="/posts/2711930683.html"/>
    <url>/posts/2711930683.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n grid rooms initialized with these three possible values.</p><p>-1 A wall or an obstacle.<br>0 A gate.<br>INF Infinity means an empty room. We use the value 231 - 1 &#x3D; 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.<br>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/03/grid.jpg" alt="Example 1"><br>Input: rooms &#x3D; [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br>Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]</p><p>Example 2:<br>Input: rooms &#x3D; [[-1]]<br>Output: [[-1]]</p><p>Constraints:<br>m &#x3D;&#x3D; rooms.length<br>n &#x3D;&#x3D; rooms[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 250<br>rooms[i][j] is -1, 0, or 231 - 1.</p><p>墙与门。</p><blockquote><p>你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：</p><p>-1 表示墙或是障碍物<br>0 表示一扇门<br>INF 无限表示一个空的房间。然后，我们用 231 - 1 &#x3D; 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。<br>你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/walls-and-gates">https://leetcode.cn/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个二维矩阵，里面的 <code>-1</code> 代表墙，<code>0</code> 代表门，<code>INF</code> 代表一个空的房间。请改写所有的 INF，表明每个 INF 到最近的门的距离。</p><p>这一题是带障碍物的 flood fill类 的题目，既然是问<code>最短距离</code>，所以这个题目应该还是偏 <code>BFS</code> 做。还有一题思路比较接近的是 542 题，也是在矩阵内通过已知的一些距离去累加起来找未知坐标的距离。还有一道题也比较类似，也是带障碍物的 flood fill 类型的题目，1730 题。</p><p>具体思路是我们从矩阵中的门出发，也就是先找到矩阵中的 0，把这些 0 的坐标放入 queue。从 queue 中弹出这些 0 的时候，往四个方向扫描，看看这些 0 的周围是否有 INF。如果有，则这些 INF 就有一个具体的距离了，把这些有了距离的 INF 再放入 queue。这些 INF 有了具体的距离之后，别的距离门更远的 INF 也就可以被计算出具体的距离了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123; &#123; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125; &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wallsAndGates</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] rooms)</span> &#123;<br>        m = rooms.length;<br>        n = rooms[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (rooms[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 在矩阵范围内且是一个房间</span><br>                <span class="hljs-comment">// 注意房间的定义是Integer.MAX_VALUE</span><br>                <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; rooms[x][y] == Integer.MAX_VALUE) &#123;<br>                    rooms[x][y] = rooms[cur[<span class="hljs-number">0</span>]][cur[<span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; x, y &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">286. Walls and Gates<br>542. 01 Matrix<br>1730. Shortest Path to Get Food<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 130. Surrounded Regions</title>
    <link href="/posts/2567862819.html"/>
    <url>/posts/2567862819.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n matrix board containing letters ‘X’ and ‘O’, capture regions that are surrounded:</p><p>Connect: A cell is connected to adjacent cells horizontally or vertically.<br>Region: To form a region connect every ‘O’ cell.<br>Surround: The region is surrounded with ‘X’ cells if you can connect the region with ‘X’ cells and none of the region cells are on the edge of the board.<br>A surrounded region is captured by replacing all ‘O’s with ‘X’s in the input matrix board.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="Example 1"><br>Input: board &#x3D; [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]]<br>Output: [[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]]</p><p>Explanation:<br>In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.</p><p>Example 2:<br>Input: board &#x3D; [[“X”]]<br>Output: [[“X”]]</p><p>Constraints:<br>m &#x3D;&#x3D; board.length<br>n &#x3D;&#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>board[i][j] is ‘X’ or ‘O’.</p><p>被围绕的区域。</p><blockquote>给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域：<p>连接：一个单元格与水平或垂直方向上相邻的单元格连接。<br>区域：连接所有 ‘O’ 的单元格来形成一个区域。<br>围绕：如果您可以用 ‘X’ 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 ‘X’ 单元格围绕。</p><p>通过将输入矩阵 board 中的所有 ‘O’ 替换为 ‘X’ 来 捕获被围绕的区域。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题就是一般的 BFS&#x2F;DFS 题目，这里我给出两种做法。其中我觉得DFS比较简单，实现起来不容易错。题意很简单但是注意一个边界条件。题目要你将所有被包围的 O 用 X 填充，但是不包括矩阵边界的 O。</p><p>具体地，我们需要对矩阵扫描三遍<br>第一次遍历首先要扫描矩阵的四条边，看看四个 border 上是否有 O，如果有，则需要 DFS 遍历，找出所有跟这个边界上的 O 联通的 O 并且把他们标记成一个别的东西。我这里是标记成 N。标记说明这些坐标是不能被改成 X 的。</p><p>第二次遍历，如果当前坐标上是 O, 则说明这个 O 不在边界上，则可以将这个坐标变成 X。</p><p>第三次遍历，将矩阵内的 N 再变回 O。这些坐标是不能被改成 X 的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="DFS代码"><a href="#DFS代码" class="headerlink" title="DFS代码"></a>DFS代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        m = board.length;<br>        n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 找到边缘上的O，改成N</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == n - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                        dfs(board, i, j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 找到内圈的O，改成X</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 把N再改回成O</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        board[i][j] = <span class="hljs-string">&#x27;N&#x27;</span>;<br>        dfs(board, i - <span class="hljs-number">1</span>, j);<br>        dfs(board, i + <span class="hljs-number">1</span>, j);<br>        dfs(board, i, j - <span class="hljs-number">1</span>);<br>        dfs(board, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS代码"><a href="#BFS代码" class="headerlink" title="BFS代码"></a>BFS代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 找到边缘上的O，改成N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == n - <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>board[i][j] = <span class="hljs-string">&#x27;N&#x27;</span>;<br>queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span>[] dx = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span>[] dy = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">int</span>[] cur = queue.poll();<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dx[k];<br><span class="hljs-type">int</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> y + dy[k];<br><span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; board[newX][newY] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>board[newX][newY] = <span class="hljs-string">&#x27;N&#x27;</span>;<br>queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; newX, newY &#125;);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 找到内圈的O，改成X</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 把N再改回成O</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1095. Find in Mountain Array</title>
    <link href="/posts/1578080988.html"/>
    <url>/posts/1578080988.html</url>
    
    <content type="html"><![CDATA[<p>(This problem is an interactive problem.)</p><p>You may recall that an array arr is a mountain array if and only if:</p><p>arr.length &gt;&#x3D; 3<br>There exists some i with 0 &lt; i &lt; arr.length - 1 such that:<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) &#x3D;&#x3D; target. If such an index does not exist, return -1.</p><p>You cannot access the mountain array directly. You may only access the array using a MountainArray interface:</p><p>MountainArray.get(k) returns the element of the array at index k (0-indexed).<br>MountainArray.length() returns the length of the array.<br>Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.</p><p>Example 1:<br>Input: mountainArr &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3<br>Output: 2<br>Explanation: 3 exists in the array, at index&#x3D;2 and index&#x3D;5. Return the minimum index, which is 2.</p><p>Example 2:<br>Input: mountainArr &#x3D; [0,1,2,4,2,1], target &#x3D; 3<br>Output: -1<br>Explanation: 3 does not exist in the array, so we return -1.</p><p>Constraints:<br>3 &lt;&#x3D; mountainArr.length() &lt;&#x3D; 104<br>0 &lt;&#x3D; target &lt;&#x3D; 109<br>0 &lt;&#x3D; mountainArr.get(index) &lt;&#x3D; 109</p><p>山脉数组中查找目标值。</p><blockquote><p>（这是一个 交互式问题 ）</p><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：</p><p>首先，A.length &gt;&#x3D; 3</p><p>其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</p><p>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p><p>你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p><p>MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）<br>MountainArray.length() - 会返回该数组的长度</p><p>注意：</p><p>对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：<a href="https://leetcode-cn.com/playground/RKhe3ave%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%E8%BF%99">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> 不是一个正确答案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-in-mountain-array">https://leetcode.cn/problems/find-in-mountain-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做这个题如果对山脉数组的定义不是很明确，可以先做一下852题。这个题可以跟162，852一起做。山脉数组就是只有<code>一个峰值 peak</code>，峰值左边的元素是单调递增的，右边的元素是单调递减的。本题不允许你直接访问 input 数组，你只能通过<code>length()</code>函数知道数组的长度，通过<code>get()</code>函数得知某一个数字的值。只能用二分法做。</p><p>这个题的思路会用到三次二分法，第一次帮助找到 peak 元素，第二次去找 peak 元素左半边是否存在 target，第三次在 peak 元素右半边查找 target。注意体会不同模板比较适合的场景。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is MountainArray&#x27;s API interface.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * interface MountainArray &#123;</span><br><span class="hljs-comment"> *     public int get(int index) &#123;&#125;</span><br><span class="hljs-comment"> *     public int length() &#123;&#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span> target, MountainArray mountainArr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mountainArr.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">peak</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// find index of peak</span><br>        <span class="hljs-comment">// 因为mid + 1可能会有越界的情况所以这里给了闭区间</span><br>        <span class="hljs-comment">// 下标都在index范围内</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="hljs-number">1</span>)) &#123;<br>                left = peak = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        找peak元素部分的二分也可以这样写，需要仔细体会</span><br><span class="hljs-comment">        int left = 0;</span><br><span class="hljs-comment">        int right = n - 1;</span><br><span class="hljs-comment">        while (left + 1 &lt; right) &#123;</span><br><span class="hljs-comment">            mid = left + (right - left) / 2;</span><br><span class="hljs-comment">            if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) &#123;</span><br><span class="hljs-comment">                left = mid;</span><br><span class="hljs-comment">            &#125; else &#123;</span><br><span class="hljs-comment">                right = mid;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if (mountainArr.get(left) &gt; mountainArr.get(right)) &#123;</span><br><span class="hljs-comment">            peak = left;</span><br><span class="hljs-comment">        &#125; else &#123;</span><br><span class="hljs-comment">            peak = right;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-comment">// find target in the left of peak</span><br>        left = <span class="hljs-number">0</span>;<br>        right = peak;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (mountainArr.get(mid) &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountainArr.get(mid) &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// find target in the right of peak</span><br>        left = peak;<br>        right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (mountainArr.get(mid) &gt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mountainArr.get(mid) &lt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">162. Find Peak Element<br>852. Peak Index in a Mountain Array<br>1095. Find in Mountain Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 704. Binary Search</title>
    <link href="/posts/3240947674.html"/>
    <url>/posts/3240947674.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1:<br>Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>Output: 4<br>Explanation: 9 exists in nums and its index is 4</p><p>Example 2:<br>Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>Output: -1<br>Explanation: 2 does not exist in nums so return -1</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt; nums[i], target &lt; 104<br>All the integers in nums are unique.<br>nums is sorted in ascending order.</p><p>二分查找。</p><blockquote>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-search">https://leetcode-cn.com/problems/binary-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题跟35题几乎一样。思路就是二分，没什么可说的，但是注意二分查找有好几种模板，我这里给出我比较喜欢的一种。当while条件是带等号的时候，且当nums[mid] &lt; target的时候，因为知道mid及其左边都小于target，所以left可以从mid的右边（mid + 1）开始继续查找，同理right也是从mid的左边开始查找，即right &#x3D; mid - 1。</p><p>同时我解释一下 while (left &lt;&#x3D; right) 的终止条件是 left &#x3D;&#x3D; right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意right的定义，是数字的最后一个元素的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 搜索的范围都在数组的下标范围内</span><br>        <span class="hljs-comment">// 如果nums[mid]不是目标值，下标一定要 +/- 1</span><br>        <span class="hljs-comment">// 注意left &lt;= right</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实现二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意right的定义，是数字的最后一个元素的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 搜索的范围都在数组的下标范围内</span><br>        <span class="hljs-comment">// 如果nums[mid]不是目标值，下标一定要 +/- 1</span><br>        <span class="hljs-comment">// 注意left &lt;= right</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java实现三</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 因为 start + 1 &lt; end，当跳出while循环的时候，start + 1 = end，start 和 end 是相邻的坐标，所以有最后的特判</span><br>        <span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                end = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[start] == target) &#123;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[end] == target) &#123;<br>            <span class="hljs-keyword">return</span> end;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> search = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(left + (right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">35. Search Insert Position<br>704. Binary Search<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 221. Maximal Square</title>
    <link href="/posts/3979275054.html"/>
    <url>/posts/3979275054.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="Example 1"></p><p>Input: matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>Output: 4</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg" alt="Example 2"></p><p>Input: matrix &#x3D; [[“0”,”1”],[“1”,”0”]]<br>Output: 1</p><p>Example 3:<br>Input: matrix &#x3D; [[“0”]]<br>Output: 0</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>matrix[i][j] is ‘0’ or ‘1’.</p><p>最大正方形。</p><blockquote><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。这是一道矩阵类的DP问题。dp[i][j] 的定义是以坐标 [i][j] 为右下角的点组成的正方形的最大边长。状态转移方程是dp(i, j) &#x3D; min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1)) + 1。这样的题目练多了才会有思路。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java一维实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalSquare</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> m &gt; <span class="hljs-number">0</span> ? matrix[<span class="hljs-number">0</span>].length : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dp[j];<br>                <span class="hljs-keyword">if</span> (matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dp[j] = Math.min(Math.min(dp[j - <span class="hljs-number">1</span>], prev), dp[j]) + <span class="hljs-number">1</span>;<br>                    max = Math.max(max, dp[j]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[j] = <span class="hljs-number">0</span>;<br>                &#125;<br>                prev = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max * max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java二维实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalSquare</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dp[i][j] = min(<br>                        dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,<br>                        dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>,<br>                        dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                    );<br>                    res = Math.max(res, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res * res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.min(a, Math.min(b, c));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">84. Largest Rectangle in Histogram<br>85. Maximal Rectangle<br>221. Maximal Square<br>1277. Count Square Submatrices with All Ones<br>1504. Count Submatrices With All Ones<br>1727. Largest Submatrix With Rearrangements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 621. Task Scheduler</title>
    <link href="/posts/3568311193.html"/>
    <url>/posts/3568311193.html</url>
    
    <content type="html"><![CDATA[<p>You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, n. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there’s a constraint: identical tasks must be separated by at least n intervals due to cooling time.</p><p>​Return the minimum number of intervals required to complete all tasks.</p><p>Example 1:<br>Input: tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 2<br>Output: 8<br>Explanation: A possible sequence is: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p><p>After completing task A, you must wait two cycles before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th cycle, you can do A again as 2 intervals have passed.</p><p>Example 2:<br>Input: tasks &#x3D; [“A”,”C”,”A”,”B”,”D”,”B”], n &#x3D; 1<br>Output: 6<br>Explanation: A possible sequence is: A -&gt; B -&gt; C -&gt; D -&gt; A -&gt; B.</p><p>With a cooling interval of 1, you can repeat a task after just one other task.</p><p>Example 3:<br>Input: tasks &#x3D; [“A”,”A”,”A”, “B”,”B”,”B”], n &#x3D; 3<br>Output: 10<br>Explanation: A possible sequence is: A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B.</p><p>There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.</p><p>Constraints:<br>1 &lt;&#x3D; tasks.length &lt;&#x3D; 104<br>tasks[i] is an uppercase English letter.<br>0 &lt;&#x3D; n &lt;&#x3D; 100</p><p>任务调度器。</p><blockquote>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 最短时间 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/task-scheduler">https://leetcode.cn/problems/task-scheduler</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这个题我给出两种解法，都是利用贪心的思路，一种是数学解法，一种会用到 priority queue 优先队列。</p><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>首先是数学的解法，思路跟358，767类似，你需要为相同字母隔开一定的距离，且首先需要保证为出现次数最多的字母隔开足够的距离。满足这个大前提之后，中间的空格就可以塞入其他字符了。这个题的思路也是类似，需要注意的细节是，如果出现次数最多的字母出现了 max 次，冷却时间为 n 的话，你需要为整个输出预留 (max - 1) * (n + 1) + 1。这个结论我第一次看的时候不理解， 后来看了一个例子记住了。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">AAAABBBEEFFGG N = 3</span><br><br><span class="hljs-comment">摆放结果</span><br><br><span class="hljs-comment">任务A出现了4次，频率最高，于是我们在每个A中间加入三个空位，如下：</span><br><span class="hljs-comment">A</span><span class="hljs-literal">---</span><span class="hljs-comment">A</span><span class="hljs-literal">---</span><span class="hljs-comment">A</span><span class="hljs-literal">---</span><span class="hljs-comment">A</span><br><span class="hljs-comment">AB</span><span class="hljs-literal">--</span><span class="hljs-comment">AB</span><span class="hljs-literal">--</span><span class="hljs-comment">AB</span><span class="hljs-literal">--</span><span class="hljs-comment">A (加入B)</span><br><span class="hljs-comment">ABE</span><span class="hljs-literal">-</span><span class="hljs-comment">ABE</span><span class="hljs-literal">-</span><span class="hljs-comment">AB</span><span class="hljs-literal">--</span><span class="hljs-comment">A (加入E)</span><br><span class="hljs-comment">ABEFABE</span><span class="hljs-literal">-</span><span class="hljs-comment">ABF</span><span class="hljs-literal">-</span><span class="hljs-comment">A (加入F，每次尽可能填满或者是均匀填充)</span><br><span class="hljs-comment">ABEFABEGABFGA (加入G)</span><br></code></pre></td></tr></table></figure><p>如上这个例子，max 应该是 A 出现的次数 &#x3D; 4，所以预留长度应该是间隔的出现次数 * 每个间隔长度，(4 - 1) * (3 + 1) &#x3D; 3 * 4 &#x3D; 12。为什么呢？因为 A 出现了 4 次，其中 4 个 A 之间会需要 3 个间隔，所以次数是 3；每个间隔的长度是冷却时间 + 1，比如之前这个例子，冷却时间是 2，但是每个 A 之间的间隔是 3。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Example</span>:<br>Input: tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>], n = <span class="hljs-number">2</span><br>Output: <span class="hljs-number">8</span><br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.<br></code></pre></td></tr></table></figure><p>至于具体的做法，是先用 hashmap 统计每个出现的字母及其次数，然后找出出现次数最大的字母的次数，先依据这个最大次数 max 和冷却时间 n ，算出一个符合条件的最短距离。同时注意两个 corner case</p><ol><li>如果出现次数最多的字母有多个，那么最后需要再 + 1。还是刚才这个例子<blockquote><p>AAAABBBEEFFGG N &#x3D; 3</p></blockquote></li></ol><p>因为 A 出现了 4 次，所以我们为了 A，起码需要有的长度 &#x3D; (max - 1) * (n + 1) + 1 &#x3D; 3 * 4 + 1 &#x3D; 13。这个长度只能摆放 max - 1 个 A（出现次数最多的字母）。假设如果 B 也出现了 4 次，input 字符串变成 AAAABBBBEEFFGG 的话，就要预留 12 + 2 &#x3D; 14 个位置。为什么最后 + 1 变成 + 2 是需要留给第四个 B，因为最后一个 B 也没有计算在内。或者换句话说之前我们计算的长度其实是按照 gap 来算的，不是按照字母出现次数算的。</p><ol start="2"><li>会存在不需要加额外冷却时间的情形，比如 n 小于 tasks 的长度，tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 1，只要把 A 和 B 隔开排列就行了。</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leastInterval</span><span class="hljs-params">(<span class="hljs-type">char</span>[] tasks, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : tasks) &#123;<br>            map[c]++;<br>            max = Math.max(max, map[c]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (max - <span class="hljs-number">1</span>) * (n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map[i] == max) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(res, tasks.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>再来是 priority queue 的做法。首先用 pq 建立一个最大堆，记录存每个字母的出现次数，出现次数最多的字母会在堆顶。再创建一个 cycle 变量，长度是 n + 1，这是每个间隔的长度。接着开始 pop 字符，每 pop 出一个字符的时候，将他加入一个临时的 list，因为有可能还会再加回 pq。每次如果在 cycle 跑完之前，pq 就遍历完了，则加入 worktime，如果 pq 没有遍历完，则加入 pq 的 size。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leastInterval</span><span class="hljs-params">(<span class="hljs-type">char</span>[] tasks, <span class="hljs-type">int</span> n)</span> &#123;<br>        HashMap&lt;Character, Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> t : tasks) &#123;<br>            counts.put(t, counts.getOrDefault(t, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br>        queue.addAll(counts.values());<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cycle</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">worktime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cycle; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!queue.isEmpty()) &#123;<br>                    temp.add(queue.poll());<br>                    worktime++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> count : temp) &#123;<br>                <span class="hljs-keyword">if</span> (--count &gt; <span class="hljs-number">0</span>) &#123;<br>                    queue.offer(count);<br>                &#125;<br>            &#125;<br>            res += !queue.isEmpty() ? cycle : worktime;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>greedy</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 18. 4Sum</title>
    <link href="/posts/1313962781.html"/>
    <url>/posts/1313962781.html</url>
    
    <content type="html"><![CDATA[<p>Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:<br>0 &lt;&#x3D; a, b, c, d &lt; n<br>a, b, c, and d are distinct.<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>You may return the answer in any order.</p><p>Example 1:<br>Input: nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p><p>Example 2:<br>Input: nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>Output: [[2,2,2,2]]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><p>四数之和。</p><blockquote><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：<br>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/4sum">https://leetcode.cn/problems/4sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>依然是双指针逼近的思路做，注意以下几点</p><ul><li>需要对 input 排序</li><li>需要四个指针 - i, j, low, high</li><li>每个指针都需要跳过重复元素</li><li>i 最多到 nums.length - 3</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^3)<br>空间O(n) - output</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="Java实现-可以处理整型溢出的问题（19行）"><a href="#Java实现-可以处理整型溢出的问题（19行）" class="headerlink" title="Java实现 - 可以处理整型溢出的问题（19行）"></a>Java实现 - 可以处理整型溢出的问题（19行）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (low &lt; hi) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) target - nums[i] - nums[j];<br>                    <span class="hljs-keyword">if</span> (nums[low] + nums[hi] == sum) &#123;<br>                        res.add(Arrays.asList(nums[i], nums[j], nums[low], nums[hi]));<br>                        <span class="hljs-keyword">while</span> (low &lt; hi &amp;&amp; nums[low] == nums[low + <span class="hljs-number">1</span>]) &#123;<br>                            low++;<br>                        &#125;<br>                        <span class="hljs-keyword">while</span> (low &lt; hi &amp;&amp; nums[hi] == nums[hi - <span class="hljs-number">1</span>]) &#123;<br>                            hi--;<br>                        &#125;<br>                        low++;<br>                        hi--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[low] + nums[hi] &lt; sum) &#123;<br>                        low++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        hi--;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fourSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">let</span> low, high, sum;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            low = j + <span class="hljs-number">1</span>;<br>            high = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>                sum = nums[i] + nums[j] + nums[low] + nums[high];<br>                <span class="hljs-keyword">if</span> (sum === target) &#123;<br>                    res.<span class="hljs-title function_">push</span>([nums[i], nums[j], nums[low], nums[high]]);<br>                    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[low] === nums[low + <span class="hljs-number">1</span>]) low++;<br>                    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[high] === nums[high - <span class="hljs-number">1</span>]) high--;<br>                    low++;<br>                    high--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                    low++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    high--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 380. Insert Delete GetRandom O(1)</title>
    <link href="/posts/2624115962.html"/>
    <url>/posts/2624115962.html</url>
    
    <content type="html"><![CDATA[<p>Design a data structure that supports all following operations in average O(1) time.</p><p>insert(val): Inserts an item val to the set if not already present.<br>remove(val): Removes an item val from the set if present.<br>getRandom: Returns a random element from current set of elements.<br>Each element must have the same probability of being returned.</p><p>Example:<br>&#x2F;&#x2F; Init an empty set.<br>RandomizedSet randomSet &#x3D; new RandomizedSet();</p><p>&#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.<br>randomSet.insert(1);</p><p>&#x2F;&#x2F; Returns false as 2 does not exist in the set.<br>randomSet.remove(2);</p><p>&#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].<br>randomSet.insert(2);</p><p>&#x2F;&#x2F; getRandom should return either 1 or 2 randomly.<br>randomSet.getRandom();</p><p>&#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].<br>randomSet.remove(1);</p><p>&#x2F;&#x2F; 2 was already in the set, so return false.<br>randomSet.insert(2);</p><p>&#x2F;&#x2F; Since 2 is the only number in the set, getRandom always return 2.<br>randomSet.getRandom();</p><p>O(1) 时间插入、删除和获取随机元素。</p><blockquote>实现RandomizedSet 类：<p>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/insert-delete-getrandom-o1">https://leetcode.cn/problems/insert-delete-getrandom-o1</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>大致思路是用一个 hashmap 和一个 list 来实现。其中 list 只是存元素，hashmap 存的是&lt;元素，他在 list 里的下标&gt;。</p><p>既然题目对所有操作的复杂度要求都是 O(1)，那么大概率需要用到 hashmap，因为元素本身在 list 中，在不知道 list 下标的情况下去删除一个元素的复杂度肯定是不止 O(1) 的。又因为我们是没有一个数据结构既能支持 O(1) 级别的读取，又能做到有序，所以这里 hashmap 里存的是&lt;元素，他在 list 里的下标&gt;。同时再创建一个 list，只存储元素。</p><p>insert 元素的时候，将 val 加入 list，然后将&lt;val, list.size() - 1&gt; 加入 hashmap。这样 hashmap 就记录了这个 val 在 list 里的下标。</p><p>remove 一个目标值 val 的时候，如果这个元素不在 hashmap 自然是 return false。若存在，</p><ul><li>获取 val 在 list 中的 index</li><li>将 list 中的最后一个元素移动到 index 上</li><li>更新 hashmap 中最后一个元素的位置</li><li>从 hashmap 中移除 val</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">跑一个例子吧，比如一开始加了 1,2,3,4,5 五个数字，他们被加入的时候，hashmap 和 list 应该长类似这样<br>map: &#123;1:0, 2:1, 3:2, 4:3, 5:4&#125;<br>list: 1-&gt;2-&gt;3-&gt;4-&gt;5<br>此时如果删除了数字 2，hashmap 和 list 会变成这样，最后一个元素 5 会被移动到 list 上 index 为 1 的地方。<br>map: &#123;1:0, 5:1, 3:2, 4:3&#125;<br>list: 1-&gt;5-&gt;3-&gt;4<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br>    HashMap&lt;Integer, Integer&gt; map;<br>    List&lt;Integer&gt; list;<br>    Random rmd;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomizedSet</span><span class="hljs-params">()</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        rmd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>                <span class="hljs-comment">// 加入val之后，map里存的是val在list中的index，这样比较直观</span><br>        list.add(val);<br>        map.put(val, list.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastItem</span> <span class="hljs-operator">=</span> list.get(list.size() - <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 要移除的元素在list中的index</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(val);<br>                <span class="hljs-comment">// 把最后一个元素lastItem挪到要移除的元素val的位置</span><br>        list.set(index, lastItem);<br>                <span class="hljs-comment">// 更新lastItem在map中的index</span><br>        map.put(lastItem, index);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        map.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.get(rmd.nextInt(list.size()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet obj = new RandomizedSet();</span><br><span class="hljs-comment"> * boolean param_1 = obj.insert(val);</span><br><span class="hljs-comment"> * boolean param_2 = obj.remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj.getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>math</tag>
      
      <tag>design</tag>
      
      <tag>random</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 80. Remove Duplicates from Sorted Array II</title>
    <link href="/posts/3921215091.html"/>
    <url>/posts/3921215091.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.</p><p>Return k after placing the final result in the first k slots of nums.</p><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p><p>Custom Judge:</p><p>The judge will test your solution with the following code:</p><p>int[] nums &#x3D; […]; &#x2F;&#x2F; Input array<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; The expected answer with correct length</p><p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; Calls your implementation</p><p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br> assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>If all assertions pass, then your solution will be accepted.</p><p>Example 1:<br>Input: nums &#x3D; [1,1,1,2,2,3]<br>Output: 5, nums &#x3D; [1,1,2,2,3,_]<br>Explanation: Your function should return k &#x3D; 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.<br>It does not matter what you leave beyond the returned k (hence they are underscores).</p><p>Example 2:<br>Input: nums &#x3D; [0,0,1,1,1,1,2,3,3]<br>Output: 7, nums &#x3D; [0,0,1,1,2,3,3,<em>,</em>]<br>Explanation: Your function should return k &#x3D; 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.<br>It does not matter what you leave beyond the returned k (hence they are underscores).</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums is sorted in non-decreasing order.</p><p>删除排序数组中的重复项 II。</p><blockquote>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>思路跟 26 题版本一差不多，也是双指针，但是本题要求元素最多只能重复两次。这里我创建两个指针，其中 i 指向原数组，用这个指针遍历 input 数组中的元素；j 指向要写入的 index。i 和 j 初始化的时候都可设置成 2，因为前两个元素可以重复，不用考虑。从 index &#x3D; 2 的地方开始，我们看如果 nums[i] !&#x3D; nums[j - 2]，那么可以把 nums[i] 放到 j 位置。意思是如果 nums[i] 与写入位置 j 的前两个位置 j - 2 上的元素不同，则可以把这个元素写入结果。</p><p>这个思路可以延伸到元素最多只能重复 k 次的情况。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[j - <span class="hljs-number">2</span>]) &#123;<br>                nums[j++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> nums.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (nums[i] !== nums[j - <span class="hljs-number">2</span>]) &#123;<br>nums[j] = nums[i];<br>j++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> j;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link href="/posts/3037487337.html"/>
    <url>/posts/3037487337.html</url>
    
    <content type="html"><![CDATA[<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return the binary tree.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="Example 1"><br>Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p><p>Example 2:<br>Input: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>Output: [-1]</p><p>Constraints:</p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> and <code>inorder</code> consist of unique values.</li><li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li><li><code>preorder</code> is guaranteed to be the preorder traversal of the tree.</li><li><code>inorder</code> is guaranteed to be the inorder traversal of the tree.</li></ul><p>从前序与中序遍历序列构造二叉树。</p><blockquote>题意是给一个二叉树的前序遍历和中序遍历，请根据这两个遍历，把树构造出来。你可以假设树中没有重复的元素。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是<strong>递归 + 分治</strong>。首先，preorder 的首个元素是树的根节点 root。然后在中序遍历中找到这个根节点的位置，在其左边的所有元素会构成其左子树，在其右边的元素会构成其右子树。</p><p>还是跑这个例子，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">preorder = [3,9,20,15,7] - 3是根节点<br>inorder = [9,3,15,20,7] - 9是左子树节点；15，20，7会构成右子树<br></code></pre></td></tr></table></figure><p>preorder 中，第一个节点 3 是根节点，之后的节点是先列出所有的左孩子，再列出所有的右孩子。在 inorder 的排列中位于 3 之前的所有元素应该是左孩子；位于 3 之后的元素应该是右孩子。代码中的 index 变量，找的是根节点在 inorder 里面的坐标。</p><p>根据如上的结论，再下一轮递归调用的时候你会发现 20 是 3 的右孩子，而 15 和 7 分别是 20 的左孩子和右孩子。其他步骤参见代码注释。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br><span class="hljs-keyword">return</span> helper(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br><span class="hljs-comment">// 递归的第一步：递归终止条件，避免死循环</span><br><span class="hljs-keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 重建根节点</span><br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preStart]);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">index找到根节点在中序遍历的位置</span><br><span class="hljs-comment">那么index左边的数都在左子树中，index右边的数都在右子树中，这样就知道了左右子树的大小</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (inorder[inStart + index] != preorder[preStart]) &#123;<br>index++;<br>&#125;<br>root.left = helper(preorder, preStart + <span class="hljs-number">1</span>, preStart + index, inorder, inStart, inStart + index - <span class="hljs-number">1</span>);<br>root.right = helper(preorder, preStart + index + <span class="hljs-number">1</span>, preEnd, inorder, inStart + index + <span class="hljs-number">1</span>, inEnd);<br><span class="hljs-keyword">return</span> root;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">105. Construct Binary Tree from Preorder and Inorder Traversal<br>106. Construct Binary Tree from Inorder and Postorder Traversal<br>889. Construct Binary Tree from Preorder and Postorder Traversal<br>1008. Construct Binary Search Tree from Preorder Traversal<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1248. Count Number of Nice Subarrays</title>
    <link href="/posts/1581090087.html"/>
    <url>/posts/1581090087.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.</p><p>Return the number of nice sub-arrays.</p><p>Example 1:<br>Input: nums &#x3D; [1,1,2,1,1], k &#x3D; 3<br>Output: 2<br>Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].</p><p>Example 2:<br>Input: nums &#x3D; [2,4,6], k &#x3D; 1<br>Output: 0<br>Explanation: There are no odd numbers in the array.</p><p>Example 3:<br>Input: nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2<br>Output: 16</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 50000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><p>统计「优美子数组」。</p><blockquote>题意是给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>子数组的题一般可以试图往 sliding window 或者前缀和 prefix sum 上靠，本题我两种解法都给出。</p><h2 id="思路一-前缀和"><a href="#思路一-前缀和" class="headerlink" title="思路一 - 前缀和"></a>思路一 - 前缀和</h2><p>首先前缀和的思路是遍历 input 里面的每个数字，把他们的<code>前缀和 sum</code> 和<code>出现次数</code>加到 hashmap 里面，但是这一题跟 560 题的区别在于，560 是在找一个特别的子数组的和 k，而本题是在找有多少个包含 k 个奇数的子数组，他并不在意子数组的和或者长度是多少。所以思路是遇到奇数的时候可以把这个数字改成 1，遇到偶数的时候可以把这个数字改成 0。当累加 prefix sum 的时候，因为从 0 到当前位置的前缀和为 sum，所以如果找到一个前缀和 sum - k，则说明存在这样一个优美子数组。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            sum += (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            res += map.getOrDefault(sum - k, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-滑动窗口"><a href="#思路二-滑动窗口" class="headerlink" title="思路二 - 滑动窗口"></a>思路二 - 滑动窗口</h2><p>既然题目说找的是<code>恰好</code>k 个奇数数字的子数组，那么我们可以沿用 992 题的思路。即最多 k 个奇数数字的子数组 - 最多 k - 1 个奇数数字的子数组 &#x3D; 正好 k 个奇数的子数组。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[end] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                k--;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (nums[start] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    k++;<br>                &#125;<br>                start++;<br>                count++;<br>            &#125;<br>            res += count;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 37. Sudoku Solver</title>
    <link href="/posts/1704254952.html"/>
    <url>/posts/1704254952.html</url>
    
    <content type="html"><![CDATA[<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><p>Each of the digits 1-9 must occur exactly once in each row.<br>Each of the digits 1-9 must occur exactly once in each column.<br>Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.<br>The ‘.’ character indicates empty cells.</p><p>Example 1:<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="Example 1"><br>Input: board &#x3D; [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]</p><p>Output: [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br>Explanation: The input board is shown above and the only valid solution is shown below:<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="Example"></p><p>Constraints:<br>board.length &#x3D;&#x3D; 9<br>board[i].length &#x3D;&#x3D; 9<br>board[i][j] is a digit or ‘.’.<br>It is guaranteed that the input board has only one solution.</p><p>解数独。</p><blockquote><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 遵循如下规则：</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sudoku-solver">https://leetcode.cn/problems/sudoku-solver</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要先做 36 题。做完 36 题，37 题需要做的就是根据规则填充 input。填充的规则是如果当前坐标上是一个点（.）的话，尝试放 1 - 9 之间的一个数字，放进去之后判断两件事，1 是是否有效（这个数字在当前行&#x2F;列&#x2F;九宫格是否被放过了），2 是放进去之后接着往下迭代处理剩下的部分的时候看看是否依然能解决完整个数独。所以这道题会牵涉到 DFS 回溯。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间 O(9^(n*n))，其中 n 是数独的边长<br>空间 O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="Java实现一"><a href="#Java实现一" class="headerlink" title="Java实现一"></a>Java实现一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">if</span> (board == <span class="hljs-literal">null</span> || board.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        helper(board);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; c++) &#123;<br>                        <span class="hljs-keyword">if</span> (isValid(board, i, j, c)) &#123;<br>                            board[i][j] = c;<br>                            <span class="hljs-keyword">if</span> (helper(board)) &#123;<br>                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][col] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; board[i][col] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (board[row][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; board[row][i] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (board[row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span>][col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span>] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; board[row / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span>][col / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span>] == c) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java实现二"><a href="#Java实现二" class="headerlink" title="Java实现二"></a>Java实现二</h2><p>我这里再提供一种更好理解的做法。首先我们还是创建三个 boolean 的二维数组记录已经存在的数字，然后我们需要一个 helper 函数去做 backtracking，模拟完其他还不存在的数字。helper 函数的退出条件是模拟到了最右下角的坐标；在没有模拟完毕之前，对于每个还没有填充过数字的坐标，我们都尝试去填充从 1 到 9 的每一个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-comment">// 三个布尔数组 表明 行, 列, 还有 3*3 的方格的数字是否被使用过</span><br>        <span class="hljs-type">boolean</span>[][] rowUsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">boolean</span>[][] colUsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-type">boolean</span>[][][] boxUsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; board.length; row++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; board[<span class="hljs-number">0</span>].length; col++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[row][col] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &lt;= num &amp;&amp; num &lt;= <span class="hljs-number">9</span>) &#123;<br>                    rowUsed[row][num] = <span class="hljs-literal">true</span>;<br>                    colUsed[col][num] = <span class="hljs-literal">true</span>;<br>                    boxUsed[row / <span class="hljs-number">3</span>][col / <span class="hljs-number">3</span>][num] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 递归尝试填充数组</span><br>        helper(board, rowUsed, colUsed, boxUsed, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] rowUsed, <span class="hljs-type">boolean</span>[][] colUsed, <span class="hljs-type">boolean</span>[][][] boxUsed, <span class="hljs-type">int</span> row,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-comment">// 边界校验, 如果已经填充完成, 返回true, 表示一切结束</span><br>        <span class="hljs-keyword">if</span> (col == board[<span class="hljs-number">0</span>].length) &#123;<br>            col = <span class="hljs-number">0</span>;<br>            row++;<br>            <span class="hljs-keyword">if</span> (row == board.length) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 是空则尝试填充, 否则跳过继续尝试填充下一个位置</span><br>        <span class="hljs-keyword">if</span> (board[row][col] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 尝试填充1~9</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">9</span>; num++) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">canUsed</span> <span class="hljs-operator">=</span> !(rowUsed[row][num] || colUsed[col][num] || boxUsed[row / <span class="hljs-number">3</span>][col / <span class="hljs-number">3</span>][num]);<br>                <span class="hljs-keyword">if</span> (canUsed) &#123;<br>                    rowUsed[row][num] = <span class="hljs-literal">true</span>;<br>                    colUsed[col][num] = <span class="hljs-literal">true</span>;<br>                    boxUsed[row / <span class="hljs-number">3</span>][col / <span class="hljs-number">3</span>][num] = <span class="hljs-literal">true</span>;<br>                    board[row][col] = (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;0&#x27;</span> + num);<br>                    <span class="hljs-keyword">if</span> (helper(board, rowUsed, colUsed, boxUsed, row, col + <span class="hljs-number">1</span>)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    rowUsed[row][num] = <span class="hljs-literal">false</span>;<br>                    colUsed[col][num] = <span class="hljs-literal">false</span>;<br>                    boxUsed[row / <span class="hljs-number">3</span>][col / <span class="hljs-number">3</span>][num] = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> helper(board, rowUsed, colUsed, boxUsed, row, col + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">36. Valid Sudoku<br>37. Sudoku Solver<br>2133. Check if Every Row and Column Contains All Numbers<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 36. Valid Sudoku</title>
    <link href="/posts/1704254951.html"/>
    <url>/posts/1704254951.html</url>
    
    <content type="html"><![CDATA[<p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:<br>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p><p>Note:<br>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.</p><p>Example 1:<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="Example 1"><br>Input: board &#x3D;<br>[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>Output: true</p><p>Example 2:<br>Input: board &#x3D;<br>[[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p><p>Constraints:<br>board.length &#x3D;&#x3D; 9<br>board[i].length &#x3D;&#x3D; 9<br>board[i][j] is a digit 1-9 or ‘.’.</p><p>有效的数独。</p><blockquote>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p><p>注意：<br>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 ‘.’ 表示。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/valid-sudoku">https://leetcode.cn/problems/valid-sudoku</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的重点是如何判断数字在他所在的行、列和 3x3 宫内只出现一次。这里我们需要三个二维数组，分别记录 9 行，9 列和 9 个 3x3 宫内数字出现的情况。其中行和列的问题比较直观，重点是如何知道某个位置上的数字是属于哪个 3x3 宫。</p><p>对于任意一个数字，他在矩阵内的坐标是(i, j)，那么他的 cubeIndex &#x3D; i &#x2F; 3 * 3 + j &#x2F; 3</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(81) - O(1)<br>空间O(1) - 三个 9x9 的 boolean 数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-comment">// 数独的行、列和3x3小宫格各有9个</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br><br>        <span class="hljs-comment">// 创建3个数组，用于记录行、列和3x3小宫格中出现的数字</span><br>        <span class="hljs-type">boolean</span>[][] rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">boolean</span>[][] cols = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">boolean</span>[][] boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-comment">// 将字符转换为0-8的数字</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">boxIndex</span> <span class="hljs-operator">=</span> (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>; <span class="hljs-comment">// 计算小宫格索引</span><br><br>                    <span class="hljs-comment">// 如果当前数字在行、列或小宫格中已存在，则返回false</span><br>                    <span class="hljs-keyword">if</span> (rows[i][num] || cols[j][num] || boxes[boxIndex][num]) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 记录当前数字在行、列和小宫格中出现过</span><br>                    rows[i][num] = <span class="hljs-literal">true</span>;<br>                    cols[j][num] = <span class="hljs-literal">true</span>;<br>                    boxes[boxIndex][num] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有冲突，返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">36. Valid Sudoku<br>37. Sudoku Solver<br>2133. Check if Every Row and Column Contains All Numbers<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 378. Kth Smallest Element in a Sorted Matrix</title>
    <link href="/posts/1735083163.html"/>
    <url>/posts/1735083163.html</url>
    
    <content type="html"><![CDATA[<p>Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.</p><p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p><p>You must find a solution with a memory complexity better than O(n2).</p><p>Example 1:<br>Input: matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8<br>Output: 13<br>Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13</p><p>Example 2:<br>Input: matrix &#x3D; [[-5]], k &#x3D; 1<br>Output: -5</p><p>Constraints:<br>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.<br>1 &lt;&#x3D; k &lt;&#x3D; n2</p><p>Follow up:<br>Could you solve the problem with a constant memory (i.e., O(1) memory complexity)?<br>Could you solve the problem in O(n) time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.</p><p>有序矩阵中第 K 小的元素。</p><blockquote>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。<p>你必须找到一个内存复杂度优于 O(n2) 的解决方案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题有三种解法，1是 priority queue（超时），2 是类似23题的归并排序的做法，3是二分法。</p><h2 id="思路一-priority-queue（超时）"><a href="#思路一-priority-queue（超时）" class="headerlink" title="思路一 - priority queue（超时）"></a>思路一 - priority queue（超时）</h2><p>首先是 priority queue 的做法。如果是无脑将 matrix 中所有的元素都加入一个最小堆中然后找第 K 小的元素，时间复杂度会非常高，因为 pq 内部排序的时间就是 O(nlogn) + 遍历input的时间 O(mn)，所以时间复杂度起码是<code>O(mn)</code>起跳。注意 matrix 里面每一列也是有序的，所以这里优化的方法是将每个元素的坐标和对应的 val 做成一个三元组加入 pq，同时，pq 中只有 matrix.length 个元素进行比较。这里跑一个例子说一下吧。pq 一开始加入了 1，5，9 三个元素，弹出 1 之后，加入的是 10；第二次的比较是介于 10，5，9 之间的，会弹出 5，并且加入跟 5 同一列的 11。以此循环往复 K - 1 次之后，再下一次 poll 出来的元素就是第 K 小的元素了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Tuple&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(matrix.length, (a, b) -&gt; (a.val - b.val));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tuple</span>(<span class="hljs-number">0</span>, i, matrix[<span class="hljs-number">0</span>][i]));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">Tuple</span> <span class="hljs-variable">tuple</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-keyword">if</span> (tuple.x == matrix.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            pq.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tuple</span>(tuple.x + <span class="hljs-number">1</span>, tuple.y, matrix[tuple.x + <span class="hljs-number">1</span>][tuple.y]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> pq.poll().val;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span> &#123;<br>    <span class="hljs-type">int</span> x, y, val;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tuple</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-归并排序"><a href="#思路二-归并排序" class="headerlink" title="思路二 - 归并排序"></a>思路二 - 归并排序</h2><p>[2022年8月更新] 用类似归并排序的做法，跟 23 题很像。23 题是 K 个有序的链表，这道题是 K 个有序的数组。如果矩阵是 m x n 的尺寸，那么最小堆里最多只有 m 个元素。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(klogn)<br>空间O(m)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// [i, j, matrix[i][j]]</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 先只加入每一行的第一个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; matrix[i][<span class="hljs-number">0</span>], i, <span class="hljs-number">0</span> &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; k != <span class="hljs-number">0</span>) &#123;<br>            k--;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> val;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (y == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; matrix[x][y + <span class="hljs-number">1</span>], x, y + <span class="hljs-number">1</span> &#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路三-二分法"><a href="#思路三-二分法" class="headerlink" title="思路三 - 二分法"></a>思路三 - 二分法</h2><p>二分法的思路有一些特别。一开始找的 left 和 right 是 matrix 里面的最小值和最大值（起码这样确定了值的范围），但是在计算 mid 的时候，mid 的值很有可能不在 matrix 中，因为他不是根据坐标得来的，但是一定处于 left 和 right 之间。所以之后 <code>count()</code> 函数是在计算 matrix 中有多少个元素小于&#x2F;大于 mid，以此决定到底是 left &#x3D; mid 还是 right &#x3D; mid。<code>count()</code> 函数还是比较巧妙的，首先记住 matrix 里面每一行和每一列都是有序的。count() 函数是从 matrix 的左下角那个元素开始看，如果左下角那个元素大于 target（nums[mid]），那么说明左下角元素所在的那一行都不满足，所以要 i–；反之如果左下角那个元素小于 target（nums[mid]），那说明左下角那个元素所在的整列元素都小于 target。如果实在记不住，暴力 O(n^2) 遍历数组去数有多少个数字小于 mid 也行。</p><p>跑一下例子吧，首先找到左下角元素12，此时 target 是11，12 &gt; 11，此时只能 i–，因为12所在的那一行一定都不满足（12，13，15）；再来会在第二行看，10 &lt; 11，res +&#x3D; i + 1 &#x3D;&gt; res +&#x3D; 0 + 1 &#x3D;&gt; res +&#x3D; 1。i是10的横坐标0，又因为10上方的所有元素都一定小于10，所以比11小的元素个数是被累加到 res 上去的。</p><p><strong>注意：这里的left mid right是数值，不是索引位置</strong></p><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)，worse case O(n^2)<br>空间O(1)</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> count(matrix, mid);<br>            <span class="hljs-keyword">if</span> (num &gt;= k) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count(matrix, right) &lt;= k - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// start from bottom left corner</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target) &#123;<br>                res += i + <span class="hljs-number">1</span>;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">matrix</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span> (<span class="hljs-params">matrix, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> lo = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> hi = matrix[matrix.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;<br>        <span class="hljs-keyword">let</span> mid = lo + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((hi - lo) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; matrix.<span class="hljs-property">length</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] &lt;= mid) &#123;<br>                    count++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; k) &#123;<br>            lo = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hi = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lo;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">373. Find K Pairs with Smallest Sums<br>378. Kth Smallest Element in a Sorted Matrix<br>719. Find K-th Smallest Pair Distance<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>binary search</tag>
      
      <tag>matrix</tag>
      
      <tag>heap</tag>
      
      <tag>merge sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 733. Flood Fill</title>
    <link href="/posts/895566530.html"/>
    <url>/posts/895566530.html</url>
    
    <content type="html"><![CDATA[<p>You are given an image represented by an m x n grid of integers image, where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. Your task is to perform a flood fill on the image starting from the pixel image[sr][sc].</p><p>To perform a flood fill:</p><p>Begin with the starting pixel and change its color to color.<br>Perform the same process for each pixel that is directly adjacent (pixels that share a side with the original pixel, either horizontally or vertically) and shares the same color as the starting pixel.<br>Keep repeating this process by checking neighboring pixels of the updated pixels and modifying their color if it matches the original color of the starting pixel.<br>The process stops when there are no more adjacent pixels of the original color to update.<br>Return the modified image after performing the flood fill.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg" alt="Example 1"><br>Input: image &#x3D; [[1,1,1],[1,1,0],[1,0,1]], sr &#x3D; 1, sc &#x3D; 1, color &#x3D; 2<br>Output: [[2,2,2],[2,2,0],[2,0,1]]</p><p>Explanation:<br>From the center of the image with position (sr, sc) &#x3D; (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.</p><p>Note the bottom corner is not colored 2, because it is not horizontally or vertically connected to the starting pixel.</p><p>Example 2:<br>Input: image &#x3D; [[0,0,0],[0,0,0]], sr &#x3D; 0, sc &#x3D; 0, color &#x3D; 0<br>Output: [[0,0,0],[0,0,0]]</p><p>Explanation:<br>The starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.</p><p>Constraints:<br>m &#x3D;&#x3D; image.length<br>n &#x3D;&#x3D; image[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 50<br>0 &lt;&#x3D; image[i][j], color &lt; 216<br>0 &lt;&#x3D; sr &lt; m<br>0 &lt;&#x3D; sc &lt; n</p><p>图像渲染。</p><blockquote>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。<p>给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flood-fill">https://leetcode-cn.com/problems/flood-fill</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这一题跟之前的695和547很类似，是矩阵类型的基础题。题目给了起始位置和需要更新的颜色 newColor，思路是用 DFS 判断四个方向的坐标上是否需要被更新颜色。</p><p>如果</p><ul><li>超出矩阵范围</li><li>或者颜色跟初始坐标上的颜色（image[sr][sc]）不同</li><li>又或者已经被染色过了（已经是newColor）</li></ul><p>则直接 return。同时如果一开始给的坐标也是被染色过了的（newColor），就直接退出了，无需任何操作。因为染色的动作一定是要从当前坐标开始被触发的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n) - 栈空间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] floodFill(<span class="hljs-type">int</span>[][] image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> color) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ori</span> <span class="hljs-operator">=</span> image[sr][sc];<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (ori == color) &#123;<br>            <span class="hljs-keyword">return</span> image;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span>[][] dirs = &#123; &#123; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125; &#125;;<br>        image[sr][sc] = color;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; sr, sc &#125;);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; image.length &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; c &lt; image[<span class="hljs-number">0</span>].length &amp;&amp; image[r][c] == ori) &#123;<br>                    image[r][c] = color;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; r, c &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] floodFill(<span class="hljs-type">int</span>[][] image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> color) &#123;<br>        m = image.length;<br>        n = image[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ori</span> <span class="hljs-operator">=</span> image[sr][sc];<br>        <span class="hljs-keyword">if</span> (ori == color) &#123;<br>            <span class="hljs-keyword">return</span> image;<br>        &#125;<br>        dfs(image, sr, sc, ori, color);<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] image, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> ori, <span class="hljs-type">int</span> color)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || image[i][j] != ori) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        image[i][j] = color;<br>        dfs(image, i - <span class="hljs-number">1</span>, j, ori, color);<br>        dfs(image, i + <span class="hljs-number">1</span>, j, ori, color);<br>        dfs(image, i, j - <span class="hljs-number">1</span>, ori, color);<br>        dfs(image, i, j + <span class="hljs-number">1</span>, ori, color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 695. Max Area of Island</title>
    <link href="/posts/988496489.html"/>
    <url>/posts/988496489.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>The area of an island is the number of cells with a value 1 in the island.</p><p>Return the maximum area of an island in grid. If there is no island, return 0.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" alt="Example 1"><br>Input: grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>Output: 6<br>Explanation: The answer is not 11, because the island must be connected 4-directionally.</p><p>Example 2:<br>Input: grid &#x3D; [[0,0,0,0,0,0,0,0]]<br>Output: 0</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 50<br>grid[i][j] is either 0 or 1.</p><p>岛屿的最大面积。</p><blockquote><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island">https://leetcode-cn.com/problems/max-area-of-island</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道 flood fill 类型的题。我这里还是给出 DFS 和 BFS 两种做法。</p><p>无论是那种做法，search 一开始找的是值为 1 的坐标，这没有什么疑问。但是找到 1 之后，则需要把这个 1 当做一个岛的起点开始做 dfs。注意以下几点，同时也是 DFS 模板题都需要注意的</p><ul><li>碰到边界就 return 0</li><li>把当前坐标的值 mark 成 0（或者一个极值，看情况而定，这是为了防止重复访问造成死循环）</li><li>四个方向递归调用 DFS 函数</li></ul><p>这个题唯一多的一个步骤就是当找到第一个 1 的时候，需要把递归调用里面所有能找到的岛屿面积累加起来。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n)</p><h2 id="DFS代码"><a href="#DFS代码" class="headerlink" title="DFS代码"></a>DFS代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, dfs(i, j, grid));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &gt;= grid[i].length || grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        num += dfs(i + <span class="hljs-number">1</span>, j, grid);<br>        num += dfs(i - <span class="hljs-number">1</span>, j, grid);<br>        num += dfs(i, j + <span class="hljs-number">1</span>, grid);<br>        num += dfs(i, j - <span class="hljs-number">1</span>, grid);<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS代码"><a href="#BFS代码" class="headerlink" title="BFS代码"></a>BFS代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] dirs = &#123; &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125; &#125;;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    res = Math.max(res, helper(grid, i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>        grid[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>] + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>] + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="hljs-number">1</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; x, y &#125;);<br>                    grid[x][y] = <span class="hljs-number">0</span>;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">695. Max Area of Island<br>2658. Maximum Number of Fish in a Grid<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 994. Rotting Oranges</title>
    <link href="/posts/1521853294.html"/>
    <url>/posts/1521853294.html</url>
    
    <content type="html"><![CDATA[<p>You are given an m x n grid where each cell can have one of three values:<br>0 representing an empty cell,<br>1 representing a fresh orange, or<br>2 representing a rotten orange.<br>Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.</p><p>Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt="Example 1"><br>Input: grid &#x3D; [[2,1,1],[1,1,0],[0,1,1]]<br>Output: 4</p><p>Example 2:<br>Input: grid &#x3D; [[2,1,1],[0,1,1],[1,0,1]]<br>Output: -1<br>Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</p><p>Example 3:<br>Input: grid &#x3D; [[0,2]]<br>Output: 0<br>Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.</p><p>Constraints:<br>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>grid[i][j] is 0, 1, or 2.</p><p>腐烂的橘子。</p><blockquote><p>在给定的网格中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。<br>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotting-oranges">https://leetcode-cn.com/problems/rotting-oranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目说了是求每个烂橘子四周围的情况，所以思路也是 flood fill 类型的 BFS。这个题跟一般的 BFS 的题目不太一样的地方在于，需要考虑会不会有一直有好橘子不腐烂的情况，所以需要算一下一共有多少个好橘子 count，每次腐烂了需要减去；和需要记录遍历次数 round，因为这是需要返回的参数。</p><p>先遍历一遍 input，得到好橘子的个数 count，也将所有的坏橘子的坐标加入 queue。从 queue 中弹出的时候，判断每个坐标的上下左右是否有好橘子，若有，则把他标记为坏橘子，再放回 queue。while 循环跳出的条件是 count &#x3D;&#x3D; 0 或者 queue 为空。最后判断如果 count 不为 0 则返回 -1，说明一直有好橘子存在；否则则返回轮数 round。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="Java-BFS实现一"><a href="#Java-BFS实现一" class="headerlink" title="Java BFS实现一"></a>Java BFS实现一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; M; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">round</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty()) &#123;<br>            round++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span>[] orange = queue.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> orange[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> orange[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r - <span class="hljs-number">1</span>][c] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r - <span class="hljs-number">1</span>][c] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; r - <span class="hljs-number">1</span>, c &#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; M &amp;&amp; grid[r + <span class="hljs-number">1</span>][c] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r + <span class="hljs-number">1</span>][c] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; r + <span class="hljs-number">1</span>, c &#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r][c - <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; r, c - <span class="hljs-number">1</span> &#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; N &amp;&amp; grid[r][c + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>                    grid[r][c + <span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; r, c + <span class="hljs-number">1</span> &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> round;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Java-BFS实现二，个人觉得这种实现对坐标的管理更容易记住"><a href="#Java-BFS实现二，个人觉得这种实现对坐标的管理更容易记住" class="headerlink" title="Java BFS实现二，个人觉得这种实现对坐标的管理更容易记住"></a>Java BFS实现二，个人觉得这种实现对坐标的管理更容易记住</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, j &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[][] DIRS = &#123; &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125; &#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">round</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span> &amp;&amp; !queue.isEmpty()) &#123;<br>            round++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">int</span>[] orange = queue.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> orange[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> orange[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : DIRS) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> y + dir[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 邻居节点在矩阵内 + 是个好橘子</span><br>                    <span class="hljs-keyword">if</span> (newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; n &amp;&amp; grid[newX][newY] == <span class="hljs-number">1</span>) &#123;<br>                        count--;<br>                        grid[newX][newY] = <span class="hljs-number">2</span>;<br>                        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; newX, newY &#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> round;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">grid</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> orangesRotting = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid</span>) &#123;<br>    <span class="hljs-keyword">let</span> q = [];<br>    <span class="hljs-keyword">let</span> newFresh = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> minutes = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// push rotten oranges to the stack and count fresh oranges</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[i].<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-number">2</span>) q.<span class="hljs-title function_">push</span>([i, j]);<br>            <span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-number">1</span>) newFresh++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-property">length</span> &amp;&amp; newFresh) &#123;<br>        <span class="hljs-keyword">let</span> newQ = []; <span class="hljs-comment">// queue for next minute</span><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">let</span> badOrange = q.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">let</span> newRottens = <span class="hljs-title function_">infectOthers</span>(grid, badOrange[<span class="hljs-number">0</span>], badOrange[<span class="hljs-number">1</span>], newQ);<br>            newFresh -= newRottens;<br>        &#125;<br>        minutes++;<br>        q = newQ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newFresh !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> minutes;<br>&#125;;<br><br><span class="hljs-comment">// Infect surrounding oranges</span><br><span class="hljs-comment">// Return the number of newly infected oranges</span><br><span class="hljs-keyword">var</span> infectOthers = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid, i, j, q</span>) &#123;<br>    <span class="hljs-keyword">let</span> infected = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] === <span class="hljs-number">1</span>) &#123;<br>        grid[i - <span class="hljs-number">1</span>][j]++;<br>        infected++;<br>        q.<span class="hljs-title function_">push</span>([i - <span class="hljs-number">1</span>, j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) &#123;<br>        grid[i][j - <span class="hljs-number">1</span>]++;<br>        infected++;<br>        q.<span class="hljs-title function_">push</span>([i, j - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; grid.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] === <span class="hljs-number">1</span>) &#123;<br>        grid[i + <span class="hljs-number">1</span>][j]++;<br>        infected++;<br>        q.<span class="hljs-title function_">push</span>([i + <span class="hljs-number">1</span>, j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) &#123;<br>        grid[i][j + <span class="hljs-number">1</span>]++;<br>        infected++;<br>        q.<span class="hljs-title function_">push</span>([i, j + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> infected;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>flood fill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 78. Subsets</title>
    <link href="/posts/3792472226.html"/>
    <url>/posts/3792472226.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3]<br>Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><p>Example 2:<br>Input: nums &#x3D; [0]<br>Output: [[],[0]]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>All the numbers of nums are unique.</p><p>子集。</p><blockquote>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路还是回溯，而且模板要背下来。第八行的 sort 被省略是因为 78 题没有重复元素，然后之后的 90 题有重复元素，这一行排序就用得上了。递归函数的一开始，将子数组加入结果集，然后遍历 input，注意遍历的时候不是从 0 开始，而是从 start index 开始。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n * 2^n) - 因为最后就是有 2^n 个结果，每次进入 helper 函数的时候 list 都会被复制一次<br>空间O(n * 2^n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// Arrays.sort(nums);</span><br>        helper(res, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>            list.add(nums[i]);<br>            helper(res, list, nums, i + <span class="hljs-number">1</span>);<br>            list.remove(list.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 523. Continuous Subarray Sum</title>
    <link href="/posts/2013424535.html"/>
    <url>/posts/2013424535.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.</p><p>A good subarray is a subarray where:<br>its length is at least two, and<br>the sum of the elements of the subarray is a multiple of k.</p><p>Note that:<br>A subarray is a contiguous part of the array.<br>An integer x is a multiple of k if there exists an integer n such that x &#x3D; n * k. 0 is always a multiple of k.</p><p>Example 1:<br>Input: nums &#x3D; [23,2,4,6,7], k &#x3D; 6<br>Output: true<br>Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.</p><p>Example 2:<br>Input: nums &#x3D; [23,2,6,4,7], k &#x3D; 6<br>Output: true<br>Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.<br>42 is a multiple of 6 because 42 &#x3D; 7 * 6 and 7 is an integer.</p><p>Example 3:<br>Input: nums &#x3D; [23,2,6,4,7], k &#x3D; 13<br>Output: false</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>0 &lt;&#x3D; sum(nums[i]) &lt;&#x3D; 231 - 1<br>1 &lt;&#x3D; k &lt;&#x3D; 231 - 1</p><p>连续的子数组和。</p><blockquote>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：<p>子数组大小 至少为 2 ，且<br>子数组元素总和为 k 的倍数。<br>如果存在，返回 true ；否则，返回 false 。</p><p>如果存在一个整数 n ，令整数 x 符合 x &#x3D; n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/continuous-subarray-sum">https://leetcode.cn/problems/continuous-subarray-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p>思路是前缀和。注意题目的要求，子数组的长度至少为 2，所以类似如下这样的情形，应该是要 return false 的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">input</span>: <span class="hljs-selector-attr">[0]</span>, k = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>既然是前缀和的思路，所以还是需要创建一个 hashmap，存<code>前缀和</code>以及当前这个前缀和<code>第一次出现的下标</code>。既然是找 sum 为 k 的倍数，所以自然而然想到取模的操作。注意这里有一个关于取模的公式需要知道（引用）。如果 sum[j] - sum[i] &#x3D; n * k, 那么两边同时除以 k 我们可以得到 sum[j] &#x2F; k - sum[i] &#x2F; k &#x3D; n。如果要使这个等式成立，我们需要满足 sum[j] % k &#x3D;&#x3D; sum[i] % k。</p><p>所以我们在得到每一个前缀和之后，我们做 sum %&#x3D; k，把余数当做 key 存入 hashmap。当我们再次遇到一个相同的 key 的时候，我们再判断这个 key 上一次出现的位置是否在两个位置以外即可。</p><p>另外一道跟前缀和 + 取模有关的题是 974 题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkSubarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            sum = (sum + num) % k;<br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                sum += k;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.containsKey(sum)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> map.get(sum);<br>                <span class="hljs-keyword">if</span> (i - lastIndex &gt;= <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(sum, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> checkSubarraySum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    map.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += nums[i];<br>        <span class="hljs-keyword">if</span> (k !== <span class="hljs-number">0</span>) &#123;<br>            sum %= k;<br>        &#125;<br>        <span class="hljs-keyword">let</span> prev = map.<span class="hljs-title function_">get</span>(sum);<br>        <span class="hljs-keyword">if</span> (prev !== <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i - prev &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(sum, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">523. Continuous Subarray Sum<br>974. Subarray Sums Divisible by K<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>prefix sum</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 560. Subarray Sum Equals K</title>
    <link href="/posts/135141854.html"/>
    <url>/posts/135141854.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.</p><p>A subarray is a contiguous non-empty sequence of elements within an array.</p><p>Example 1:<br>Input: nums &#x3D; [1,1,1], k &#x3D; 2<br>Output: 2</p><p>Example 2:<br>Input: nums &#x3D; [1,2,3], k &#x3D; 3<br>Output: 2</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>-107 &lt;&#x3D; k &lt;&#x3D; 107</p><p>和为 K 的子数组。</p><blockquote>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<p>子数组是数组中元素的连续非空序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k">https://leetcode.cn/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-暴力解"><a href="#思路一-暴力解" class="headerlink" title="思路一 - 暴力解"></a>思路一 - 暴力解</h2><p>题意是给一个数组和一个数字 K，请求出 input 数组中有多少个子数组的和为 K。两种做法，一种是暴力解；一种会用到 hashmap。</p><p>暴力解的思路是用两个 for loop 扫描 input 数组，扫描的时候记录累加和 sum，再用一个变量记录是否有满足条件的子数组满足 sum &#x3D;&#x3D; k，若有就++。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subarraySum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; nums.<span class="hljs-property">length</span>; j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-keyword">if</span> (sum === k) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-前缀和"><a href="#思路二-前缀和" class="headerlink" title="思路二 - 前缀和"></a>思路二 - 前缀和</h2><p>用一个数组 sum 记录从 0 到 i 之间所有元素的累积总和。如果累积总和在索引 i 和索引 j 之间相差 k，即 sum[i] - sum[j] &#x3D; k，则位于索引 i 和索引 j 之间的元素之和是 k。</p><p>根据这个思路，我们可以用 hashmap 记录数组所有的前 N 项的前缀和。key 是前缀和，value 是这个前缀和出现的次数。扫描的时候，如果 map 存在 sum（下图黄色部分） 和 sum - k（下图红色部分），就说明有满足条件的子数组，因为他们的差值是 k。同时因为数组可能存在负数的关系，加入前缀和的时候需要判断 key 是否存在过。举个例子，比如前 N 项的和是 sum，前 N-1 项的和是 sum - k，那么前 N 项的和 - 前 N-1 项的和 &#x3D; K。</p><p><span style="background:yellow">x, x, x, x, x, x, x, x</span> - sum<br><span style="background:red">x, x, x, x, x, x, x</span>, k - sum - k</p><p>这个思路很好，能帮助解决很多求子数组，子区间的问题。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// &lt;unique的前缀和，这个前缀和出现了多少次&gt;</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(sum - k)) &#123;<br>                res += map.get(sum - k);<br>            &#125;<br>            map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subarraySum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]);<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += nums[i];<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(sum - k)) &#123;<br>            count += map.<span class="hljs-title function_">get</span>(sum - k);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-title function_">has</span>(sum)) &#123;<br>            map.<span class="hljs-title function_">set</span>(sum, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(sum, map.<span class="hljs-title function_">get</span>(sum) + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 525. Contiguous Array</title>
    <link href="/posts/357721324.html"/>
    <url>/posts/357721324.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.</p><p>Example 1:<br>Input: nums &#x3D; [0,1]<br>Output: 2<br>Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.</p><p>Example 2:<br>Input: nums &#x3D; [0,1,0]<br>Output: 2<br>Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>nums[i] is either 0 or 1.</p><p>连续数组。</p><blockquote>给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/contiguous-array">https://leetcode.cn/problems/contiguous-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题目看似简单但是这个思路比较难想到。这个题的 tag 是 hash table，感觉可以往前缀和为 0 的思路上去靠。题目问的是包含相同数量的 0 和 1 的子数组的长度，这里我们需要灵活运用前缀和这个思路。如果把 0 替换成 -1，也就把题目转化为满足条件的子数组的和会是 0，因为 -1 和 1 是成对出现的。所以做法是创建一个 hashmap 记录前缀和和他最后一次出现的位置的 index。扫描的时候就按照加前缀和的方式做，当遇到某一个前缀和 X 已经存在于 hashmap 的时候，就知道这一段区间内的子数组的和为 0 了，否则这个前缀和不可能重复出现。举个例子，比如 [0,1,0] 好了，一开始往 hashmap 存入了初始值 0 和他的下标 -1（这是大多数前缀和的题都需要做的初始化），当遍历完前两个元素 0（-1）和1之后，此时又得到这个 prefix sum &#x3D; 0，此时去看一下 i - map.get(sum) 的值是否能更大，以得出这个最长的子数组的长度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>sum += (nums[i] == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (map.containsKey(sum)) &#123;<br>res = Math.max(res, i - map.get(sum));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>map.put(sum, i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findMaxLength = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    map.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += nums[i] == <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(sum)) &#123;<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, i - map.<span class="hljs-title function_">get</span>(sum));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(sum, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 362. Design Hit Counter</title>
    <link href="/posts/3607955859.html"/>
    <url>/posts/3607955859.html</url>
    
    <content type="html"><![CDATA[<p>Design a hit counter which counts the number of hits received in the past 5 minutes.</p><p>Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.</p><p>It is possible that several hits arrive roughly at the same time.</p><p>Example:<br>HitCounter counter &#x3D; new HitCounter();</p><p>&#x2F;&#x2F; hit at timestamp 1.<br>counter.hit(1);</p><p>&#x2F;&#x2F; hit at timestamp 2.<br>counter.hit(2);</p><p>&#x2F;&#x2F; hit at timestamp 3.<br>counter.hit(3);</p><p>&#x2F;&#x2F; get hits at timestamp 4, should return 3.<br>counter.getHits(4);</p><p>&#x2F;&#x2F; hit at timestamp 300.<br>counter.hit(300);</p><p>&#x2F;&#x2F; get hits at timestamp 300, should return 4.<br>counter.getHits(300);</p><p>&#x2F;&#x2F; get hits at timestamp 301, should return 3.<br>counter.getHits(301);<br>Follow up:<br>What if the number of hits per second could be very large? Does your design scale?</p><p>敲击计数器。</p><blockquote><p>设计一个敲击计数器，使它可以统计在过去5分钟内被敲击次数。每个函数会接收一个时间戳参数（以秒为单位），你可以假设最早的时间戳从1开始，且都是按照时间顺序对系统进行调用（即时间戳是单调递增）。在同一时刻有可能会有多次敲击。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两种思路。</p><ol><li>用一个 queue 记录每次敲击的 timestamp，当试图访问 getHits 函数的时候，查看 queue 头部的元素的 timestamp 和当前 timestamp 是否差值大于 300，若大于则说明无效了，需要弹出 queue 中所有跟目前 timestamp 差值大于 300 的元素，queue 的 size 则是过去五分钟内的敲击次数。</li></ol><p>这个做法在遇到一些极端的 case 的时候会有问题，比如 time &#x3D; 1 的时候我敲击了一次，但是 time &#x3D; 5 的时候我敲击了一万次，time &#x3D; 6 的时候我又敲击了两万次。这样重复多次，如果在 300 秒以内有太多上万次的敲击，queue 可能会存不下。所以参见方法二的优化。</p><ol start="2"><li>用两个数组 times 和 hits，分别记录敲击的时间和次数。敲击的时候，先用 <code>timestamp % 300</code>，这样我们就可以直接跳过 <code>timestamp - 300</code> 甚至更早于这个时间点的敲击了。如果 timestamp 做模运算的那个位置上有值但是不等于当前的 timestamp，说明这个位置上的 timestamp 是 五分钟以前甚至更早的，此时我们可以直接把这个位置的数字重置为 1。若小于300秒则直接在hits同样位置++，说明这依然是五分钟以内的敲击，同时在times数组内记录最新的timestamp。统计敲击次数的时候，是遍历hits数组，若hits[i]不为0，则判断当前i位置上times和timestamp的差值是否又大于300，若大于则不能加入结果集。</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(300) - O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HitCounter</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] hits;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] times;<br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HitCounter</span><span class="hljs-params">()</span> &#123;<br>hits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">300</span>];<br>times = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">300</span>];<br>&#125;<br><br><span class="hljs-comment">/** Record a hit.</span><br><span class="hljs-comment">    <span class="hljs-doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hit</span><span class="hljs-params">(<span class="hljs-type">int</span> timestamp)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> timestamp % <span class="hljs-number">300</span>;<br><span class="hljs-keyword">if</span> (times[index] != timestamp) &#123;<br>times[index] = timestamp;<br>hits[index] = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>hits[index]++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/** Return the number of hits in the past 5 minutes.</span><br><span class="hljs-comment">    <span class="hljs-doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHits</span><span class="hljs-params">(<span class="hljs-type">int</span> timestamp)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (timestamp - times[i] &lt; <span class="hljs-number">300</span>) &#123;<br>total += hits[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> total;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your HitCounter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * HitCounter obj = new HitCounter();</span><br><span class="hljs-comment"> * obj.hit(timestamp);</span><br><span class="hljs-comment"> * int param_2 = obj.getHits(timestamp);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">362. Design Hit Counter<br>933. Number of Recent Calls<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 25. Reverse Nodes in k-Group</title>
    <link href="/posts/423135070.html"/>
    <url>/posts/423135070.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p><p>You may not alter the values in the list’s nodes, only nodes themselves may be changed.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>Output: [2,1,4,3,5]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="Example 2"><br>Input: head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>Output: [3,2,1,4,5]</p><p>Constraints:<br>The number of nodes in the list is n.<br>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 5000<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>Follow-up: Can you solve the problem in O(1) extra memory space?</p><p>K 个一组翻转链表。</p><blockquote>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">https://leetcode.cn/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意不难理解，这里我提供一个迭代的思路。递归也可以做，但是递归的思路很容易错。</p><p>迭代的思路是设置两个 pointer，start 和 end，卡住需要翻转的部分，同时需要记录一个 pre 节点（需要翻转的部分之前的一个节点）和一个 nextStart 节点（需要翻转的部分之后的一个节点）。这样翻转完了之后不至于丢失前后的 node。<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/">一个很好的图示</a>，帮助理解。思路如下，</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crystal">步骤分解:<br><br>链表分区为已翻转部分+待翻转部分+未翻转部分<br>每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定<br>需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来<br>初始需要两个变量 pre 和 <span class="hljs-keyword">end</span>，pre 代表待翻转链表的前驱，<span class="hljs-keyword">end</span> 代表待翻转链表的末尾<br>经过k此循环，<span class="hljs-keyword">end</span> 到达末尾，记录待翻转链表的后继 <span class="hljs-keyword">next</span> = <span class="hljs-keyword">end</span>.<span class="hljs-keyword">next</span><br>翻转链表，然后将三部分链表连接起来，然后重置 pre 和 <span class="hljs-keyword">end</span> 指针，然后进入下一次循环<br>特殊情况，当翻转部分长度不足 k 时，在定位 <span class="hljs-keyword">end</span> 完成后，<span class="hljs-keyword">end</span>==null，已经到达末尾，说明题目已完成，直接返回即可<br>时间复杂度为 O(n*K)O(n∗K) 最好的情况为 O(n) 最差的情况为 O(n^<span class="hljs-number">2</span>)<br>空间复杂度为 O(<span class="hljs-number">1</span>) 除了几个必须的节点指针外，我们并没有占用其他空间<br>作者：reals<br>链接：<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/leetcode-cn.com/problems</span><span class="hljs-regexp">/reverse-nodes-in-k-group/solution</span><span class="hljs-regexp">/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2) - worst case<br>空间O(1) - 题目要求不使用额外空间</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-comment">// pre是翻转部分之前的node</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (end != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">null</span>; i++) &#123;<br>                end = end.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextStart</span> <span class="hljs-operator">=</span> end.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next;<br>            <span class="hljs-comment">// 先跟后面的部分断开以便reverse当前这K个节点</span><br>            end.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// reverse完毕之后，跟pre节点连接起来</span><br>            pre.next = reverse(start);<br>            <span class="hljs-comment">// 此时start是已经反转的部分的最后一个节点，需要连到下一段需要反转的部分的开头</span><br>            start.next = nextStart;<br>            pre = start;<br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 24. Swap Nodes in Pairs</title>
    <link href="/posts/771654464.html"/>
    <url>/posts/771654464.html</url>
    
    <content type="html"><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p><p>Example 1:<br>Input: head &#x3D; [1,2,3,4]<br>Output: [2,1,4,3]</p><p>Explanation:<br><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="Example 1"></p><p>Example 2:<br>Input: head &#x3D; []<br>Output: []</p><p>Example 3:<br>Input: head &#x3D; [1]<br>Output: [1]</p><p>Example 4:<br>Input: head &#x3D; [1,2,3]<br>Output: [2,1,3]</p><p>Constraints:<br>The number of nodes in the list is in the range [0, 100].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>两两交换链表中的节点。</p><blockquote>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的思路是迭代。依然是给一个 dummy 节点，然后 dummy.next &#x3D; head，nextStart 是第三个节点，需要交换的只是 l2 和 l2.next，l1 永远是需要 swap 的两个节点之前的那个节点，他不参与 swap。每次交换完了之后只往前挪动一个节点的距离。我画了一个示意图，这样不容易错。我参考了<a href="https://leetcode.wang/leetCode-24-Swap-Nodes-in-Pairs.html">这个帖子</a>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dummy</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span><br><span class="hljs-attribute">l1</span>      l2         ns<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (l2 != <span class="hljs-literal">null</span> &amp;&amp; l2.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextStart</span> <span class="hljs-operator">=</span> l2.next.next;            <span class="hljs-comment">// 记住3在什么地方</span><br>            l1.next = l2.next;                            <span class="hljs-comment">// dummy -&gt; 2</span><br>            l2.next.next = l2;                            <span class="hljs-comment">// 2 -&gt; 1</span><br>            l2.next = nextStart;                        <span class="hljs-comment">// 1 -&gt;3</span><br>            <span class="hljs-comment">// 此时</span><br>            <span class="hljs-comment">// dummy -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4</span><br>            <span class="hljs-comment">// l1            l2</span><br>            l1 = l2;                                    <span class="hljs-comment">// l1移动到1</span><br>            l2 = l2.next;                                <span class="hljs-comment">// l2移动到2</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span><br><span class="hljs-comment">l1       l2        ns</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> swapPairs = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> l1 = dummy;<br>    <span class="hljs-keyword">let</span> l2 = head;<br>    <span class="hljs-keyword">while</span> (l2 !== <span class="hljs-literal">null</span> &amp;&amp; l2.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">let</span> nextStart = l2.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        l1.<span class="hljs-property">next</span> = l2.<span class="hljs-property">next</span>;<br>        l2.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = l2;<br>        l2.<span class="hljs-property">next</span> = nextStart;<br>        l1 = l2;<br>        l2 = l2.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 424. Longest Repeating Character Replacement</title>
    <link href="/posts/824845836.html"/>
    <url>/posts/824845836.html</url>
    
    <content type="html"><![CDATA[<p>You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.</p><p>Return the length of the longest substring containing the same letter you can get after performing the above operations.</p><p>Example 1:<br>Input: s &#x3D; “ABAB”, k &#x3D; 2<br>Output: 4<br>Explanation: Replace the two ‘A’s with two ‘B’s or vice versa.</p><p>Example 2:<br>Input: s &#x3D; “AABABBA”, k &#x3D; 1<br>Output: 4<br>Explanation: Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”.<br>The substring “BBBB” has the longest repeating letters, which is 4.<br>There may exists other ways to achieve this answer too.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of only uppercase English letters.<br>0 &lt;&#x3D; k &lt;&#x3D; s.length</p><p>替换后的最长重复字符。</p><blockquote>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。<p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-repeating-character-replacement">https://leetcode.cn/problems/longest-repeating-character-replacement</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个字符串，只有大写字母，允许你替换其中的 k 个字母，问替换操作完成后能返回的最长字母相同的子串的长度是多少。既然是看替换 k 个字母之后能组成的相同字母的子串的长度，所以思路还是偏向滑动窗口。那么替换字母的原则应该是先统计目前每个不同字母的出现次数，然后用 k 尽量去替换成那个出现最多次数的字母，看看是否能组成最长的子串。具体做法如下</p><ul><li>创建一个 map 记录 s 中每个字母和他们的出现次数</li><li>创建两个指针 start 和 end 准备卡住窗口</li><li>end 先移动，并同时用一个变量 max 找到当下最大的出现次数</li><li>如果当前窗口 size - k &gt; max，则考虑缩小窗口尺寸，挪动 start 指针</li><li>窗口 size 缩减到小于 max + k 之后，记录一个当前窗口的值，这个值就是替换了 k 个字符之后能组成的最长重复子串的长度</li></ul><p>这个题我在做的时候有个疑问，为什么通过滑动窗口找到的这个最长子串的长度是对的呢？我举了个反例，比如 s 是 ABCDEFGA 好了，k &#x3D; 2，出现次数最多的字母依然是 A。按照上面的算法，直到扫到 input 的最后才会发现出现次数最多的字母是 A，既然 k 是 2，所以无论你替换别的任何字母，最后跟 A 凑成最长的子串都一定是 1 + 2 &#x3D; 3，因为前后两个 A 是凑不到一起的。</p><p>这个例子只能证明滑动窗口可以解决这道题，并没有回答另一个疑问：最长的子串里面一定包含出现次数最多的字母，这个没有什么疑问。但是左指针在往前走，试图缩短窗口尺寸的时候，会不会造成额外的问题？答案是不会。我参考了<a href="https://leetcode.com/problems/longest-repeating-character-replacement/discuss/91271/Java-12-lines-O(n)-sliding-window-solution-with-explanation/137008">这个帖子</a>。右指针停下的位置一定是当前出现次数最多的字母的位置。如果此时左指针开始往前走（试图缩短窗口尺寸），虽然随着左指针往前走，出现次数最多的字母的次数（最多次数）会被减少，但是并不影响这个字母是出现次数最多的字母的事实。目前需要找的窗口大小依然是基于这个出现次数最多的字母而找的。</p><p>第三个疑问是按照代码里跑的方式，start 和 end 指针中间也许不会包含出现次数最多的那个字母所有出现的地方，比如我们发现 max &#x3D; 5，但是 start 和 end 之间也许并不会包含那个字母 5 次，这种情况下，代码是让 start 和 end 指针同时往前走的，只要两个指针的距离没变，结果就是对的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            map[c1]++;<br>            max = Math.max(max, map[c1]);<br>            end++;<br>            <span class="hljs-keyword">while</span> (end - start - max &gt; k) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2]--;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> characterReplacement = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, k</span>) &#123;<br><span class="hljs-keyword">let</span> count = &#123;&#125;;<br><span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>; end &lt; s.<span class="hljs-property">length</span>; end++) &#123;<br>count[s[end]] = count[s[end]] + <span class="hljs-number">1</span> || <span class="hljs-number">1</span>;<br>max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, count[s[end]]);<br><span class="hljs-keyword">if</span> (end - start + <span class="hljs-number">1</span> - max &gt; k) &#123;<br>count[s[start]]--;<br>start++;<br>&#125;<br>res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, end - start + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 209. Minimum Size Subarray Sum</title>
    <link href="/posts/4170399115.html"/>
    <url>/posts/4170399115.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p><p>Example 1:<br>Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>Output: 2<br>Explanation: The subarray [4,3] has the minimal length under the problem constraint.</p><p>Example 2:<br>Input: target &#x3D; 4, nums &#x3D; [1,4,4]<br>Output: 1</p><p>Example 3:<br>Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]<br>Output: 0</p><p>Constraints:<br>1 &lt;&#x3D; target &lt;&#x3D; 109<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).</p><p>长度最小的子数组。</p><blockquote>给定一个含有 n 个正整数的数组和一个正整数 target 。<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum">https://leetcode.cn/problems/minimum-size-subarray-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><p>还是 sliding window 的思路做。给两个指针 left 和 right，也用一个变量 sum 记录遍历到的数字们的加和。遍历的时候一开始也是只移动右指针，当 sum &gt;&#x3D; target 的时候，开始试图移动左指针。所谓的最短的子数组也就是左右指针的距离最短，所以每次当 sum &gt;&#x3D; target 的时候，需要记录 right - left 的值。注意有可能最后是找不到一个子数组满足其 sum &gt;&#x3D; target 的，如果是这种情况，需要输出 0。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; nums.length) &#123;<br>            sum += nums[end];<br>            end++;<br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>                res = Math.min(res, end - start);<br>                sum -= nums[start];<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minSubArrayLen = <span class="hljs-keyword">function</span> (<span class="hljs-params">target, nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; nums.<span class="hljs-property">length</span>) &#123;<br>        sum += nums[right];<br>        right++;<br>        <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(res, right - left);<br>            sum -= nums[left];<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res === <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span> ? <span class="hljs-number">0</span> : res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sliding window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 438. Find All Anagrams in a String</title>
    <link href="/posts/1543913520.html"/>
    <url>/posts/1543913520.html</url>
    
    <content type="html"><![CDATA[<p>Given two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Example 1:<br>Input: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>Output: [0,6]<br>Explanation:<br>The substring with start index &#x3D; 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index &#x3D; 6 is “bac”, which is an anagram of “abc”.</p><p>Example 2:<br>Input: s &#x3D; “abab”, p &#x3D; “ab”<br>Output: [0,1,2]<br>Explanation:<br>The substring with start index &#x3D; 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index &#x3D; 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index &#x3D; 2 is “ab”, which is an anagram of “ab”.</p><p>Constraints:<br>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104<br>s and p consist of lowercase English letters.</p><p>找到字符串中所有字母异位词。</p><blockquote>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string">https://leetcode.cn/problems/find-all-anagrams-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。思路是滑动窗口（sliding window）。这个题也可以用之前的模板做，参见76，159，340。先遍历p，得到 p 中每个字母和他们对应的出现次数。再去遍历 s，用 start 和 end 指针，end 在前，当某个字母的出现次数被减少到 0 的时候，counter 才能–。当 counter &#x3D;&#x3D; 0 的时候，判断 end - begin 是否等于p的长度，若是，才能将此时 begin 的坐标加入结果集。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : p.toCharArray()) &#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> p.length();<br>        <br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s.length() &lt; p.length()) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span> (map[c1] &gt; <span class="hljs-number">0</span>) &#123;<br>                counter--;<br>            &#125;<br>            map[c1]--;<br>            end++;<br>            <span class="hljs-keyword">while</span> (counter == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2]++;<br>                <span class="hljs-keyword">if</span> (map[c2] &gt; <span class="hljs-number">0</span>) &#123;<br>                    counter++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (end - start == p.length()) &#123;<br>                    res.add(start);<br>                &#125;<br>                start++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">p</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findAnagrams = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, p</span>) &#123;<br><span class="hljs-keyword">let</span> res = [];<br><span class="hljs-keyword">if</span> (p.<span class="hljs-property">length</span> &gt; s.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> p) &#123;<br>map.<span class="hljs-title function_">set</span>(c, (map.<span class="hljs-title function_">get</span>(c) | <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> begin = <span class="hljs-number">0</span>,<br>end = <span class="hljs-number">0</span>,<br>counter = map.<span class="hljs-property">size</span>;<br><span class="hljs-keyword">while</span> (end &lt; s.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">let</span> c = s.<span class="hljs-title function_">charAt</span>(end);<br><span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(c)) &#123;<br>map.<span class="hljs-title function_">set</span>(c, map.<span class="hljs-title function_">get</span>(c) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(c) === <span class="hljs-number">0</span>) &#123;<br>counter--;<br>&#125;<br>&#125;<br>end++;<br><span class="hljs-keyword">while</span> (counter === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">let</span> d = s.<span class="hljs-title function_">charAt</span>(begin);<br><span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(d)) &#123;<br>map.<span class="hljs-title function_">set</span>(d, map.<span class="hljs-title function_">get</span>(d) + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(d) &gt; <span class="hljs-number">0</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (end - begin == p.<span class="hljs-property">length</span>) &#123;<br>res.<span class="hljs-title function_">push</span>(begin);<br>&#125;<br>begin++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 159. Longest Substring with At Most Two Distinct Characters</title>
    <link href="/posts/2079065207.html"/>
    <url>/posts/2079065207.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s, return the length of the longest substring that contains at most two distinct characters.</p><p>Example 1:<br>Input: s &#x3D; “eceba”<br>Output: 3<br>Explanation: The substring is “ece” which its length is 3.</p><p>Example 2:<br>Input: s &#x3D; “ccaabbb”<br>Output: 5<br>Explanation: The substring is “aabbb” which its length is 5.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s consists of English letters.</p><p>至多包含两个不同字符的最长子串。</p><blockquote>题意是给一个字符串，请返回一个最长子串的长度，子串至多包含两个不同字符的最长子串。</blockquote><h2 id="思路-滑动窗口，类似76题"><a href="#思路-滑动窗口，类似76题" class="headerlink" title="思路 - 滑动窗口，类似76题"></a>思路 - 滑动窗口，类似76题</h2><p>这题依然是用到 sliding window 的思想。给左右两个指针，并且创建一个 hashmap，key 是遍历到的字母，value 是字母最后一次出现位置的 index。扫描的时候，一开始只让右指针移动，把遍历到的字母和当前的坐标值加入hashmap。此时最大子串的长度就是左右指针的间距。当右指针遍历到第三个不同字母的时候，需要扫描hashmap，找到value（记为leftmost）最小的那个key并且删除这个键值对。此时左指针的位置是leftmost + 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1) - 虽然有 hashmap 但是 size 很小，只有 26 个字母</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstringTwoDistinct</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span> (map[c1] == <span class="hljs-number">0</span>) &#123;<br>                counter++;<br>            &#125;<br>            map[c1]++;<br>            end++;<br>            <span class="hljs-keyword">while</span> (counter &gt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2]--;<br>                <span class="hljs-keyword">if</span> (map[c2] == <span class="hljs-number">0</span>) &#123;<br>                    counter--;<br>                &#125;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstringTwoDistinct = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) &#123;<br>        map.<span class="hljs-title function_">set</span>(s[right], right);<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-property">size</span> &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">let</span> leftMostChar = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">let</span> leftMostIndex = <span class="hljs-title class_">Infinity</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [char, index] <span class="hljs-keyword">of</span> map) &#123;<br>                <span class="hljs-keyword">if</span> (index &lt; leftMostIndex) &#123;<br>                    leftMostChar = char;<br>                    leftMostIndex = index;<br>                &#125;<br>            &#125;<br>            map.<span class="hljs-title function_">delete</span>(leftMostChar);<br>            left = leftMostIndex + <span class="hljs-number">1</span>;<br>        &#125;<br>        max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, right - left + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 340. Longest Substring with At Most K Distinct Characters</title>
    <link href="/posts/1151287680.html"/>
    <url>/posts/1151287680.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.</p><p>Example 1:<br>Input: s &#x3D; “eceba”, k &#x3D; 2<br>Output: 3<br>Explanation: The substring is “ece” with length 3.</p><p>Example 2:<br>Input: s &#x3D; “aa”, k &#x3D; 1<br>Output: 2<br>Explanation: The substring is “aa” with length 2.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>0 &lt;&#x3D; k &lt;&#x3D; 50</p><p>至多包含K个不同字符的最长子串。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题跟 159 题一模一样，无非是把最多两个字母改成了最多 K 个字母。还是 sliding window 的思路做。不熟悉的话可以先做 159 题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1) - 只是一个256位长度的数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstringKDistinct</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span> (map[c1] == <span class="hljs-number">0</span>) &#123;<br>                counter++;<br>            &#125;<br>            map[c1]++;<br>            end++;<br>            <span class="hljs-keyword">while</span> (counter &gt; k) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>                map[c2]--;<br>                <span class="hljs-keyword">if</span> (map[c2] == <span class="hljs-number">0</span>) &#123;<br>                    counter--;<br>                &#125;<br>                start++;<br>            &#125;<br>            res = Math.max(res, end - start);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstringKDistinct = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, k</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> maxLen = -<span class="hljs-title class_">Infinity</span>;<br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">while</span> (end &lt; s.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> c1 = s.<span class="hljs-title function_">charAt</span>(end);<br>        <span class="hljs-keyword">if</span> (map[c1] == <span class="hljs-literal">null</span> || map[c1] &lt;= <span class="hljs-number">0</span>) &#123;<br>            counter++;<br>        &#125;<br>        map[c1] = map[c1] + <span class="hljs-number">1</span> || <span class="hljs-number">1</span>;<br>        end++;<br>        <span class="hljs-keyword">while</span> (counter &gt; k) &#123;<br>            <span class="hljs-keyword">let</span> c2 = s.<span class="hljs-title function_">charAt</span>(start);<br>            <span class="hljs-keyword">if</span> (map[c2] == <span class="hljs-number">1</span>) &#123;<br>                counter--;<br>            &#125;<br>            map[c2]--;<br>            start++;<br>        &#125;<br>        maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLen, end - start);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 3. Longest Substring Without Repeating Characters</title>
    <link href="/posts/3910559116.html"/>
    <url>/posts/3910559116.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s, find the length of the longest substring without repeating characters.</p><p>Example 1:<br>Input: s &#x3D; “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.</p><p>Example 2:<br>Input: s &#x3D; “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p><p>Example 3:<br>Input: s &#x3D; “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>Notice that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><p>Example 4:<br>Input: s &#x3D; “”<br>Output: 0</p><p>Constraints:<br>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s consists of English letters, digits, symbols and spaces.</p><p>最长无重复字符的子串。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个 input 字符串，请输出其最长的，没有重复字符的子串的长度。这是two pointer追击型指针&#x2F;sliding window的基础题。</p><p>思路是用一个 hashmap 或者 hashset 以及两个指针 i 和 j，其中 i 指针在左边，j 指针在右边，j 指针每次看当前遍历到的 character 是否在 hashset 中出现过，此时有两种情况</p><ul><li>如果没出现过则将当前这个字符串加入 hashset 并且 j++，同时每次更新一下此时此刻两个指针之间的距离 res，这就是满足题意的子串的长度</li><li>如果出现过则将 i 指针指向的字母从 hashset 中删除并且 i++</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - hashset</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (!set.contains(c)) &#123;<br>                set.add(c);<br>                i++;<br>                res = Math.max(res, i - j);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set.remove(s.charAt(j));<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span> (map[s[j]]) &#123;<br>            map[s[i]] = <span class="hljs-literal">false</span>;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map[s[j]] = <span class="hljs-literal">true</span>;<br>            res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, j - i + <span class="hljs-number">1</span>);<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">3. Longest Substring Without Repeating Characters<br>1695. Maximum Erasure Value<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 76. Minimum Window Substring</title>
    <link href="/posts/2236387316.html"/>
    <url>/posts/2236387316.html</url>
    
    <content type="html"><![CDATA[<p>Given two strings s and t of lengths m and n respectively, return the minimum window<br>substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string “”.</p><p>The testcases will be generated such that the answer is unique.</p><p>Example 1:<br>Input: s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>Output: “BANC”<br>Explanation: The minimum window substring “BANC” includes ‘A’, ‘B’, and ‘C’ from string t.</p><p>Example 2:<br>Input: s &#x3D; “a”, t &#x3D; “a”<br>Output: “a”<br>Explanation: The entire string s is the minimum window.</p><p>Example 3:<br>Input: s &#x3D; “a”, t &#x3D; “aa”<br>Output: “”<br>Explanation: Both ‘a’s from t must be included in the window.<br>Since the largest window of s only has one ‘a’, return empty string.</p><p>Constraints:<br>m &#x3D;&#x3D; s.length<br>n &#x3D;&#x3D; t.length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>s and t consist of uppercase and lowercase English letters.</p><p>Follow up: Could you find an algorithm that runs in O(m + n) time?</p><p>最小覆盖子串。</p><blockquote>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。<p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-window-substring">https://leetcode-cn.com/problems/minimum-window-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路依然是滑动窗口（sliding window），<mark>这个题解是具有普适性的，<a href="https://leetcode.com/problems/minimum-window-substring/solutions/26808/Here-is-a-10-line-template-that-can-solve-most-'substring'-problems/comments/25816/">可以套用到多个 LC 的题目中</a></mark>。如下是几个细节，</p><ul><li>创建一个hashmap，记录T中出现的字母及其次数</li><li>创建一个变量count去记录T的长度</li><li>创建两个指针left和right，一前一后扫描S，right在前，left在后，去卡S里面的子串，看这个子串里面是否包含T中所有的字符</li><li>最后跳出循环的条件是right已经扫描完整个S的长度</li></ul><p>扫描的一开始，是 right 指针往前走，每遇到一个字符，无论他在不在 T 中，就都去 map 中 – 这个字符；如果这个字符在 T 中也有，同时也要去 count–。当 count &#x3D;&#x3D; 0 的时候，证明此时的子串已经包含了 T 中所有的字母了，可以考虑缩减 start 和 end 之间的距离了。缩减的条件是 while (count &#x3D;&#x3D; 0)，去看 end - start 是否能缩短那个最小长度 minLen，同时开始挪动 start 指针；若能缩短，也要记录一个变量 minStart，这样就能记住最短的子串到底从什么位置开始的。挪动 start 指针的时候也要去 map 中补足当前遍历到的字符的出现次数。如果当前字符在 map 中的 value 大于 0 了，count 也需要++，因为这说明有一个字符已经不在子串中了，此时会跳出 while 循环。最后最短子串是 s.substring(minStart, minStart + minLen)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br><span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>map[c]++;<br>&#125;<br><span class="hljs-comment">// end指针在右边，start指针在左边</span><br><span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最短子串的起点</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minStart</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最短子串的长度</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> t.length();<br><span class="hljs-keyword">while</span> (end &lt; s.length()) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(end);<br><span class="hljs-keyword">if</span> (map[c1] &gt; <span class="hljs-number">0</span>) &#123;<br>counter--;<br>&#125;<br>map[c1]--;<br>end++;<br><span class="hljs-comment">// 如果找到了所有t中的字符，可以试着缩小窗口的距离了</span><br><span class="hljs-keyword">while</span> (counter == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 试图更新最短子串的长度和起点</span><br><span class="hljs-keyword">if</span> (minLen &gt; end - start) &#123;<br>minLen = end - start;<br>minStart = start;<br>&#125;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(start);<br>map[c2]++;<br>start++;<br><span class="hljs-keyword">if</span> (map[c2] &gt; <span class="hljs-number">0</span>) &#123;<br>counter++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(minStart, minStart + minLen);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">t</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minWindow = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) &#123;<br><span class="hljs-keyword">let</span> ans = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">// save all the letters in t to a hashmap</span><br><span class="hljs-keyword">let</span> map = &#123;&#125;;<br>t.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">ch</span> =&gt;</span> (map[ch] = (map[ch] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>));<br><span class="hljs-keyword">let</span> count = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(map).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// traverse s</span><br><span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> r = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (r &lt; s.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// l~r contains t</span><br><span class="hljs-keyword">if</span> (!ans || r - l + <span class="hljs-number">1</span> &lt; ans.<span class="hljs-property">length</span>) &#123;<br>ans = s.<span class="hljs-title function_">slice</span>(l, r + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// get rid of curr ch and then move l</span><br><span class="hljs-keyword">if</span> (map[s[l]] !== <span class="hljs-literal">undefined</span>) &#123;<br>map[s[l]]++;<br>&#125;<br><span class="hljs-keyword">if</span> (map[s[l]] &gt; <span class="hljs-number">0</span>) &#123;<br>count++;<br>&#125;<br>l++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// l~r doesn&#x27;t contain t</span><br><span class="hljs-comment">// move r and add new ch</span><br>r++;<br><span class="hljs-keyword">if</span> (map[s[r]] !== <span class="hljs-literal">undefined</span>) &#123;<br>map[s[r]]--;<br>&#125;<br><span class="hljs-keyword">if</span> (map[s[r]] === <span class="hljs-number">0</span>) &#123;<br>count--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>sliding window</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 419. Battleships in a Board</title>
    <link href="/posts/1351088998.html"/>
    <url>/posts/1351088998.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n matrix board where each cell is a battleship ‘X’ or empty ‘.’, return the number of the battleships on board.</p><p>Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg" alt="Example 1"><br>Input: board &#x3D; [[“X”,”.”,”.”,”X”],[“.”,”.”,”.”,”X”],[“.”,”.”,”.”,”X”]]<br>Output: 2</p><p>Example 2:<br>Input: board &#x3D; [[“.”]]<br>Output: 0</p><p>Constraints:<br>m &#x3D;&#x3D; board.length<br>n &#x3D;&#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>board[i][j] is either ‘.’ or ‘X’.</p><p>Follow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board?</p><p>甲板上的战舰。</p><blockquote>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。<p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题的 followup 是问是否只扫描一遍并且不用额外空间。所以最优解思路是遍历一次 input，找出战舰的起始点。所谓的战舰起始点，就是为 X 的点，同时该点的上方和左侧的点不能为 X。这题其实是比较简单，因为如果战舰可以相邻，会更难判断。</p><p>二刷的时候这道题看了答案都不记得为什么上方和左边的点不能为 X，原因是因为每个单独的战舰是不能跟其他战舰相邻的，我们既然找的是战舰的起点，中间一定要隔开起码一个坐标的距离。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBattleships</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 如果上面和左侧有点，那么当前这个点一定不是一个战舰的起点</span><br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 不是点也不是需要跳过的X那么就一定是一个战舰的起点X</span><br>res++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1002. Find Common Characters</title>
    <link href="/posts/92520130.html"/>
    <url>/posts/92520130.html</url>
    
    <content type="html"><![CDATA[<p>Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.</p><p>Example 1:<br>Input: words &#x3D; [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]</p><p>Example 2:<br>Input: words &#x3D; [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 100<br>words[i] consists of lowercase English letters.</p><p>查找共用字符。</p><blockquote>给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个装了单词的数组，请求出这些单词里面共同的字母，以 list 形式输出。如果有多个相同的字母也需要多次输出。</p><p>思路是用 hashmap 记录 input 中第一个单词里面每个字母的出现次数，然后从第二个单词开始，也是去计算每个字母出现的次数，但是把某个字母在某个单词中出现的最少的次数加入结果集。举个例子，比如 cool 里面 o 出现了两次，但是在 lock 里面 o 只出现了一次，记录 o 的时候只记录最少的出现次数。最后遍历结果集里面每个单词，根据次数拼接成最后要输出的 list。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m * n) - n 个单词 * 每个单词的平均长度 m<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">commonChars</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : first.toCharArray()) &#123;<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">int</span>[] letters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : cur.toCharArray()) &#123;<br>                letters[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>                map[j] = Math.min(map[j], letters[j]);<br>            &#125;<br>        &#125;<br><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">while</span> (map[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>) (i + <span class="hljs-string">&#x27;a&#x27;</span>);<br>                res.add(c + <span class="hljs-string">&quot;&quot;</span>);<br>                map[i]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 999. Available Captures for Rooks</title>
    <link href="/posts/1415125802.html"/>
    <url>/posts/1415125802.html</url>
    
    <content type="html"><![CDATA[<p>You are given an 8 x 8 matrix representing a chessboard. There is exactly one white rook represented by ‘R’, some number of white bishops ‘B’, and some number of black pawns ‘p’. Empty squares are represented by ‘.’.</p><p>A rook can move any number of squares horizontally or vertically (up, down, left, right) until it reaches another piece or the edge of the board. A rook is attacking a pawn if it can move to the pawn’s square in one move.</p><p>Note: A rook cannot move through other pieces, such as bishops or pawns. This means a rook cannot attack a pawn if there is another piece blocking the path.</p><p>Return the number of pawns the white rook is attacking.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/02/20/1253_example_1_improved.PNG" alt="Example 1"><br>Input: board &#x3D; [[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”R”,”.”,”.”,”.”,”p”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 3</p><p>Explanation:<br>In this example, the rook is attacking all the pawns.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/02/19/1253_example_2_improved.PNG" alt="Example 2"><br>Input: board &#x3D; [[“.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”p”,”p”,”p”,”p”,”p”,”.”,”.”],[“.”,”p”,”p”,”B”,”p”,”p”,”.”,”.”],[“.”,”p”,”B”,”R”,”B”,”p”,”.”,”.”],[“.”,”p”,”p”,”B”,”p”,”p”,”.”,”.”],[“.”,”p”,”p”,”p”,”p”,”p”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 0</p><p>Explanation:<br>The bishops are blocking the rook from attacking any of the pawns.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2019/02/20/1253_example_3_improved.PNG" alt="Example 3"><br>Input: board &#x3D; [[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“p”,”p”,”.”,”R”,”.”,”p”,”B”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”B”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 3</p><p>Explanation:<br>The rook is attacking the pawns at positions b5, d6, and f5.</p><p>Constraints:<br>board.length &#x3D;&#x3D; 8<br>board[i].length &#x3D;&#x3D; 8<br>board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’<br>There is exactly one cell with board[i][j] &#x3D;&#x3D; ‘R’</p><p>可以被一步捕获的棋子数。</p><blockquote>给定一个 8 x 8 的棋盘，只有一个 白色的车，用字符 'R' 表示。棋盘上还可能存在白色的象 'B' 以及黑色的卒 'p'。空方块用字符 '.' 表示。<p>车可以按水平或竖直方向（上，下，左，右）移动任意个方格直到它遇到另一个棋子或棋盘的边界。如果它能够在一次移动中移动到棋子的方格，则能够 吃掉 棋子。</p><p>注意：车不能穿过其它棋子，比如象和卒。这意味着如果有其它棋子挡住了路径，车就不能够吃掉棋子。</p><p>返回白车将能 吃掉 的 卒的数量。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题没有什么算法，就是按规则从车所在的位置开始扫描 4 个不同的方向，遇到小写的 p 则 res++，遇到边缘和大写的字母（因为是白色棋子）则停下。这个题就是考你在矩阵中如何一直往一个方向走的技巧。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(64) - 最极端情况需要扫描整个棋盘<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRookCaptures</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123; &#123; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;, &#123; <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125; &#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// when find the rook</span><br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j;<br>                        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                            x += dir[<span class="hljs-number">0</span>];<br>                            y += dir[<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n || board[x][y] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (board[x][y] == <span class="hljs-string">&#x27;p&#x27;</span>) &#123;<br>                                res++;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 201. Bitwise AND of Numbers Range</title>
    <link href="/posts/298596106.html"/>
    <url>/posts/298596106.html</url>
    
    <content type="html"><![CDATA[<p>Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.</p><p>Example 1:<br>Input: left &#x3D; 5, right &#x3D; 7<br>Output: 4</p><p>Example 2:<br>Input: left &#x3D; 0, right &#x3D; 0<br>Output: 0</p><p>Example 3:<br>Input: left &#x3D; 1, right &#x3D; 2147483647<br>Output: 0</p><p>Constraints:<br>0 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; 231 - 1</p><p>数字范围按位与。</p><blockquote><p>给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个范围 [m, n]，输出这个范围内所有二进制数做 AND 操作之后的结果。思路是位运算。举个例子，如下是四个连续的数字，</p><blockquote><p>0100010<br>0100011<br>0100100<br>0100101</p></blockquote><p>注意，当他们被AND的时候，会发现最低位会变成0。因为两个相邻的数字的最低位一定不一样，所以AND之后的结果只会是0。这样不停地AND之后（同时向右移，假设最后右移了 X 次），到这一步发现前面若干位都是一样的时候，就可以停止了。最后将 m 向左移动 X 次，就会得到最后的结果。</p><blockquote><p>0100xxx<br>0100xxx<br>0100xxx<br>0100xxx</p></blockquote><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - 只要跑32次<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rangeBitwiseAnd</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (m != n) &#123;<br>            m &gt;&gt;= <span class="hljs-number">1</span>;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>            offset++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m &lt;&lt; offset;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">m</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rangeBitwiseAnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">m, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (m !== n) &#123;<br>        m &gt;&gt;= <span class="hljs-number">1</span>;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>        offset++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> m &lt;&lt; offset;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 151. Reverse Words in a String</title>
    <link href="/posts/4263260139.html"/>
    <url>/posts/4263260139.html</url>
    
    <content type="html"><![CDATA[<p>Given an input string, reverse the string word by word.</p><p>Example 1:<br>Input: “the sky is blue”<br>Output: “blue is sky the”</p><p>Example 2:<br>Input: “ hello world! “<br>Output: “world! hello”<br>Explanation: Your reversed string should not contain leading or trailing spaces.</p><p>Example 3:<br>Input: “a good example”<br>Output: “example good a”<br>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</p><p>Note:<br>A word is defined as a sequence of non-space characters.<br>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.<br>You need to reduce multiple spaces between two words to a single space in the reversed string.</p><p>翻转字符串中的单词。</p><blockquote><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p><p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p><p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p><p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string">https://leetcode.cn/problems/reverse-words-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-正则表达"><a href="#思路一-正则表达" class="headerlink" title="思路一 - 正则表达"></a>思路一 - 正则表达</h2><p>题意不难理解，我感觉这道题就是要考察代码熟练程度的。</p><p>我们要对 input 做预处理，一种情况是去掉 input 前后多余的空格，还有就是单词之间的多余空格也要去掉，每两个单词之间只留一个空格即可。思路是先把 input 字符串分开成数组，再将数组 reverse，最后将数组的每个元素拼接成字符串。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// trim 前后 skip 中间的回车 空格之类的东西</span><br>        String[] words = s.trim().split(<span class="hljs-string">&quot;\\s+&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> words.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            sb.append(words[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-双指针"><a href="#思路二-双指针" class="headerlink" title="思路二 - 双指针"></a>思路二 - 双指针</h2><p>这种思路是 trim 完 input 之后，从后往前开始遍历 input，用双指针卡住单词。先移动其中一个指针，当遇到空格的时候就需要截取单词了；将单词加入结果集之后记得要跳过单词之间的空格。具体参见代码注释。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-comment">// 去掉input边缘无效的空格</span><br>        <span class="hljs-comment">// &quot; test   &quot;</span><br>        s = s.trim();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 卡住每个单词的左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 未遇到空格之前，左指针一直往左走</span><br>            <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                start--;<br>            &#125;<br>            <span class="hljs-comment">// 卡住单词，注意subtring是左闭右开的</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(start + <span class="hljs-number">1</span>, end + <span class="hljs-number">1</span>);<br>            sb.append(word);<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            <span class="hljs-comment">// 把左右指针移动到下一个不是空格的位置上接着找下一个单词</span><br>            <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(start) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                start--;<br>            &#125;<br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString().trim();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseWords = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s<br>        .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)               <span class="hljs-comment">//create an array of words separated based by spaces</span><br>        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> string) <span class="hljs-comment">//remove empty strings to take care of extra whitespace</span><br>        .<span class="hljs-title function_">reverse</span>()                <span class="hljs-comment">//reverse the array of words</span><br>        .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);               <span class="hljs-comment">//join the words back together with spaces inbetween</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">151. Reverse Words in a String<br>186. Reverse Words in a String II<br>344. Reverse String<br>541. Reverse String II<br>557. Reverse Words in a String III<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 62. Unique Paths</title>
    <link href="/posts/1202755244.html"/>
    <url>/posts/1202755244.html</url>
    
    <content type="html"><![CDATA[<p>There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.</p><p>Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p><p>The test cases are generated so that the answer will be less than or equal to 2 * 109.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="Example 1"><br>Input: m &#x3D; 3, n &#x3D; 7<br>Output: 28</p><p>Example 2:<br>Input: m &#x3D; 3, n &#x3D; 2<br>Output: 3<br>Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p><ol><li>Right -&gt; Down -&gt; Down</li><li>Down -&gt; Down -&gt; Right</li><li>Down -&gt; Right -&gt; Down</li></ol><p>Constraints:<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100</p><p>不同路径。</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/unique-paths">https://leetcode.cn/problems/unique-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start”）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径。</p><p>这一题也是 DP 的基础题，一定要掌握。这里我提供三种做法，</p><ul><li>自上而下（自上而下又叫递归 + memo）</li><li>自下而上</li><li>节省空间的自下而上</li></ul><h2 id="DP自上而下"><a href="#DP自上而下" class="headerlink" title="DP自上而下"></a>DP自上而下</h2><p>时间O(mn)<br>空间O(mn)</p><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">return</span> dp(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][j] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][j];<br>        &#125;<br>        memo[i][j] = dp(i - <span class="hljs-number">1</span>, j) + dp(i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dp自上而下</span><br></code></pre></td></tr></table></figure><h2 id="DP自下而上，先确定矩阵边缘上的点的DP值，然后再考虑中间的点"><a href="#DP自下而上，先确定矩阵边缘上的点的DP值，然后再考虑中间的点" class="headerlink" title="DP自下而上，先确定矩阵边缘上的点的DP值，然后再考虑中间的点"></a>DP自下而上，先确定矩阵边缘上的点的DP值，然后再考虑中间的点</h2><p>时间O(mn)<br>空间O(mn)</p><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] += dp[i - <span class="hljs-number">1</span>][j];<br>                dp[i][j] += dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// dp自下而上</span><br></code></pre></td></tr></table></figure><h2 id="节省空间的一维-DP"><a href="#节省空间的一维-DP" class="headerlink" title="节省空间的一维 DP"></a>节省空间的一维 DP</h2><p>一维 DP 的思路是逐行扫描。首先初始化一个长度为 n 的数组，并初始化第一个坐标为 1（也就是坐标上0, 0的位置）。接着往右边扫描，每一个坐标的值是当前位置的 DP 值 + 他左边一个位置的 DP 值。根据下图跑一下代码，第7行，第一遍跑的时候，一开始 res[j] &#x3D; res[1] &#x3D; 0 + res[0] &#x3D; 0 + 1 &#x3D; 1；接着 res[2] &#x3D; 0 + 1 &#x3D; 1。以此类推得到第一行的dp值是 [1, 1, 1, 1, 1, 1]。再遍历第二行，得到 [1, 2, 3, 4, 5, 6]；第三行 [1, 3, 6, 10, 15, 21] 和第四行 [1, 4, 10, 20, 35, 56]。这个思路非常巧妙，需要多多体会。<br>时间O(mn)<br>空间O(n)</p><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(res, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                res[j] += res[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 节省空间的自下而上</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">m</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-keyword">function</span> (<span class="hljs-params">m, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            res[j] = res[j] + res[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// console.log(res);</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res[n - <span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">62. Unique Paths<br>63. Unique Paths II<br>64. Minimum Path Sum<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 876. Middle of the Linked List</title>
    <link href="/posts/946488007.html"/>
    <url>/posts/946488007.html</url>
    
    <content type="html"><![CDATA[<p>Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg" alt="Example 1"><br>Input: [1,2,3,4,5]<br>Output: Node 3 from this list (Serialization: [3,4,5])<br>The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>Note that we returned a ListNode object ans, such that:<br>ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, and ans.next.next.next &#x3D; NULL.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg" alt="Example 2"><br>Input: [1,2,3,4,5,6]<br>Output: Node 4 from this list (Serialization: [4,5,6])<br>Since the list has two middle nodes with values 3 and 4, we return the second one.</p><p>Note:<br>The number of nodes in the given list will be between 1 and 100.</p><p>链表的中间结点。</p><blockquote><p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是快慢指针，快指针停下的时候，慢指针所在的位置即是所求。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> middleNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = head;<br>    <span class="hljs-keyword">let</span> fast = head;<br>    <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">21. Merge Two Sorted Lists<br>23. Merge k Sorted Lists<br>148. Sort List<br>876. Middle of the Linked List<br>2095. Delete the Middle Node of a Linked List<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 17. Letter Combinations of a Phone Number</title>
    <link href="/posts/3353073922.html"/>
    <url>/posts/3353073922.html</url>
    
    <content type="html"><![CDATA[<p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="Example"></p><p>Example 1:<br>Input: digits &#x3D; “23”<br>Output: [“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>Example 2:<br>Input: digits &#x3D; “”<br>Output: []</p><p>Example 3:<br>Input: digits &#x3D; “2”<br>Output: [“a”,”b”,”c”]</p><p>Constraints:<br>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] is a digit in the range [‘2’, ‘9’].</p><p>电话号码的字母组合。</p><blockquote>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number">https://leetcode.cn/problems/letter-combinations-of-a-phone-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-backtracking"><a href="#思路一-backtracking" class="headerlink" title="思路一 - backtracking"></a>思路一 - backtracking</h2><p>题意是给一个 string，里面是数字，请返回所有可能的字母组合。这是典型的 backtracking 回溯类的题目，一定要会。回溯类的题目一般都是带着一个 prefix 前缀，然后不断地尝试不同的组合直到最后的结果满足一定的情况，往往是长度满足情况。这道题有两种解法，其中第二种解法也是一定会考的。</p><p>第一种解法是典型的回溯解法，会用到一个 helper 函数。递归函数的跳出条件就是遍历完了当前所有的数字。每当遍历一个数字的时候，拿出它背后所有的字母，比如 2，就拿出 abc 来分别往结果集里面添加。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(4^n * n) - 每个按键平均对应 4 个字母，那么递归次数为一个满四叉树的节点个数。每把一个结果加入结果集的时候，需要 new 一个新的 string 所以还需要再乘以 n<br>空间O(4^n) - output list</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span> String[] mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span> &#125;;<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>helper(res, digits, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;String&gt; res, String digits, String prefix, <span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">// base case</span><br><span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>res.add(prefix);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 拿出每个数字背后对应的字母们</span><br><span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> mapping[digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : letters.toCharArray()) &#123;<br>            helper(res, digits, prefix + c, index + <span class="hljs-number">1</span>);<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我再提供一个 StringBuilder 的代码，注意代码中是有撤回操作的。String 的版本为什么不需要撤回是因为进入下一层递归的时候 String 创建了新的对象。<br>Java实现二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        helper(res, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder sb, String digits, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> mapping[digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; letters.length(); i++) &#123;<br>            sb.append(letters.charAt(i));<br>            helper(res, sb, digits, index + <span class="hljs-number">1</span>);<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-bfs"><a href="#思路二-bfs" class="headerlink" title="思路二 - bfs"></a>思路二 - bfs</h2><p>第二种做法是类似树的层序遍历。一开始将一个空的字符串加入一个用linkedlist创建的队列，接着遍历input，拿到每一个数字，加入队列，弹出的时候，遵循先进先出的原则，弹出某个字母，再根据长度判断是否需要再attach新的字符。<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/hui-su-dui-lie-tu-jie-by-ml-zimingmeng/">动图链接</a>。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(3^n)<br>空间O(3^n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        LinkedList&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        String[] mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span> &#125;;<br>        res.add(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; digits.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> digits.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">while</span> (res.peek().length() == i) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> res.remove();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> s : mapping[num].toCharArray()) &#123;<br>                    res.add(t + s);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 129. Sum Root to Leaf Numbers</title>
    <link href="/posts/3006640849.html"/>
    <url>/posts/3006640849.html</url>
    
    <content type="html"><![CDATA[<p>You are given the root of a binary tree containing digits from 0 to 9 only.</p><p>Each root-to-leaf path in the tree represents a number.</p><p>For example, the root-to-leaf path 1 -&gt; 2 -&gt; 3 represents the number 123.<br>Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.</p><p>A leaf node is a node with no children.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="Example 1"><br>Input: root &#x3D; [1,2,3]<br>Output: 25<br>Explanation:<br>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.<br>Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="Example 2"><br>Input: root &#x3D; [4,9,0,5,1]<br>Output: 1026<br>Explanation:<br>The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.<br>The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.<br>The root-to-leaf path 4-&gt;0 represents the number 40.<br>Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 1000].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>The depth of the tree will not exceed 10.</p><p>求根到叶子节点数字之和。</p><blockquote><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers">https://leetcode.cn/problems/sum-root-to-leaf-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是前序遍历。记录一个变量 sum 存之前所有的加和，当遍历到当前节点的时候，sum *&#x3D; 10 再加当前的节点值 cur.val。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;    <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum = sum * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            res += sum;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        helper(root.left, sum);<br>        helper(root.right, sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sumNumbers = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_">helper</span>(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> total;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">root, sum</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sum = sum * <span class="hljs-number">10</span> + root.<span class="hljs-property">val</span>;<br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;<br>            total += sum;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">left</span>, sum);<br>        <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">right</span>, sum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">129. Sum Root to Leaf Numbers<br>1022. Sum of Root To Leaf Binary Numbers<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 222. Count Complete Tree Nodes</title>
    <link href="/posts/2590265563.html"/>
    <url>/posts/2590265563.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a complete binary tree, return the number of the nodes in the tree.</p><p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><p>Design an algorithm that runs in less than O(n) time complexity.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="Example 1"><br>Input: root &#x3D; [1,2,3,4,5,6]<br>Output: 6</p><p>Example 2:<br>Input: root &#x3D; []<br>Output: 0</p><p>Example 3:<br>Input: root &#x3D; [1]<br>Output: 1</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 5 * 104].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 104<br>The tree is guaranteed to be complete.</p><p>完全二叉树的节点个数。</p><blockquote>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/count-complete-tree-nodes">https://leetcode.cn/problems/count-complete-tree-nodes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-递归-分治"><a href="#思路一-递归-分治" class="headerlink" title="思路一 - 递归 + 分治"></a>思路一 - 递归 + 分治</h2><p>比较容易写出来的思路是可以用递归。我参考了<a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/ru-he-ji-s-2320e/">这个帖子</a>。</p><p>因为一个完美二叉树的节点个数是2^h - 1，2的h次方 - 1，h是树的高度。如果根节点的左子树和右子树的高度一样，则说明当前这棵树一定为满二叉树。如果左子树和右子树的高度不一样，则一定有其中一棵子树不是满二叉树，就需要递归到更小的子树去看到底哪个子树不是满二叉树。注意这个思路的时间复杂度是 O(logn * logn)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn * logn)<br>空间O(logn) - O(h) - 树的高度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> leftDepth(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> rightDepth(root);<br>        <span class="hljs-comment">// 如果根节点的左子树深度等于右子树深度，则说明整棵树是满二叉树</span><br>        <span class="hljs-comment">// 否则就要递归去找到底哪个子树不是满二叉树</span><br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-comment">// return (int) Math.pow(2, left) - 1;</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1</span> &lt;&lt; left) - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.left) + countNodes(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leftDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            root = root.left;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rightDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            root = root.right;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// O(logn * logn)</span><br></code></pre></td></tr></table></figure><h2 id="思路二-二分查找"><a href="#思路二-二分查找" class="headerlink" title="思路二 - 二分查找"></a>思路二 - 二分查找</h2><p>注意这个题的 tag 是 binary search 二分法，二分法是这道题最优解但是不好想到，这里我也给出二分法的解法，参考了<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/c-san-chong-fang-fa-jie-jue-wan-quan-er-cha-shu-de/">这个帖子</a>。思路是首先拿到树的最大深度，这个不难，只要不停地往左孩子遍历就行。其次，如果是一个满二叉树（complete binary tree），节点数是2^depth - 1。按照例子一，如果是一个高度为3的树，节点个数就是2^3 - 1 &#x3D; 7；同时最后一层的节点数应该是2^(depth - 1) &#x3D; 2^2 &#x3D; 4。</p><p>但是如果只是一个完全二叉树，最后一层的节点数很有可能是缺失的，此时就需要用二分法找最后一层到底有几个节点了。这里需要写一个 helper 函数帮助做二分法，因为每一层的节点数是跟当前的深度有关所以当前层的节点数的范围应该在0 ~ (2^depth - 1)之间。所以二分法找的时候，比如一个高度为 3 的树如果是满的，理论上最低一层应该有 8 个节点，则去判断是否有第 4 个节点，若有则往右子树走，若没有则往左子树走。最后 helper 函数返回的是最后一层处于位置i的节点是否存在。</p><p>最后着重解释一下exist函数。还是给定了上下界 left &#x3D; 0, right &#x3D; 2^depth - 1。这个函数是为了检查某一个节点是否存在的。检查的方法其实是类似 DFS，从深度为 0 的地方开始，在已经知道节点 index 的情况下，带入 tree 去检查，如果 index 大于当前层中间的 node，则去右子树看，反之则去左子树看。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn * logn)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> computeDepth(root);<br>        <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, d) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (exists(root, d, mid)) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, d) - <span class="hljs-number">1</span> + left;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">computeDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            depth++;<br>            root = root.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, depth) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth; i++) &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (index &lt;= mid) &#123;<br>                root = root.left;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                root = root.right;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>binary search</tag>
      
      <tag>divide and conquer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 230. Kth Smallest Element in a BST</title>
    <link href="/posts/1608621597.html"/>
    <url>/posts/1608621597.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="Example 1"><br>Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>Output: 1</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="Example 2"><br>Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3<br>Output: 3</p><p>Constraints:<br>The number of nodes in the tree is n.<br>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 104<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><p>Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p><p>二叉搜索树中第 K 小的元素。</p><blockquote>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为是 BST 所以大概率会考察中序遍历，即中序遍历的结果是升序的。这道题的最优解就是按照中序遍历的方法去遍历 BST 的节点，用 count 记录是否到 k，输出第 k 个节点即可。影子题 671。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>迭代的做法和递归的做法复杂度一样。<br>时间O(n)<br>空间O(n)</p><h2 id="Java递归实现"><a href="#Java递归实现" class="headerlink" title="Java递归实现"></a>Java递归实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> res;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        count = k;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        helper(root.left);<br>        count--;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            res = root.val;<br>        &#125;<br>        helper(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java迭代实现"><a href="#Java迭代实现" class="headerlink" title="Java迭代实现"></a>Java迭代实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        stack.push(cur);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            count++;<br>            <span class="hljs-keyword">if</span> (count == k) &#123;<br>                <span class="hljs-keyword">return</span> cur.val;<br>            &#125;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JavaScript递归实现"><a href="#JavaScript递归实现" class="headerlink" title="JavaScript递归实现"></a>JavaScript递归实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = k;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> helper = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">left</span>);<br>        count--;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            res = root.<span class="hljs-property">val</span>;<br>        &#125;<br>        <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">helper</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="JavaScript迭代实现"><a href="#JavaScript迭代实现" class="headerlink" title="JavaScript迭代实现"></a>JavaScript迭代实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            stack.<span class="hljs-title function_">push</span>(root);<br>            root = root.<span class="hljs-property">left</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = stack.<span class="hljs-title function_">pop</span>();<br>            k--;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.<span class="hljs-property">val</span>;<br>            &#125;<br>            root = root.<span class="hljs-property">right</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">230. Kth Smallest Element in a BST<br>671. Second Minimum Node In a Binary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>inorder</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 238. Product of Array Except Self</title>
    <link href="/posts/2592651913.html"/>
    <url>/posts/2592651913.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p><p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p><p>You must write an algorithm that runs in O(n) time and without using the division operation.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,4]<br>Output: [24,12,8,6]</p><p>Example 2:<br>Input: nums &#x3D; [-1,1,0,-3,3]<br>Output: [0,0,9,0,0]</p><p>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30<br>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p><p>Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)</p><p>除自身以外数组的乘积。</p><blockquote>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/product-of-array-except-self">https://leetcode.cn/problems/product-of-array-except-self</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数组，请输出一个等长的数组，res[i] 位上存的是 input 数组除了 i 位其他所有数字的乘积。</p><p>注意这个题不能用除法，如果用除法会很简单。思路是我们创建一个和 input 数组等长的 res 数组记录结果，对于在 i 位上的数字，在 res[i] 上存住从左往右把之前每个数字相乘的乘积 * 从右向左在 i 之后每个数字相乘的乘积。注意左边和右边的代码稍有不同，需要多体会。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - output</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res[i] = left;<br>            left *= nums[i];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            res[i] *= right;<br>            right *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> productExceptSelf = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-keyword">var</span> left = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> product = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>product.<span class="hljs-title function_">push</span>(left);<br>left = left * num;<br>&#125;<br><br><span class="hljs-keyword">var</span> right = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>product[i] *= right;<br>right = right * nums[i];<br>&#125;<br><span class="hljs-keyword">return</span> product;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>prefix sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 409. Longest Palindrome</title>
    <link href="/posts/3720452250.html"/>
    <url>/posts/3720452250.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.</p><p>Letters are case sensitive, for example, “Aa” is not considered a palindrome.</p><p>Example 1:<br>Input: s &#x3D; “abccccdd”<br>Output: 7<br>Explanation: One longest palindrome that can be built is “dccaccd”, whose length is 7.</p><p>Example 2:<br>Input: s &#x3D; “a”<br>Output: 1<br>Explanation: The longest palindrome that can be built is “a”, whose length is 1.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 2000<br>s consists of lowercase and&#x2F;or uppercase English letters only.</p><p>最长回文串。</p><blockquote>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的 回文串 的长度。<p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历 input，并用一个 hashmap 存字母的出现次数。如果某字母已经存在于 hashmap减去它在 hashmap 内的出现次数，res +&#x3D; 2，这里的意思是找到了一对字母可以用于回文串；如果某字母不存在于 hashmap 则把它加入 hashmap，map[char]++。最后遍历 hashmap，看是否还存在某个字母的出现次数不为零的情况，若还有不为零的字母则最长的回文串长度是 res + 1（会形成类似aba这样的回文）；否则则是res（会形成类似abba这样的回文）。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(256) - O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (count[c] &gt; <span class="hljs-number">0</span>) &#123;<br>                count[c]--;<br>                res += <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count[c]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (count[i] != <span class="hljs-number">0</span>) &#123;<br>                res++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> s) &#123;<br>        <span class="hljs-keyword">if</span> (map[c] !== <span class="hljs-literal">undefined</span>) &#123;<br>            map[c] = <span class="hljs-literal">undefined</span>;<br>            res++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map[c] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> map) &#123;<br>        <span class="hljs-keyword">if</span> (map[key] !== <span class="hljs-literal">undefined</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> res * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res * <span class="hljs-number">2</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 题目总结</title>
    <link href="/posts/939082724.html"/>
    <url>/posts/939082724.html</url>
    
    <content type="html"><![CDATA[<p>本博客不定期更新 LeetCode 题目总结，所有题目使用 Java 实现，小部分题目也提供 JavaScript 代码。我不追求一行 AC 但是我追求<span style="color:red">一题多解，比较常规的思路，解释清楚复杂度，代码可读性强。</span>欢迎留言和评论，共同进步。这本是我自己用来复习的笔记，如果也能帮到你，那也是我的福报。</p><p>如果你想按类型刷题，可以参考我的标签。我做出的分类比 LC 官方的更细一些，比如我有如下展示的这些类型，其中有一些类型在 2021 年 6 月以前官方没有收录，有的按照题设分类，有的按照思路&#x2F;解法分类。同时有一些题目的解法或者思想很类似的，我也会以相关题目的形式列在文章的最底部。对于每一种类型的题，你可以基本按照题号从小到大开始刷，比较小的题号（尤其前 400）都是经典题，一般直接问算法，比较大的题号往往是前 400 题中某个题目的 followup 或变形，如果你看懂题目要考什么，其实涉及的算法在前 400 题应该都有涉及。<span style="color:red">题是刷不完的，只有总结反思才会有提高</span>。</p><ul><li><a href="https://shurui91.github.io/tags/flood-fill/">flood fill</a> 岛屿类 - 往往是通过 BFS&#x2F;DFS 从一个点开始遍历整个二维数组，根据题意找岛的个数&#x2F;面积或者找一个点与点之间的距离，一个走到某个坐标上的步数&#x2F;时间</li><li><a href="https://shurui91.github.io/tags/matrix/">matrix</a> 矩阵类，跟岛屿类型的题很接近，但是主要考点是二维数组的非常规遍历，翻转。官方把岛屿类的题也归类到 matrix 一类了，我这里做了一些区分</li><li><a href="https://shurui91.github.io/tags/monotonic-stack/">monotonic stack</a> 单调栈 - 不容易想到但是的确能解决问题的一种思路，如果不用单调栈，暴力解基本是 O(n^2) 级别的</li><li><a href="https://shurui91.github.io/tags/two-pointer/">two pointer</a> 双指针，包括很多可以用双指针做但是没有标注成双指针类型的题</li><li><a href="https://shurui91.github.io/tags/prefix-sum/">prefix sum</a> 前缀和</li><li><a href="https://shurui91.github.io/tags/sliding-window/">sliding window</a> 滑动窗口</li><li>sliding window with fixed size 固定尺寸的滑动窗口</li><li><a href="https://shurui91.github.io/tags/palindrome/">palindrome</a> 回文 - 也是双指针的一个子类，两边往中间逼近</li><li>line sweep 扫描线&#x2F;差分数组 - 这一类的题其实也分为两个子类，一类是类似会议室那种，一类是合并子区间那种</li><li><a href="https://shurui91.github.io/tags/counting-sort/">counting sort</a> 计数排序</li><li>bucket sort 桶排序</li><li>Longest Increasing Subsequence (LIS) 最长递增子序列<ul><li>这个类型的题往往跟 DP 有关</li></ul></li><li>Longest Common Subsequence (LCS) 最长相同子序列，经典题有<ul><li>Edit Distance</li><li>Longest Common Subsequence</li></ul></li><li><a href="https://shurui91.github.io/tags/two-sum/">two sum</a> 两数之和 - 一些算是 two sum 的 followup 题</li><li>MOD - 结果非常大，需要取模的题。如果需要优化，大多涉及到二分</li><li><a href="https://shurui91.github.io/tags/binary-search/">binary search</a> 二分法<ul><li><a href="https://shurui91.github.io/posts/3220296722.html">我总结的三个二分法模板及其区别</a></li></ul></li><li>binary search on answer 在答案上二分<ul><li>也是二分的一类题，一般不是直接在 input 数组上做二分</li></ul></li><li><a href="https://shurui91.github.io/tags/dijkstra/">Dijkstra</a> 迪杰斯特拉算法<ul><li>使用类似广度优先搜索的方法解决图的单源最短路径问题，一般会涉及有向和有权的图</li></ul></li><li><a href="https://shurui91.github.io/tags/graph/">graph</a> 图论 - 包括很多 input signature 给的是树但是实际是需要自己把图或邻接表建立起来的题，和官方压根没有给出 graph 这个 tag 的题（比如1192题，2021年6月这个题官方加了tag了）</li><li><a href="https://shurui91.github.io/tags/union-find/">union find</a> - 并查集 - 解决一些 BFS 做会复杂度高或 DFS 做会 stack overflow 的图论的题，比如如果数据是以数据流的形式给出的，BFS 的复杂度就会很高。并查集有时候在 union 的过程中就能找到答案。</li><li>knapsack 背包问题 - 动态规划中的一个子类</li><li>memorization - 记忆化（递归）- 动态规划中的一个子类</li><li><a href="https://shurui91.github.io/tags/simulation/">simulation</a> - 模拟，一般不涉及算法，就是根据题意实现</li><li><a href="https://shurui91.github.io/tags/gcd/">gcd</a> 最大公约数</li></ul><p>我做了一个 <a href="https://docs.qq.com/sheet/DVnNKeUNIaEJzSmtU?tab=bb08j2">腾讯文档</a> 记录总结写过题解的题目并附上链接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 543. Diameter of Binary Tree</title>
    <link href="/posts/2554022659.html"/>
    <url>/posts/2554022659.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the length of the diameter of the tree.</p><p>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p><p>The length of a path between two nodes is represented by the number of edges between them.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="Example 1"><br>Input: root &#x3D; [1,2,3,4,5]<br>Output: 3<br>Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</p><p>Example 2:<br>Input: root &#x3D; [1,2]<br>Output: 1</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 104].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>二叉树的直径。</p><blockquote>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/diameter-of-binary-tree">https://leetcode.cn/problems/diameter-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个二叉树，找二叉树里面的最大直径。最大直径的定义是任意两个 node 之间的最大距离。注意这个最大距离很有可能不经过根节点，如下图例子，最大直径是从 9 到 8，摘自LC中文网。<br><img src="https://pic.leetcode-cn.com/f39419c0fd3b3225a643ac4f40a1289c93cb03a6fb07a0be9e763c732a49b47d-543.jpg" alt="Example"></p><p>思路是后序遍历 postorder。做法类似104题找二叉树最大深度用到的递归，但是稍微做一点改动。设置一个全局变量记录 res 这个最大长度，递归函数找的依然是最大深度但是 res 记录的是经过当前节点的 diameter。helper 函数往父节点 return 的则是一边的最长长度 + 1 &#x3D; 一边的最长长度 + 当前这个子节点到父节点的距离。</p><p>照着这个例子跑一下吧，比如根节点的左孩子 2 这里。此时我需要知道的信息是经过 2 的 diameter 最长可以到多少，所以是 left + right。但是我往 2 的父节点 1 需要 return 的信息是经过 2（同时也经过1）的最长的 diameter，我能贡献的长度是多少。这个长度是 2 的左右子树能贡献出来的较长者 + 1（2到1的距离）。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> helper(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> helper(root.right);<br>        <span class="hljs-comment">// 经过当前节点的直径是多长</span><br>        res = Math.max(res, left + right);<br>        <span class="hljs-comment">// 但是往父节点return的时候，return的却是一边的最长长度 + 1 = 一边的最长长度 + 子节点到父节点的距离</span><br>        <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">104. Maximum Depth of Binary Tree<br>110. Balanced Binary Tree<br>366. Find Leaves of Binary Tree<br>543. Diameter of Binary Tree<br>1522. Diameter of N-Ary Tree<br>1245. Tree Diameter<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 114. Flatten Binary Tree to Linked List</title>
    <link href="/posts/3521840866.html"/>
    <url>/posts/3521840866.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, flatten the tree into a “linked list”:</p><ul><li>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.</li><li>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</li></ul><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="Example 1"><br>Input: root &#x3D; [1,2,5,3,4,null,6]<br>Output: [1,null,2,null,3,null,4,null,5,null,6]</p><p>Example 2:<br>Input: root &#x3D; []<br>Output: []</p><p>Example 3:<br>Input: root &#x3D; [0]<br>Output: [0]</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 2000].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Can you flatten the tree in-place (with O(1) extra space)?</p><p>二叉树展开为链表。</p><blockquote><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-迭代"><a href="#思路一-迭代" class="headerlink" title="思路一 - 迭代"></a>思路一 - 迭代</h2><p>这里我给出迭代的做法，会用到 stack。照着例子看来，最后的输出是按照先序遍历的顺序来的。所以用 stack 先右后左地塞入每个节点，但是在弹出的时候需要注意一些细节，在重连 right 指针的时候，先不要把那个对应的右节点从 stack 中 pop 出来，否则就会出错。具体的参见代码注释。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - stack</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                <span class="hljs-comment">// if pop here, the result will be wrong</span><br>                <span class="hljs-comment">// at this step, you get the right node, this node will be poped out in the next round</span><br>                cur.right = stack.peek();<br>            &#125;<br>            cur.left = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify root in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> flatten = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> stack = [];<br>    stack.<span class="hljs-title function_">push</span>(root);<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> cur = stack.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;<br>            stack.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;<br>            stack.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span>) &#123;<br>            cur.<span class="hljs-property">right</span> = stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>        &#125;<br>        cur.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-也是迭代，无需额外空间"><a href="#思路二-也是迭代，无需额外空间" class="headerlink" title="思路二 - 也是迭代，无需额外空间"></a>思路二 - 也是迭代，无需额外空间</h2><p>参考<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/">这个帖子</a>的解法一。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - stack</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果左子树为空，直接去看右子树</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                root = root.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 找到左子树的最右孩子，走到4的位置</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> root.left;<br>                <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-literal">null</span>) &#123;<br>                    pre = pre.right;<br>                &#125;<br>                <span class="hljs-comment">// 把左子树的最右孩子连接到右子树</span><br>                pre.right = root.right;        <span class="hljs-comment">// 4 - 5</span><br>                root.right = root.left;        <span class="hljs-comment">// 1 - 2，只是2从1的左孩子变成了右孩子</span><br>                root.left = <span class="hljs-literal">null</span>;            <span class="hljs-comment">// 1的左指针设置为NULL</span><br>                root = root.right;            <span class="hljs-comment">// 1走到2</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">114. Flatten Binary Tree to Linked List<br>430. Flatten a Multilevel Doubly Linked List<br>897. Increasing Order Search Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>linked list</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 739. Daily Temperatures</title>
    <link href="/posts/3636396652.html"/>
    <url>/posts/3636396652.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] &#x3D;&#x3D; 0 instead.</p><p>Example 1:<br>Input: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>Output: [1,1,4,2,1,1,0,0]</p><p>Example 2:<br>Input: temperatures &#x3D; [30,40,50,60]<br>Output: [1,1,1,0]</p><p>Example 3:<br>Input: temperatures &#x3D; [30,60,90]<br>Output: [1,1,0]</p><p>Constraints:<br>1 &lt;&#x3D; temperatures.length &lt;&#x3D; 105<br>30 &lt;&#x3D; temperatures[i] &lt;&#x3D; 100</p><p>每日温度。</p><blockquote>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures">https://leetcode-cn.com/problems/daily-temperatures</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路依然是单调栈，而且这个题应该是一个单调递减栈。</p><p>具体做法是创建一个 stack，遍历数组，依然是把数组的下标放进 stack；若当前 stack 不为空且栈顶元素背后指向的温度 (temperatures[stack.peek()]) 小于当前温度 (temperatures[i])，则弹出栈顶 index，在结果集里面的对应 index 可以记录 i - index，这就是 index 和他自己之后一个高温天气的时间差。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> temperatures[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; cur &gt; temperatures[stack.peekLast()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dayIndex</span> <span class="hljs-operator">=</span> stack.pollLast();<br>                res[dayIndex] = i - dayIndex;<br>            &#125;<br>            stack.offerLast(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">temperatures</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> dailyTemperatures = <span class="hljs-keyword">function</span> (<span class="hljs-params">temperatures</span>) &#123;<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(temperatures.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]]) &#123;<br>            <span class="hljs-keyword">let</span> index = stack.<span class="hljs-title function_">pop</span>();<br>            res[index] = i - index;<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 6. Zigzag Conversion</title>
    <link href="/posts/3565050416.html"/>
    <url>/posts/3565050416.html</url>
    
    <content type="html"><![CDATA[<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><p>P A H N<br>A P L S I I G<br>Y I R<br>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);</p><p>Example 1:<br>Input: s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 3<br>Output: “PAHNAPLSIIGYIR”</p><p>Example 2:<br>Input: s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:<br>P I N<br>A L S I G<br>Y A H R<br>P I</p><p>Z字形变换。</p><blockquote><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p>P A H N<br>A P L S I I G<br>Y I R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion">https://leetcode-cn.com/problems/zigzag-conversion</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个正常的字符串，和一个参数 numRows，请以 Z 字形表示出来。例子，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">Example:<br>Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4<br>Output: &quot;PINALSIGYAHRPI&quot;<br>Explanation:<br>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I<br></code></pre></td></tr></table></figure><p>如例子所示，input字符串被展示成了4行。这个题不涉及算法，是一道实现题，我这里介绍一个看到的非常好的<a href="https://www.youtube.com/watch?v=CPamjPdCvIk">YouTube视频</a>。我会结合这个图讲思路，图也来自于视频。<br><img src="https://img2020.cnblogs.com/i-beta/1821153/202003/1821153-20200314032323808-95093551.png" alt="Example"></p><p>思路是用Java创建一个 StringBuilder array，里面加入 numRows 个 StringBuilder，然后遍历 input。首先是从上往下竖直的部分，因为已经知道了行数所以遍历的时候用 sb[i].append(c[index++]); 写入字符，i 是在 track 行数，index 是在 track 字符串。当 i &#x3D;&#x3D; numRows 的时候，会跳出这个循环；</p><p>接下来是从左下到右上的部分，因为P已经在第一个 for 循环写进去了所以接下来要写A和L。如果所示，斜向上的元素始于 sb[numRows - 2]（原因在于sb[numRows - 1]是最下面一行），止于sb[1]（sb[0]是第一行），遍历依然是用 sb[i].append(c[index++]); 写入字符。写入所有字符之后，将 StringBuilder array 里面所有的 StringBuilder append 在一起，再 convert 成 string 输出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - StringBuilder</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> numRows)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span> || s.length() &lt;= numRows) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        StringBuilder[] sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>[numRows];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            sb[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 一开始是往下走</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            rows[index].append(c);<br>            index += down ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 如果遇到了第一行或者最后一行，就改变方向</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span> || index == rows.length - <span class="hljs-number">1</span>) &#123;<br>                down = !down;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (StringBuilder row : sb) &#123;<br>            res.append(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 692. Top K Frequent Words</title>
    <link href="/posts/3993399751.html"/>
    <url>/posts/3993399751.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of strings words and an integer k, return the k most frequent strings.</p><p>Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.</p><p>Example 1:<br>Input: words &#x3D; [“i”,”love”,”leetcode”,”i”,”love”,”coding”], k &#x3D; 2<br>Output: [“i”,”love”]<br>Explanation: “i” and “love” are the two most frequent words.<br>Note that “i” comes before “love” due to a lower alphabetical order.</p><p>Example 2:<br>Input: words &#x3D; [“the”,”day”,”is”,”sunny”,”the”,”the”,”the”,”sunny”,”is”,”is”], k &#x3D; 4<br>Output: [“the”,”is”,”sunny”,”day”]<br>Explanation: “the”, “is”, “sunny” and “day” are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.</p><p>Constraints:<br>1 &lt;&#x3D; words.length &lt;&#x3D; 500<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 10<br>words[i] consists of lowercase English letters.<br>k is in the range [1, The number of unique words[i]]</p><p>Follow-up: Could you solve it in O(n log(k)) time and O(n) extra space?</p><p>前K个高频单词。</p><blockquote><p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/top-k-frequent-words">https://leetcode.cn/problems/top-k-frequent-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路-最小堆"><a href="#思路-最小堆" class="headerlink" title="思路 - 最小堆"></a>思路 - 最小堆</h2><p>因为是前 K 个 XX 的题型所以思路不是优先队列就是 bucket sort。本题是用到 heap&#x2F;priority queue。先用 hashmap 存每个单词和他们出现的频率，然后用 pq 创建一个最小堆，并且做一个 comparator 比较单词出现的频率，如果两个单词的出现频率相同，则比较两个单词的字典序，字典序小的在前，否则就按照这两个单词的出现频率从大到小排序。</p><p>这样排序，频率小的单词更靠近堆顶，字典序大的单词更靠近堆顶，所以弹出的时候，需要把 list 反转一下。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogk)<br>空间O(k)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">topKFrequent</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> k)</span> &#123;<br>        HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            map.put(word, map.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 小频率在堆顶 → 被先 poll 掉 → 最后留下的是频率大的</span><br>        <span class="hljs-comment">// 如果频率相同，我们要留下字典序小的，所以堆顶是字典序大的</span><br>        PriorityQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">freq1</span> <span class="hljs-operator">=</span> map.get(a);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">freq2</span> <span class="hljs-operator">=</span> map.get(b);<br>            <span class="hljs-keyword">if</span> (freq1 != freq2) &#123;<br>                <span class="hljs-keyword">return</span> freq1 - freq2;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> b.compareTo(a);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;<br>            queue.offer(key);<br>            <span class="hljs-keyword">if</span> (queue.size() &gt; k) &#123;<br>                queue.poll();<br>            &#125;<br>        &#125;<br><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            res.add(queue.poll());<br>        &#125;<br>        Collections.reverse(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// min heap</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sort</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 450. Delete Node in a BST</title>
    <link href="/posts/4075304350.html"/>
    <url>/posts/4075304350.html</url>
    
    <content type="html"><![CDATA[<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p><p>Basically, the deletion can be divided into two stages:</p><p>Search for a node to remove.<br>If the node is found, delete the node.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt="Example 1"><br>Input: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>Output: [5,4,6,2,null,null,7]<br>Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.<br>One valid answer is [5,4,6,2,null,null,7], shown in the above BST.<br>Please notice that another valid answer is [5,2,6,null,4,null,7] and it’s also accepted.</p><p>Example 2:<br>Input: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0<br>Output: [5,3,6,2,4,null,7]<br>Explanation: The tree does not contain a node with value &#x3D; 0.</p><p>Example 3:<br>Input: root &#x3D; [], key &#x3D; 0<br>Output: []</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 104].<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>Each node has a unique value.<br>root is a valid binary search tree.<br>-105 &lt;&#x3D; key &lt;&#x3D; 105</p><p>Follow up: Could you solve it with time complexity O(height of tree)?</p><p>删除二叉搜索树中的节点。</p><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；<br>如果找到了，删除它。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/delete-node-in-a-bst">https://leetcode.cn/problems/delete-node-in-a-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为是BST，所以找节点和删除节点还是有一定规律可循的。首先，找到要删除的节点不难，如果 root.val &lt; key 就往右走；如果 root.val &gt; key 就往左走，直到找到要删除的节点。接下来就要考虑删除节点的情况了：</p><ol><li>如果要删除的节点没有左子树或者右子树，说明他是一个叶子节点，直接返回 null 即可。</li><li>如果要删除的节点只有左子树，那就把他的左孩子的值赋给他，然后去左子树里删除这个节点。这就相当于是把这个节点的值替换成了他的左孩子的值。</li><li>如果要删除的节点只有右子树，那就把他的右孩子的值赋给他，然后去右子树里删除这个节点。这就相当于是把这个节点的值替换成了他的右孩子的值。</li><li>如果要删除的节点有左右子树，那就要找到右子树中<code>最小的节点</code>，把这个节点的值赋给要删除的节点，然后去右子树里删除这个最小的节点。这样就相当于是把这个节点的值替换成了他的右孩子的最小值。</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-keyword">if</span> (key &lt; root.val) &#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root.val) &#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 找到要删除的节点</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br><br>            <span class="hljs-comment">// 找到右子树最小值节点</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> getMin(root.right);<br>            root.val = minNode.val;<br>            <span class="hljs-comment">// 删除右子树中的最小节点</span><br>            root.right = deleteNode(root.right, minNode.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取以 node 为根的子树中的最小节点</span><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">getMin</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 572. Subtree of Another Tree</title>
    <link href="/posts/2990643160.html"/>
    <url>/posts/2990643160.html</url>
    
    <content type="html"><![CDATA[<p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</p><p>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" alt="Example 1"><br>Input: root &#x3D; [3,4,5,1,2], subRoot &#x3D; [4,1,2]<br>Output: true</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg" alt="Example 2"><br>Input: root &#x3D; [3,4,5,1,2,null,null,null,null,0], subRoot &#x3D; [4,1,2]<br>Output: false</p><p>Constraints:<br>The number of nodes in the root tree is in the range [1, 2000].<br>The number of nodes in the subRoot tree is in the range [1, 1000].<br>-104 &lt;&#x3D; root.val &lt;&#x3D; 104<br>-104 &lt;&#x3D; subRoot.val &lt;&#x3D; 104</p><p>另一个树的子树。</p><blockquote><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。<br>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/subtree-of-another-tree">https://leetcode.cn/problems/subtree-of-another-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给两个树 root 和 subRoot，判断 subRoot 是否是 root 的子树。如果两者相同，也可以视为 subRoot 是 root 的子树。<br>这个题的思路跟100题same tree非常像。既然是问  subRoot 是否是 root 的子树，那也就意味着 root 这棵树比 subRoot 要大，或者最多相同，所以就可以按照100题的思路递归比较</p><ul><li>root 的左子树和右子树是否分别和 subRoot 一样</li><li>root 是否和 subRoot 是相同的树</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (subRoot == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot) || helper(root, subRoot);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p.val != q.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> helper(p.left, q.left) &amp;&amp; helper(p.right, q.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">t</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isSubtree = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) &#123;<br><span class="hljs-keyword">if</span> (s === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (t === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSameTree</span>(s, t)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">isSubtree</span>(s.<span class="hljs-property">left</span>, t) || <span class="hljs-title function_">isSubtree</span>(s.<span class="hljs-property">right</span>, t) || <span class="hljs-title function_">isSameTree</span>(s, t);<br>&#125;;<br><br><span class="hljs-keyword">var</span> isSameTree = <span class="hljs-keyword">function</span> (<span class="hljs-params">s, t</span>) &#123;<br><span class="hljs-keyword">if</span> (s === <span class="hljs-literal">null</span> &amp;&amp; t === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (s === <span class="hljs-literal">null</span> || t === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (s.<span class="hljs-property">val</span> != t.<span class="hljs-property">val</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">isSameTree</span>(s.<span class="hljs-property">left</span>, t.<span class="hljs-property">left</span>) &amp;&amp; <span class="hljs-title function_">isSameTree</span>(s.<span class="hljs-property">right</span>, t.<span class="hljs-property">right</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1122. Relative Sort Array</title>
    <link href="/posts/3311195696.html"/>
    <url>/posts/3311195696.html</url>
    
    <content type="html"><![CDATA[<p>Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.</p><p>Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.</p><p>Example 1:<br>Input: arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]<br>Output: [2,2,2,1,4,3,3,9,6,7,19]</p><p>Example 2:<br>Input: arr1 &#x3D; [28,6,22,8,44,17], arr2 &#x3D; [22,28,8,6]<br>Output: [22,28,8,6,17,44]</p><p>Constraints:<br>1 &lt;&#x3D; arr1.length, arr2.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; arr1[i], arr2[i] &lt;&#x3D; 1000<br>All the elements of arr2 are distinct.<br>Each arr2[i] is in arr1.</p><p>数组的相对排序。</p><blockquote>给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。<p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是用 counting sort（计数排序）做，用一个长度为 1001（Java需要定义长度）的数组（bucket）记录每个数字在 arr1 中出现的次数，然后根据数字在 arr2 中出现与否来改动arr1，使得在 arr2 中有的数字在 arr1 中能按照他们的相对顺序重新排列；再次扫描 bucket，把 arr1 中有但是 arr2 中没有的元素添加到 arr1 的末端。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>        <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1001</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr1) &#123;<br>            map[num]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr2) &#123;<br>            <span class="hljs-keyword">while</span> (map[num] != <span class="hljs-number">0</span>) &#123;<br>                arr1[index++] = num;<br>                map[num]--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; map.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (map[i] != <span class="hljs-number">0</span>) &#123;<br>                arr1[index++] = i;<br>                map[i]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">arr2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> relativeSortArray = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr1, arr2</span>) &#123;<br>    <span class="hljs-keyword">let</span> bucket = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr1.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (bucket[arr1[i]]) &#123;<br>            bucket[arr1[i]]++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            bucket[arr1[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr2.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">while</span> (bucket[arr2[j]]) &#123;<br>            res.<span class="hljs-title function_">push</span>(arr2[j]);<br>            bucket[arr2[j]]--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> bucket) &#123;<br>        <span class="hljs-keyword">while</span> (bucket[key]) &#123;<br>            res.<span class="hljs-title function_">push</span>(key);<br>            bucket[key]--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>counting sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 236. Lowest Common Ancestor of a Binary Tree</title>
    <link href="/posts/3816757317.html"/>
    <url>/posts/3816757317.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="Example 1"><br>Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="Example 2"><br>Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p><p>Example 3:<br>Input: root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>Output: 1</p><p>Constraints:<br>The number of nodes in the tree is in the range [2, 105].<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>All Node.val are unique.<br>p !&#x3D; q<br>p and q will exist in the tree.</p><p>二叉树的最近公共祖先。</p><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目跟235题很接近，唯一的不同是235题是一个二叉搜索树（BST），本题是一个二叉树。本题只能用递归做，无法用 BST 的性质判断 p 和 q 到底是在左子树还是在右子树。这道题很考验对递归的理解，以及子节点往父节点返回信息的理解。我参考了<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-x-tl5b/">这个帖子</a>。</p><ul><li>如果我们遇到的是 p 或 q 其中的一个，我们往上一层返回 p 或 q，这样我告诉我的父节点在我这里有其中一个目标值，否则我只能返回 null</li><li>在某个节点，如果他的左右孩子都不为空，那么说明这个节点就是要找的最小公共祖先</li><li>如果在某个节点他的左右孩子其中有一个为 null，往上返回不为空的那个，这样我可以告诉我的父节点，在我这里有其中一个目标值</li></ul><p>分享<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/">一个动图</a>理解递归的过程。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 最坏情况会遍历树中所有的 node<br>空间O(h) - 树的高度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">// 如果遍历过程中遇到了p或者q，就往上返回这个节点，否则就往上一层返回null</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">// 分别递归去看左右子树</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-comment">// 走到某个节点，如果发现他的左右孩子都不为空，说明当前节点就是最小公共祖先</span><br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 如果只找到一个孩子，需要给父节点返回另一个不为空的孩子</span><br>        <span class="hljs-keyword">return</span> left == <span class="hljs-literal">null</span> ? right : left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">p</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">q</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, p, q</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">left</span>, p, q);<br>    <span class="hljs-keyword">let</span> right = <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">right</span>, p, q);<br>    <span class="hljs-keyword">if</span> (left !== <span class="hljs-literal">null</span> &amp;&amp; right !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left == <span class="hljs-literal">null</span> ? right : left;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">235. Lowest Common Ancestor of a Binary Search Tree<br>236. Lowest Common Ancestor of a Binary Tree<br>865. Smallest Subtree with all the Deepest Nodes<br>1257. Smallest Common Region<br>1650. Lowest Common Ancestor of a Binary Tree III<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>recursion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 235. Lowest Common Ancestor of a Binary Search Tree</title>
    <link href="/posts/3054890269.html"/>
    <url>/posts/3054890269.html</url>
    
    <content type="html"><![CDATA[<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Example 1"><br>Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="Example 2"><br>Input: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>Output: 2<br>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p><p>Example 3:<br>Input: root &#x3D; [2,1], p &#x3D; 2, q &#x3D; 1<br>Output: 2</p><p>Constraints:<br>The number of nodes in the tree is in the range [2, 105].<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>All Node.val are unique.<br>p !&#x3D; q<br>p and q will exist in the BST.</p><p>二叉搜索树的最小公共祖先。</p><blockquote>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>影子题236。题意是给一个二叉搜索树（BST）和两个节点 p 和 q，请找出两个节点的最小公共祖先。思路是递归，因为BST的性质，所以任何节点的左孩子一定比当前节点小，右孩子一定比当前节点大。明白这一点，代码就不难写。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(h) - h 是树的高度<br>空间O(h)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">p</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">q</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, p, q</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> &gt; p.<span class="hljs-property">val</span> &amp;&amp; root.<span class="hljs-property">val</span> &gt; q.<span class="hljs-property">val</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">left</span>, p, q);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> &lt; p.<span class="hljs-property">val</span> &amp;&amp; root.<span class="hljs-property">val</span> &lt; q.<span class="hljs-property">val</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">right</span>, p, q);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">235. Lowest Common Ancestor of a Binary Search Tree<br>236. Lowest Common Ancestor of a Binary Tree<br>865. Smallest Subtree with all the Deepest Nodes<br>1257. Smallest Common Region<br>1650. Lowest Common Ancestor of a Binary Tree III<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>recursion</tag>
      
      <tag>bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 295. Find Median from Data Stream</title>
    <link href="/posts/1598623452.html"/>
    <url>/posts/1598623452.html</url>
    
    <content type="html"><![CDATA[<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p><p>For example, for arr &#x3D; [2,3,4], the median is 3.<br>For example, for arr &#x3D; [2,3], the median is (2 + 3) &#x2F; 2 &#x3D; 2.5.<br>Implement the MedianFinder class:</p><p>MedianFinder() initializes the MedianFinder object.<br>void addNum(int num) adds the integer num from the data stream to the data structure.<br>double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.</p><p>Example 1:<br>Input<br>[“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]<br>Output<br>[null, null, null, 1.5, null, 2.0]</p><p>Explanation<br>MedianFinder medianFinder &#x3D; new MedianFinder();<br>medianFinder.addNum(1); &#x2F;&#x2F; arr &#x3D; [1]<br>medianFinder.addNum(2); &#x2F;&#x2F; arr &#x3D; [1, 2]<br>medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)<br>medianFinder.addNum(3); &#x2F;&#x2F; arr[1, 2, 3]<br>medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</p><p>Constraints:<br>-105 &lt;&#x3D; num &lt;&#x3D; 105<br>There will be at least one element in the data structure before calling findMedian.<br>At most 5 ^ 104 calls will be made to addNum and findMedian.</p><p>Follow up:<br>If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?<br>If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?</p><p>数据流的中位数。</p><blockquote>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例：</p><p>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2<br>进阶:</p><p>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-median-from-data-stream">https://leetcode.cn/problems/find-median-from-data-stream</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数据流，请根据题意设计几个函数。</p><p>其中需要实现的函数是<code>addNum()</code>和<code>findMedian()</code>。</p><p>思路是用两个堆做，一个是<code>最大堆</code>一个是<code>最小堆</code>。<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/">这个图示</a>应该能清楚说明问题。</p><p>我们使用 两个堆（优先队列） 来维护数据流中的前一半和后一半：</p><ul><li>maxHeap：最大堆，存储较小的一半（即左边）</li><li>minHeap：最小堆，存储较大的一半（即右边）</li></ul><p>维护规则：</p><ul><li>所有元素分为两部分放入 maxHeap 和 minHeap</li><li>maxHeap.size() 总是等于或多于 minHeap.size()（差距不超过 1）</li><li>所有 maxHeap 中的元素都小于等于 minHeap 中的元素</li></ul><p>中位数的定义：</p><ul><li>如果总数为奇数，返回 maxHeap.peek()</li><li>如果总数为偶数，返回 (maxHeap.peek() + minHeap.peek()) &#x2F; 2.0</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogk) - pq的操作<br>空间O(n) - pq</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    PriorityQueue&lt;Integer&gt; maxHeap;<br>    PriorityQueue&lt;Integer&gt; minHeap;<br>    <span class="hljs-type">boolean</span> even;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>        maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());<br>        minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        even = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (even) &#123;<br>            minHeap.offer(num);<br>            maxHeap.offer(minHeap.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            maxHeap.offer(num);<br>            minHeap.offer(maxHeap.poll());<br>        &#125;<br>        even = !even;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (even) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) (maxHeap.peek() + minHeap.peek()) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) maxHeap.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj.addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj.findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">295. Find Median from Data Stream<br>480. Sliding Window Median<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 347. Top K Frequent Elements</title>
    <link href="/posts/445851025.html"/>
    <url>/posts/445851025.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.</p><p>Example 1:<br>Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>Output: [1,2]</p><p>Example 2:<br>Input: nums &#x3D; [1], k &#x3D; 1<br>Output: [1]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>k is in the range [1, the number of unique elements in the array].<br>It is guaranteed that the answer is unique.</p><p>Follow up: Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p><p>前 K 个高频元素。</p><blockquote>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前 K 个 XX 的题型思路大多不是 pq 就是 bucket sort。题目要求时间复杂度必须优于 O(nlogn)。<br>因为题目有时间复杂度的要求所以只能是 bucket sort 桶排序的思想做。</p><p>解释一下思路，既然是桶排序，所以需要将出现频率一样的元素放到同一个桶里面，所以这里会用到一个 hashmap 记录数字和他们各自出现频率（key:value）。接着就需要根据频率大小，挑出前 K 个频率最大的元素。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 题目要求<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br><span class="hljs-comment">// 记录不同元素分别出现的个数</span><br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// bucket sort</span><br>List&lt;Integer&gt;[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[nums.length + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> map.get(key);<br><span class="hljs-comment">// 把出现次数相同的元素放在同一个桶里</span><br><span class="hljs-keyword">if</span> (bucket[freq] == <span class="hljs-literal">null</span>) &#123;<br>bucket[freq] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br>bucket[freq].add(key);<br>&#125;<br><br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 从出现次数大的桶开始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bucket.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; k; i--) &#123;<br><span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : bucket[i]) &#123;<br>res[index++] = num;<br><span class="hljs-keyword">if</span> (index == k) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>bucket sort</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 41. First Missing Positive</title>
    <link href="/posts/1855473463.html"/>
    <url>/posts/1855473463.html</url>
    
    <content type="html"><![CDATA[<p>Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.</p><p>You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,0]<br>Output: 3<br>Explanation: The numbers in the range [1,2] are all in the array.</p><p>Example 2:<br>Input: nums &#x3D; [3,4,-1,1]<br>Output: 2<br>Explanation: 1 is in the array but 2 is missing.</p><p>Example 3:<br>Input: nums &#x3D; [7,8,9,11,12]<br>Output: 1<br>Explanation: The smallest positive integer 1 is missing.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p><p>缺失的第一个正数。</p><blockquote>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/first-missing-positive">https://leetcode.cn/problems/first-missing-positive</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意这道题对时间空间复杂度是有要求的，因为时间要求是 O(n) 所以没法排序；也不允许使用额外空间，所以不能用 hashmap 或者 hashset。那么这题的思路就只能是类似桶排序&#x2F;抽屉原理，需要在对应的坐标上找到对应的数字，即数字 i 应该出现在坐标为 i - 1 的位置上，这样也能排除负数和大于数组长度的正数。 按照这个思路，需要扫描两遍，第一遍是将所有大于 0 且小于数组长度的正整数放到他们应该去的位置上，因为只有这些数字可以跟下标形成对应关系。第二遍再次扫描 input 的时候就能找出第一个缺失的正数了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 题目要求<br>空间O(1) - 题目要求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-comment">// 如果swap的动作按照注释中的部分写</span><br><span class="hljs-comment">// 一定要把nums[nums[i] - 1]先赋值给temp，否则如下的case是会越界的</span><br><span class="hljs-comment">// [3, 4, -1, 1]</span><br><span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br><span class="hljs-comment">// int temp = nums[nums[i] - 1];</span><br><span class="hljs-comment">// nums[nums[i] - 1] = nums[i];</span><br><span class="hljs-comment">// nums[i] = temp;</span><br>swap(nums, i, nums[i] - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// double check</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> nums.length + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>nums[i] = nums[j];<br>nums[j] = tmp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> firstMissingPositive = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (nums === <span class="hljs-literal">null</span> || nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; nums.<span class="hljs-property">length</span> &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] !== nums[i]) &#123;<br>            <span class="hljs-keyword">let</span> temp = nums[nums[i] - <span class="hljs-number">1</span>];<br>            nums[nums[i] - <span class="hljs-number">1</span>] = nums[i];<br>            nums[i] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// double check</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] !== i + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">41. First Missing Positive<br>268. Missing Number<br>442. Find All Duplicates in an Array<br>448. Find All Numbers Disappeared in an Array<br>765. Couples Holding Hands<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>bucket sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 45. Jump Game II</title>
    <link href="/posts/3234829421.html"/>
    <url>/posts/3234829421.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>Example:<br>Input: [2,3,1,1,4]<br>Output: 2<br>Explanation: The minimum number of jumps to reach the last index is 2.<br> Jump 1 step from index 0 to 1, then 3 steps to the last index.</p><p>Note:<br>You can assume that you can always reach the last index.</p><p>跳跃游戏 II。</p><blockquote>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><p>0 &lt;&#x3D; j &lt;&#x3D; nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/jump-game-ii">https://leetcode.cn/problems/jump-game-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟版本一很接近，唯一不同的是版本一是问是否能到达终点；版本二问的是跳到最后一个位置最少需要几步（题目给的 testcase 一定能到达终点）。</p><p>思路也是贪心，但是这个题跟一般的贪心略有不同。我参考了<a href="https://leetcode.cn/problems/jump-game-ii/solutions/2926993/tu-jie-yi-zhang-tu-miao-dong-tiao-yue-yo-h2d4">这个帖子</a>。因为这里求的不是每一次最远能跳几步，而是每次在可跳范围内选择可以使得跳的更远的位置。</p><p>注意代码中 for 循环停下的位置，在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">jump</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 目前能到达的最远位置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">curEnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 下一次能到达的最远位置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">nextEnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>nextEnd = Math.max(nextEnd, i + nums[i]);<br><span class="hljs-keyword">if</span> (i == curEnd) &#123;<br>jump++;<br>curEnd = nextEnd;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> jump;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> jump = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-keyword">let</span> end = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> maxPosition = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> steps = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>maxPosition = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxPosition, nums[i] + i);<br><span class="hljs-keyword">if</span> (i === end) &#123;<br>end = maxPosition;<br>steps++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> steps;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 31. Next Permutation</title>
    <link href="/posts/2197095459.html"/>
    <url>/posts/2197095459.html</url>
    
    <content type="html"><![CDATA[<p>A permutation of an array of integers is an arrangement of its members into a sequence or linear order.</p><p>For example, for arr &#x3D; [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].</p><p>The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p><p>For example, the next permutation of arr &#x3D; [1,2,3] is [1,3,2].</p><p>Similarly, the next permutation of arr &#x3D; [2,3,1] is [3,1,2].</p><p>While the next permutation of arr &#x3D; [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.</p><p>Given an array of integers nums, find the next permutation of nums.</p><p>The replacement must be in place and use only constant extra memory.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3]<br>Output: [1,3,2]</p><p>Example 2:<br>Input: nums &#x3D; [3,2,1]<br>Output: [1,2,3]</p><p>Example 3:<br>Input: nums &#x3D; [1,1,5]<br>Output: [1,5,1]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><p>下一个排列。</p><blockquote>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/next-permutation">https://leetcode.cn/problems/next-permutation</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果 input 本身已经是降序的了，比如 [3, 2, 1]，则返回 [1, 2, 3]。跑一个比较长的例子吧，比如 [1, 5, 8, 4, 7, 6, 5, 3, 1]，它的下一个排列应该是 [1, 5, 8, 5, 1, 3, 4, 6, 7]。因为 input 本身就是 permutation 的一种，又是按字典序，所以发现 4 后面的五个数字是降序的（7, 6, 5, 3, 1）；他的下一个排列是需要找到比 4 大的数里面最小的（5）并且将 4 后面的所有的数字 reverse 成升序。有了这个思路，所以一开始数组需要用一个 i 指针从右往左扫，找到第一个不是升序的数字（4），停下；再用第二个指针 j 从右往左扫第二次，此时找的是第一个比 4 大的数字，会停在 5 的位置；将 4 跟 5 调换一下位置；</p><p>[1, 5, 8, <span style="color:red">4</span>, 7, 6, <span style="color:red">5</span>, 3, 1] -&gt; [1, 5, 8, <span style="color:red">5</span>, 7, 6, <span style="color:red">4</span>, 3, 1]</p><p>最后再反转后五个数字，从而得到下一个排列。</p><p>[1, 5, 8, 5, <span style="background:yellow">7, 6, 4, 3, 1</span>] -&gt; [1, 5, 8, 5, <span style="background:yellow">1, 3, 4, 6, 7</span>]</p><p>类似题目还有556题。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-comment">// i 去找到从后往前的第一个下降点</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>i--;<br>&#125;<br><br><span class="hljs-comment">// j 去找到从后往前的第一个比 nums[i] 大的数</span><br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;<br>j--;<br>&#125;<br>swap(nums, i, j);<br>&#125;<br>reverse(nums, i + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>swap(nums, i, j);<br>i++;<br>j--;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>nums[i] = nums[j];<br>nums[j] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> nextPermutation = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>        i--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> j = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-title function_">swap</span>(nums, i, j);<br>    &#125;<br>    <span class="hljs-title function_">reverse</span>(nums, i + <span class="hljs-number">1</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> reverse = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, start</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = start;<br>    <span class="hljs-keyword">let</span> j = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-title function_">swap</span>(nums, i, j);<br>        i++;<br>        j--;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> swap = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, i, j</span>) &#123;<br>    <span class="hljs-keyword">let</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">31. Next Permutation<br>556. Next Greater Element III<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>permutation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 55. Jump Game</title>
    <link href="/posts/811798551.html"/>
    <url>/posts/811798551.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>Example 1:<br>Input: [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</p><p>Example 2:<br>Input: [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br> jump length is 0, which makes it impossible to reach the last index.</p><p>跳跃游戏。</p><blockquote>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/jump-game">https://leetcode.cn/problems/jump-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个非负整数数组，数字代表你在该位置可以跳跃的最大长度（注意：你不一定需要跳这么远），你的起点是在数组的第一个位置。判断你是否能跳跃到数组的最后一个位置。</p><p>这题有别的解法但是我这里给出的是贪心的思路。设一个变量 k，记录最远可以到达的 index，初始化 k &#x3D; 0。遍历数组的时候，一旦发现 i &gt; k 就说明 i 点的坐标是无法达到的，返回 false；更新 k 的方式是 i + nums[i]，表示在 i 位置最远可以跳到什么位置。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; max) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            max = Math.max(max, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canJump = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        k = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(k, i + nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 452. Minimum Number of Arrows to Burst Balloons</title>
    <link href="/posts/3476678931.html"/>
    <url>/posts/3476678931.html</url>
    
    <content type="html"><![CDATA[<p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p><p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p><p>Example:<br>Input:<br>[[10,16], [2,8], [1,6], [7,12]]</p><p>Output:<br>2</p><p>Explanation:<br>One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons).</p><p>用最少数量的箭引爆气球。</p><blockquote>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个数组，数组里面存的是类似 [left, right] 这样的区间，left 和 right 分别代表气球直径的起点和终点。求问如果要引爆所有的气球最少需要几只箭。</p><p>思路是贪心，类似会议室二。先对所有气球直径的终点排序，然后以第一个气球的终点为起点开始看，如果第二个气球的起点大于第一个气球的终点，就说明两个气球不重叠，则需要另一个箭；同时挪动 end 指针到第二个气球的终点。end 指针可以理解为箭指向的位置，如果下一个气球的起点跟箭不重叠，则需要下一个箭了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> points.length;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (points == <span class="hljs-literal">null</span> || len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (end &lt; points[i][<span class="hljs-number">0</span>]) &#123;<br>                res++;<br>                end = points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">points</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findMinArrowShots = <span class="hljs-keyword">function</span> (<span class="hljs-params">points</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (points === <span class="hljs-literal">null</span> || points.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// normal case</span><br>    points = points.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> firstEnd = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; firstEnd) &#123;<br>            res++;<br>            firstEnd = points[i][<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 225. Implement Stack using Queues</title>
    <link href="/posts/479904417.html"/>
    <url>/posts/479904417.html</url>
    
    <content type="html"><![CDATA[<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).</p><p>Implement the MyStack class:<br>void push(int x) Pushes element x to the top of the stack.<br>int pop() Removes the element on the top of the stack and returns it.<br>int top() Returns the element on the top of the stack.<br>boolean empty() Returns true if the stack is empty, false otherwise.</p><p>Notes:<br>You must use only standard operations of a queue, which means that only push to back, peek&#x2F;pop from front, size and is empty operations are valid.</p><p>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations.</p><p>Example 1:<br>Input<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>Output<br>[null, null, null, 2, 2, false]</p><p>Explanation<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; return 2<br>myStack.pop(); &#x2F;&#x2F; return 2<br>myStack.empty(); &#x2F;&#x2F; return False</p><p>Constraints:<br>1 &lt;&#x3D; x &lt;&#x3D; 9<br>At most 100 calls will be made to push, pop, top, and empty.<br>All the calls to pop and top are valid.<br>Follow-up: Can you implement the stack using only one queue?</p><p>用队列实现栈。</p><blockquote>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<p>实现 MyStack 类：<br>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p>注意：<br>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-stack-using-queues">https://leetcode-cn.com/problems/implement-stack-using-queues</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意这一题的 followup 是问你是否可以只用一个 queue。这一题的 JavaScript 代码会简单很多，因为在 JavaScript 中，队列和栈都是用数组实现的，用法类似 Java 里的 deque。依然解释一下几个函数的实现方式。</p><p>push(x) - 将元素推进栈。时间均摊O(n)，因为涉及到会扩大内存的动作。<br>举个例子，比如此时 queue 中的元素从左到右是 [1, 2, 3]，此时你需要 push 一个新的元素 4，我们要做的是把 4 push 进 queue 的同时将前面所有的元素再拿出来放到 4 的后面，最后 queue 会变成这样<br>[4, 1, 2, 3]</p><p>pop() – 将栈顶元素弹出。时间O(1)</p><p>top() – 等同于peek，看一下栈顶元素是什么。时间O(1)</p><p>empty() – 判断栈是否为空。时间O(1)</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>同上</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    Queue&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        queue.offer(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queue.size() - <span class="hljs-number">1</span>; i++) &#123;<br>            queue.offer(queue.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyStack</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push element x onto stack.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>] = x;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element on top of the stack and returns that element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the top element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">top</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns whether the stack is empty.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">empty</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MyStack()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * var param_2 = obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.top()</span><br><span class="hljs-comment"> * var param_4 = obj.empty()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">225. Implement Stack using Queues<br>232. Implement Queue using Stacks<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>design</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 232. Implement Queue using Stacks</title>
    <link href="/posts/1196770022.html"/>
    <url>/posts/1196770022.html</url>
    
    <content type="html"><![CDATA[<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</p><p>Implement the MyQueue class:<br>void push(int x) Pushes element x to the back of the queue.<br>int pop() Removes the element from the front of the queue and returns it.<br>int peek() Returns the element at the front of the queue.<br>boolean empty() Returns true if the queue is empty, false otherwise.</p><p>Notes:<br>You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid.<br>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</p><p>Example 1:<br>Input<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>Output<br>[null, null, null, 1, 1, false]</p><p>Explanation<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p><p>Constraints:<br>1 &lt;&#x3D; x &lt;&#x3D; 9<br>At most 100 calls will be made to push, pop, peek, and empty.<br>All the calls to pop and peek are valid.</p><p>Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.</p><p>用栈模拟队列。</p><blockquote>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<p>实现 MyQueue 类：<br>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p>说明：<br>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/implement-queue-using-stacks">https://leetcode.cn/problems/implement-queue-using-stacks</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>同理参考影子题225题。</p><p>题干即是题意，用栈实现队列的几个函数，例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Example:<br>MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);  <br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// returns 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><p>思路是需要用到两个栈，用 first 和 second 表示。以下分别解释一下每个函数的实现方式。</p><p>push() - 将元素加入队列。这没什么可说的，加入到第一个栈 first 中。时间O(1)</p><p>pop() - 弹出队列的首个元素。因为 stack 只会弹出最后一个放入的元素，所以只能通过将第一个 stack 中的元素全部倒入第二个 stack 中，再 pop 第二个 stack 栈顶元素的方式，得到 queue 的首个元素。时间是均摊的 O(n)</p><p>peek() - 看一下队列顶端的元素。因为 peek 的功能几乎跟 pop 无异，pop 会弹出首个元素，peek 只是看一下，所以做法跟 pop 几乎相同，也是需要将所有元素都倒入第二个 stack 中再 peek 第二个 stack 的栈顶元素。时间O(1)</p><p>empty() - 检测队列是否为空。只要看一下两个 stack 是否都为空即可。时间O(1)</p><p>最后分享一个B站非常好的视频讲解，<a href="https://www.bilibili.com/video/av86054613/">https://www.bilibili.com/video/av86054613/</a></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间 - 同上<br>空间 - 两个 stack，O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    Stack&lt;Integer&gt; first;<br>    Stack&lt;Integer&gt; second;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        second = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        first.add(x);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!second.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> second.pop();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!first.isEmpty()) &#123;<br>            second.add(first.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> second.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!second.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> second.peek();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!first.isEmpty()) &#123;<br>            second.add(first.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> second.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first.isEmpty() &amp;&amp; second.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyQueue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span> = [];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push element x to the back of queue.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-title function_">push</span>(x);<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element from in front of queue and returns that element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// if the second stack is empty, move everything from first to second</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-title function_">pop</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-title function_">pop</span>();<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the front element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">peek</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// almost same as pop()</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-title function_">pop</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns whether the queue is empty.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">empty</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-property">length</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span>.<span class="hljs-property">length</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MyQueue()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * var param_2 = obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.peek()</span><br><span class="hljs-comment"> * var param_4 = obj.empty()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">225. Implement Stack using Queues<br>232. Implement Queue using Stacks<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>design</tag>
      
      <tag>stack</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 146. LRU Cache</title>
    <link href="/posts/1072577098.html"/>
    <url>/posts/1072577098.html</url>
    
    <content type="html"><![CDATA[<p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p><p>Implement the LRUCache class:</p><ul><li>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li><li>int get(int key) Return the value of the key if the key exists, otherwise return -1.</li><li>void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.<br>The functions get and put must each run in O(1) average time complexity.</li></ul><p>Example 1:<br>Input<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>Output<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>Explanation<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; cache is {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; cache is {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; return 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; LRU key was 2, evicts key 2, cache is {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; returns -1 (not found)<br>lRUCache.put(4, 4); &#x2F;&#x2F; LRU key was 1, evicts key 1, cache is {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; return -1 (not found)<br>lRUCache.get(3);    &#x2F;&#x2F; return 3<br>lRUCache.get(4);    &#x2F;&#x2F; return 4</p><p>Constraints:<br>1 &lt;&#x3D; capacity &lt;&#x3D; 3000<br>0 &lt;&#x3D; key &lt;&#x3D; 104<br>0 &lt;&#x3D; value &lt;&#x3D; 105<br>At most 2 * 105 calls will be made to get and put.</p><p>LRU 缓存。</p><blockquote><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br><span style="color: red">函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/lru-cache">https://leetcode.cn/problems/lru-cache</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实现这个缓存器，时间复杂度要求是O(1)。LRU缓存器是在一定的容量范围内存了一些node，按照上一次被访问的时间由新到旧排列，越近被访问的node应该排得越靠前。一个很容易理解的例子就是手机的后台，最近使用的APP最靠前，内存不足的时候，会释放上一次使用时间最远的APP。</p><p>思路是双向链表（DLL） + hashmap。因为题意要求了时间复杂度必须是O(1)所以只有 hashmap 和链表才能满足这个时间复杂度。至于为什么是DLL而不是单链表，则是为了node之间的移动方便，也是为了添加删除节点的时候能更加高效。这里解释一下两个函数的实现细节。</p><p>get函数，就是在hashmap里面寻找目标。如果有则先删除这个目标，再加进去，再返回，没有则返回-1；同时DLL里面，如果没有这个目标则什么都不做，如果有这个目标则需要把这个node移动到头节点。</p><p>put函数，如果node之前存在过，则hashmap没有动作，DLL里面需要把这个node放到头节点；如果node不存在，需要看一下此时此刻node的数量是否超过cache的容量capacity，如果没超过就直接把node放到DLL的头节点，放入hashmap并size++，如果超过了capacity，要先去掉DLL的tail节点，再加入当前节点。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - required<br>空间O(n) - hashmap + DLL</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        Node prev;<br>        Node next;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// always add the node after the head</span><br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> node.prev;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>        prev.next = next;<br>        next.prev = prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(Node node)</span> &#123;<br>        removeNode(node);<br>        addNode(node);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">popTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> tail.prev;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> Node head, tail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>            newNode.key = key;<br>            newNode.value = value;<br>            cache.put(key, newNode);<br>            addNode(newNode);<br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> popTail();<br>                cache.remove(tail.key);<br>                size--;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">146. LRU Cache<br>460. LFU Cache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>design</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 977. Squares of a Sorted Array</title>
    <link href="/posts/1991592077.html"/>
    <url>/posts/1991592077.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.</p><p>Example 1:<br>Input: nums &#x3D; [-4,-1,0,3,10]<br>Output: [0,1,9,16,100]<br>Explanation: After squaring, the array becomes [16,1,0,9,100].<br>After sorting, it becomes [0,1,9,16,100].</p><p>Example 2:<br>Input: nums &#x3D; [-7,-3,2,3,11]<br>Output: [4,9,9,49,121]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums is sorted in non-decreasing order.</p><p>Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?</p><p>有序数组的平方。</p><blockquote><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是 two pointer 夹逼。创建一个跟 input 同样长度的数组。因为 input 里面存在负数，而且很有可能存在一个绝对值非常大的负数，导致其平方值最大，所以需要 two pointer 左右指针比较哪个数字的绝对值大。细节实现参见代码。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(nums[left]) &gt; Math.abs(nums[right])) &#123;<br>                res[index--] = nums[left] * nums[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[index--] = nums[right] * nums[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">A</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortedSquares = <span class="hljs-keyword">function</span> (<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> n = A.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> res = [n];<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p = n - <span class="hljs-number">1</span>; p &gt;= <span class="hljs-number">0</span>; p--) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(A[i]) &gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(A[j])) &#123;<br>            res[p] = A[i] * A[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[p] = A[j] * A[j];<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 498. Diagonal Traverse</title>
    <link href="/posts/3904628621.html"/>
    <url>/posts/3904628621.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt="Image"><br>Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>Output: [1,2,4,7,5,3,6,8,9]</p><p>Example 2:<br>Input: mat &#x3D; [[1,2],[3,4]]<br>Output: [1,2,3,4]</p><p>Constraints:<br>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 104<br>1 &lt;&#x3D; m * n &lt;&#x3D; 104<br>-105 &lt;&#x3D; mat[i][j] &lt;&#x3D; 105</p><p>对角线遍历。</p><blockquote><p>给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题没有什么算法，难点是如何判断到底是往上扫描还是往下扫描以及如何判断边界条件。</p><p>首先发现如果是从左下往右上遍历，每个遍历到的点的横纵坐标的加和（x+y）% 2 &#x3D;&#x3D; 0，比如1的坐标是（0,0），7的坐标是（0,2），5的坐标是（1,1）；如果是从右上往左下遍历，遍历到的点的横纵坐标的加和（x+y）% 2 &#x3D;&#x3D; 1，比如2的坐标（1，0），4的坐标（0,1）。这是一个仅限于这一题的结论。碰到边界条件只有两种可能，一是左下往右上走的时候确保纵坐标不要超出右边的边界和横坐标不要小于0；二是右上往左下走的时候确保横坐标不要大于矩阵的高和纵坐标不要超出左边的边界。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(mn) - 存储output</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findDiagonalOrder(<span class="hljs-type">int</span>[][] matrix) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m * n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;<br>res[i] = matrix[row][col];<br><span class="hljs-comment">// moving up</span><br><span class="hljs-keyword">if</span> ((row + col) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (col == n - <span class="hljs-number">1</span>) &#123;<br>row++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span>) &#123;<br>col++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>row--;<br>col++;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (row == m - <span class="hljs-number">1</span>) &#123;<br>col++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (col == <span class="hljs-number">0</span>) &#123;<br>row++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>row++;<br>col--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 155. Min Stack</title>
    <link href="/posts/4038167410.html"/>
    <url>/posts/4038167410.html</url>
    
    <content type="html"><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the MinStack class:</p><p>MinStack() initializes the stack object.<br>void push(int val) pushes the element val onto the stack.<br>void pop() removes the element on the top of the stack.<br>int top() gets the top element of the stack.<br>int getMin() retrieves the minimum element in the stack.</p><p>You must implement a solution with O(1) time complexity for each function.</p><p>Example 1:<br>Input<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>Output<br>[null,null,null,null,-3,null,0,-2]</p><p>Explanation<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin(); &#x2F;&#x2F; return -3<br>minStack.pop();<br>minStack.top(); &#x2F;&#x2F; return 0<br>minStack.getMin(); &#x2F;&#x2F; return -2</p><p>Constraints:<br>-231 &lt;&#x3D; val &lt;&#x3D; 231 - 1<br>Methods pop, top and getMin operations will always be called on non-empty stacks.<br>At most 3 * 104 calls will be made to push, pop, top, and getMin.</p><p>最小栈。</p><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题我给出两种解法，一种用了两个 stack，一种只需要用一个 stack。两种做法的复杂度都是<br>时间O(1)<br>空间O(n)</p><h2 id="思路一-两个stack"><a href="#思路一-两个stack" class="headerlink" title="思路一 - 两个stack"></a>思路一 - 两个stack</h2><p>两个 stack。创建两个 stack，一个叫 stack，另一个叫做 minstack。</p><ul><li>push() - 每当需要 push 的时候，每个元素都会被正常 push 到 stack，同时需要看一下当前元素与全局最小元素 min 的关系，以决定是否需要把这个元素 push 到 minStack。minStack 只 push 当前遍历到的最小值。</li><li>pop() - stack 会正常 pop 出当前元素；因为 minStack 的顶端存的永远是当前的最小值，所以当 stack 弹出一个元素 X 的时候，需要去 minStack 的栈顶看一下 X 是不是最小值，也就是看一下 minStack 的栈顶是不是也是 X，如是，也需要从 minStack 弹出，这样 minStack 顶端保留的永远是最小值。</li><li>top() - 同 peek()，只是看一下 stack 顶端的元素</li><li>getMin() - 去 peek minStack 顶端的元素，因为 minStack 的顶端永远是当前遍历到的最小值</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minStack;<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stack.push(x);<br>        <span class="hljs-keyword">if</span> (!minStack.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> minStack.peek();<br>            <span class="hljs-keyword">if</span> (x &lt;= min) &#123;<br>                minStack.push(x);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minStack.push(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-keyword">if</span> (x == minStack.peek()) &#123;<br>            minStack.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">MinStack</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span> = [];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> top = <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (x &lt;= top) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-title function_">push</span>(x);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-title function_">push</span>(x);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> pop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">let</span> top = <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (pop === top) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">top</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getMin</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">minStack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MinStack()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.top()</span><br><span class="hljs-comment"> * var param_4 = obj.getMin()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="思路二-一个stack"><a href="#思路二-一个stack" class="headerlink" title="思路二 - 一个stack"></a>思路二 - 一个stack</h2><p>一个 stack，同时创建一个变量记录最小值 min。我参考了<a href="https://leetcode.cn/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/">这个帖子</a>的解法二。</p><ul><li>push() - push 的时候看一下当前元素是否比 min 小，若是则把上一个min再次放进stack，同时更新当前最小值 min。</li><li>pop() - 如果弹出值 &#x3D;&#x3D; 当前最小值，那么再弹一次的值为上一个最小值也即出栈后更新的最小值</li><li>top() - 同 peek，只是看一下 stack 顶端的元素</li><li>getMin() - 输出 min 即可</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Stack&lt;Integer&gt; stack;<br>    <span class="hljs-type">int</span> min;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        min = Integer.MAX_VALUE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (val &lt;= min) &#123;<br>            stack.push(min);<br>            min = val;<br>        &#125;<br>        stack.push(val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stack.pop() == min) &#123;<br>            min = stack.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">MinStack</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-comment">// 当前值比min值更小</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span> &gt;= x) &#123;<br>        <span class="hljs-comment">// 将上一个min最小值保存入栈</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span>);<br>        <span class="hljs-comment">// 更新当前最小值</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span> = x;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x)<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 如果弹出值 == 当前最小值，那么再弹一次的值为上一个最小值也即出栈后更新的最小值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>() == <span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">top</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getMin</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">min</span>;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MinStack()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.top()</span><br><span class="hljs-comment"> * var param_4 = obj.getMin()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">155. Min Stack<br>716. Max Stack<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>design</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 73. Set Matrix Zeroes</title>
    <link href="/posts/4041800823.html"/>
    <url>/posts/4041800823.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0’s.</p><p>You must do it in place.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="Example 1"><br>Input: matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]<br>Output: [[1,0,1],[0,0,0],[1,0,1]]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="Example 2"><br>Input: matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]<br>Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[0].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>-231 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 231 - 1</p><p>Follow up:<br>A straightforward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p><p>矩阵置零。</p><blockquote>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数组&#x2F;矩阵类型的题有好几道都明确要求不能使用额外空间，这题也不例外。因为不能用到额外空间，所以只能将是否需要赋零的flag记录在input的数组里面，这里我选择记录在第一行和第一列上。但是我此时仍然需要两个flag来分别记录第一行和第一列上有没有0。因为第一行和第一列上的0有可能是因着记录里面的行和列的结果而被赋值成0的。我参考了<a href="https://www.cnblogs.com/grandyang/p/4341590.html">grandyang大神的思路</a>，非常简洁，列在这里。</p><ul><li>先扫描第一行第一列，如果有0，则将各自的flag设置为true</li><li>然后扫描除去第一行第一列的整个数组，如果有0，则将对应的第一行和第一列的数字赋0</li><li>再次遍历除去第一行第一列的整个数组，如果对应的第一行和第一列的数字有一个为0，则将当前值赋0</li><li>最后根据第一行第一列的flag来更新第一行第一列</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>        <br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// mark if first row and first col has zero</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) row = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) col = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// change the inner part to zeroes based on the first row and first col</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br><span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>matrix[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// change the first row and first col if needed</span><br>        <span class="hljs-keyword">if</span> (row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">matrix</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> setZeroes = <span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || matrix === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> m = matrix.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">let</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> rowZero = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> colZero = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// check if first row has zero</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] === <span class="hljs-number">0</span>) colZero = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// check if first column has zero</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][i] === <span class="hljs-number">0</span>) rowZero = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// scan all the other rows and columns</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] === <span class="hljs-number">0</span>) &#123;<br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// scan again to see if we should mark the whole row or column to be zero</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] === <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] === <span class="hljs-number">0</span>) &#123;<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// check if we should mark the first row and first column to be zero</span><br>    <span class="hljs-keyword">if</span> (rowZero) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (colZero) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">73. Set Matrix Zeroes<br>289. Game of Life<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 59. Spiral Matrix II</title>
    <link href="/posts/2293412747.html"/>
    <url>/posts/2293412747.html</url>
    
    <content type="html"><![CDATA[<p>Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="Example 1"><br>Input: n &#x3D; 3<br>Output: [[1,2,3],[8,9,4],[7,6,5]]</p><p>Example 2:<br>Input: n &#x3D; 1<br>Output: [[1]]</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 20</p><p>螺旋矩阵II。</p><blockquote>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数字 n，请输出一个 n x n 的矩阵，被从 1 到 n 方这 n 方个数字填满。填满的方式同 54 题。</p><p>这个题跟 54 题做法几乎一样。也是要通过找到 row 和 column 的边界来完成填充的动作。首先创建一个 n x n 的二维数组并用0填满。遍历的时候，也是按照右 - 下 - 左 - 上的顺序。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<br>            <span class="hljs-comment">// left to right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                matrix[top][i] = num++;<br>            &#125;<br>            top++;<br><br>            <span class="hljs-comment">// top to bottom</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>                matrix[i][right] = num++;<br>            &#125;<br>            right--;<br><br>            <span class="hljs-comment">// right to left</span><br>            <span class="hljs-keyword">if</span> (top &lt;= bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>                    matrix[bottom][i] = num++;<br>                &#125;<br>                bottom--;<br>            &#125;<br><br>            <span class="hljs-comment">// bottom to top</span><br>            <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                    matrix[i][left] = num++;<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> generateMatrix = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> rowBegin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> rowEnd = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> colBegin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> colEnd = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123;<br>        <span class="hljs-comment">// right</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = colBegin; i &lt;= colEnd; i++) &#123;<br>            res[rowBegin][i] = num++;<br>        &#125;<br>        rowBegin++;<br><br>        <span class="hljs-comment">// down</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = rowBegin; i &lt;= rowEnd; i++) &#123;<br>            res[i][colEnd] = num++;<br>        &#125;<br>        colEnd--;<br><br>        <span class="hljs-comment">// left</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = colEnd; i &gt;= colBegin; i--) &#123;<br>            res[rowEnd][i] = num++;<br>        &#125;<br>        rowEnd--;<br><br>        <span class="hljs-comment">// up</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = rowEnd; i &gt;= rowBegin; i--) &#123;<br>            res[i][colBegin] = num++;<br>        &#125;<br>        colBegin++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 54. Spiral Matrix</title>
    <link href="/posts/230483172.html"/>
    <url>/posts/230483172.html</url>
    
    <content type="html"><![CDATA[<p>Given an m x n matrix, return all elements of the matrix in spiral order.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="Example 1"><br>Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>Output: [1,2,3,6,9,8,7,4,5]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="Example 2"><br>Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>Output: [1,2,3,4,8,12,11,10,9,5,6,7]</p><p>Constraints:<br>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p><p>螺旋矩阵。</p><blockquote>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题没有什么比较巧妙的思路，只能照着遍历的方式去实现了代码，按照右 - 下 - 左 - 上的顺序去遍历。这个题做的时候需要用几个变量去记录二维数组坐标的边界，同时记得当每一行&#x2F;列遍历完了之后，边界值需要减1因为遍历的时候每一圈的 size 都在减小。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn)<br>空间O(n) - 输出是一个一维数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<br>            <span class="hljs-comment">// left to right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>                res.add(matrix[top][i]);<br>            &#125;<br>            top++;<br><br>            <span class="hljs-comment">// top to bottom</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>                res.add(matrix[i][right]);<br>            &#125;<br>            right--;<br><br>            <span class="hljs-comment">// right to left</span><br>            <span class="hljs-keyword">if</span> (top &lt;= bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>                    res.add(matrix[bottom][i]);<br>                &#125;<br>                bottom--;<br>            &#125;<br><br>            <span class="hljs-comment">// bottom to top</span><br>            <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                    res.add(matrix[i][left]);<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">matrix</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> spiralOrder = <span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">let</span> rowBegin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> rowEnd = matrix.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> colBegin = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> colEnd = matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (colBegin &lt;= colEnd &amp;&amp; rowBegin &lt;= rowEnd) &#123;<br>        <span class="hljs-comment">// right</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = colBegin; i &lt;= colEnd; i++) &#123;<br>            res.<span class="hljs-title function_">push</span>(matrix[rowBegin][i]);<br>        &#125;<br>        rowBegin++;<br><br>        <span class="hljs-comment">// down</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = rowBegin; i &lt;= rowEnd; i++) &#123;<br>            res.<span class="hljs-title function_">push</span>(matrix[i][colEnd]);<br>        &#125;<br>        colEnd--;<br><br>        <span class="hljs-comment">// left</span><br>        <span class="hljs-keyword">if</span> (rowBegin &lt;= rowEnd) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = colEnd; i &gt;= colBegin; i--) &#123;<br>                res.<span class="hljs-title function_">push</span>(matrix[rowEnd][i]);<br>            &#125;<br>        &#125;<br>        rowEnd--;<br><br>        <span class="hljs-comment">// up</span><br>        <span class="hljs-keyword">if</span> (colBegin &lt;= colEnd) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = rowEnd; i &gt;= rowBegin; i--) &#123;<br>                res.<span class="hljs-title function_">push</span>(matrix[i][colBegin]);<br>            &#125;<br>        &#125;<br>        colBegin++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
      <tag>simulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 48. Rotate Image</title>
    <link href="/posts/4004786799.html"/>
    <url>/posts/4004786799.html</url>
    
    <content type="html"><![CDATA[<p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).</p><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="Example 1"><br>Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>Output: [[7,4,1],[8,5,2],[9,6,3]]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="Example 2"><br>Input: matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p><p>Constraints:<br>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000</p><p>旋转图像。</p><blockquote>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然规定了要 in-place 做，只能想到对折之类的做法。但是如何对折呢？是先通过对角线对折（左上 - 右下），然后再左右对折。注意对角线对折部分 j 指针是从哪里开始的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-comment">// 按左上 - 右下对角线交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; m; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 左右对折</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[i][m - <span class="hljs-number">1</span> - j];<br>                matrix[i][m - <span class="hljs-number">1</span> - j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">matrix</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotate = <span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-keyword">let</span> m = matrix.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 左上- 右下对角线交换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">let</span> temp = matrix[i][j];<br>            matrix[i][j] = matrix[j][i];<br>            matrix[j][i] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 左右对折</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; m / <span class="hljs-number">2</span>; j++) &#123;<br>            <span class="hljs-keyword">let</span> temp = matrix[i][j];<br>            matrix[i][j] = matrix[i][m - <span class="hljs-number">1</span> - j];<br>            matrix[i][m - <span class="hljs-number">1</span> - j] = temp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">48. Rotate Image<br>1886. Determine Whether Matrix Can Be Obtained By Rotation<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 134. Gas Station</title>
    <link href="/posts/3013454655.html"/>
    <url>/posts/3013454655.html</url>
    
    <content type="html"><![CDATA[<p>There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].</p><p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays gas and cost, return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.</p><p>Example 1:<br>Input: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>Output: 3<br>Explanation:<br>Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4<br>Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8<br>Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7<br>Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6<br>Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5<br>Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.<br>Therefore, return 3 as the starting index.</p><p>Example 2:<br>Input: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]<br>Output: -1<br>Explanation:<br>You can’t start at station 0 or 1, as there is not enough gas to travel to the next station.<br>Let’s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4<br>Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3<br>Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3<br>You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.<br>Therefore, you can’t travel around the circuit once no matter where you start.</p><p>Constraints:<br>n &#x3D;&#x3D; gas.length &#x3D;&#x3D; cost.length<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; gas[i], cost[i] &lt;&#x3D; 104</p><p>加油站。</p><blockquote>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/gas-station">https://leetcode.cn/problems/gas-station</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个长度为 n 的环，用数组表示。环上的每一个点都有两个值，一个是当前加油站的油量，一个是开到下一个加油站的耗油量。请找到一个起点能够保证车开完一圈，返回起点的坐标；若找不到这个起点则返回-1。这是一个数学题。这个题涉及一个定理（此处不证明了），<mark>如果一个数组的总和非负，那么一定可以找到一个起始位置，从它开始绕数组一圈，累加和一直都是非负的</mark>。有了这个定理之后，可以对input做如下判断。</p><ol><li>从位置 i 开始直到绕完一圈，如果油箱没空，说明从 i 开始所有的累积都是正的（总的加油量大于耗油量）</li><li>如果在位置 j 的时候油箱空了，说明从位置 i 开始是走不完全程的，此时可以从 j + 1 的位置重新开始计算。为什么不考虑从 i + 1 的位置开始重新计算是因为 i 处的油量是正的情况下已经走不完全程了，因为从 i 去到 i + 1也有油耗，如果从 i + 1 开始，更走不完全程了</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] gas, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-comment">// total记录环内总油量是否足够</span><br>        <span class="hljs-comment">// sum记录当前油箱剩余油量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gas.length; i++) &#123;<br>            total += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                sum = gas[i] - cost[i];<br>                start = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += gas[i] - cost[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> total &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">gas</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">cost</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canCompleteCircuit = <span class="hljs-keyword">function</span> (<span class="hljs-params">gas, cost</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (gas.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || cost.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-property">length</span>; i++) &#123;<br>        total += (gas[i] - cost[i]);<br>        <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>            sum = gas[i] - cost[i];<br>            start = i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sum += gas[i] - cost[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> total &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : start;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>greedy</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 70. Climbing Stairs</title>
    <link href="/posts/2952065353.html"/>
    <url>/posts/2952065353.html</url>
    
    <content type="html"><![CDATA[<p>You are climbing a staircase. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><p>Example 1:<br>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p><ol><li>1 step + 1 step</li><li>2 steps</li></ol><p>Example 2:<br>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p><ol><li>1 step + 1 step + 1 step</li><li>1 step + 2 steps</li><li>2 steps + 1 step</li></ol><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 45</p><p>爬楼梯。</p><blockquote>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</blockquote><p>这道题有两种解法，一种是数学解法，一种是动态规划。</p><h2 id="思路一-数学解法"><a href="#思路一-数学解法" class="headerlink" title="思路一 - 数学解法"></a>思路一 - 数学解法</h2><p>首先是数学解法，这个题本质上是斐波那契数列。当输入为1, 2, 3, 4, 5, 6, 7, 8, 9, 10时，观察输出为1, 2, 3, 5, 8, 13, 21, 34, 55, 89。所以做法就很直观了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            cur = zero + first;<br>            zero = first;<br>            first = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-动态规划"><a href="#思路二-动态规划" class="headerlink" title="思路二 - 动态规划"></a>思路二 - 动态规划</h2><p>dp[i] 数组的定义是跑到第 i 层楼的时候，上楼梯的组合数是多少。几个初始值是 dp[0] &#x3D; 0, dp[1] &#x3D; 1, dp[2] &#x3D; 2。因为每次既可以爬一层楼，也可以爬两层楼，所以当你需要知道第i层楼的爬法的时候，你需要看的是我爬到 i - 2 层楼有几种爬法和我爬到 i - 1 层楼有几种爬法。所以状态转移方程就是 dp[i] &#x3D; dp[i - 1] + dp[i - 2]。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>javascript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> dp = [n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">70. Climbing Stairs<br>509. Fibonacci Number<br>746. Min Cost Climbing Stairs<br>1137. N-th Tribonacci Number<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>dynamic programming</tag>
      
      <tag>math</tag>
      
      <tag>memorization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 107. Binary Tree Level Order Traversal II</title>
    <link href="/posts/2469883664.html"/>
    <url>/posts/2469883664.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="Example 1"><br>Input: root &#x3D; [3,9,20,null,null,15,7]<br>Output: [[15,7],[9,20],[3]]</p><p>Example 2:<br>Input: root &#x3D; [1]<br>Output: [[1]]</p><p>Example 3:<br>Input: root &#x3D; []<br>Output: []</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 2000].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>二叉树的层序遍历 II。</p><blockquote><p>给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题跟102题唯一的区别是每一层的节点整理好以后，是加到结果集的头部而不是尾部。这里我只提供 BFS 实现。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n^2)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br>Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.offer(root);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>list.add(cur.val);<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.right);<br>&#125;<br>&#125;<br>res.add(<span class="hljs-number">0</span>, list);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">102. Binary Tree Level Order Traversal<br>107. Binary Tree Level Order Traversal II<br>429. N-ary Tree Level Order Traversal<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 98. Validate Binary Search Tree</title>
    <link href="/posts/1121020247.html"/>
    <url>/posts/1121020247.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p><p>A valid BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="Example 1"><br>Input: root &#x3D; [2,1,3]<br>Output: true</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="Example 2"><br>Input: root &#x3D; [5,1,4,null,null,3,6]<br>Output: false<br>Explanation: The root node’s value is 5 but its right child’s value is 4.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 104].<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><p>验证二叉搜索树。</p><blockquote>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<p>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/validate-binary-search-tree">https://leetcode.cn/problems/validate-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树的特性是对于每个node而言，他的左子树上任意节点都比他自身小，右子树上任意节点都比他自身大。这个题也是有两种做法，迭代和递归。时间空间复杂度都是O(n)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代的做法其实就是树的中序遍历，需要用到 stack。按照中序遍历的顺序遍历所有的 node，记录一个 pre node 和一个 currrent node。如果树是一个合法的BST，中序遍历的结果应该是有序的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt;= cur.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            pre = cur;<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isValidBST = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> cur = root;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span> || stack.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;<br>            stack.<span class="hljs-title function_">push</span>(cur);<br>            cur = cur.<span class="hljs-property">left</span>;<br>        &#125;<br>        cur = stack.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">if</span> (pre !== <span class="hljs-literal">null</span> &amp;&amp; cur.<span class="hljs-property">val</span> &lt;= pre.<span class="hljs-property">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = cur;<br>        cur = cur.<span class="hljs-property">right</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的代码就非常简单了，任何节点如果存在左孩子，左孩子的 val 不能大于其父节点；如果存在右孩子， 右孩子的 val 不能小于其父节点。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> helper(root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, Integer min, Integer max)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (min != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= min) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (max != <span class="hljs-literal">null</span> &amp;&amp; root.val &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isValidBST = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">helper</span>(root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, min, max</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (min !== <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">val</span> &lt;= min) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (max !== <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">val</span> &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">left</span>, min, root.<span class="hljs-property">val</span>) &amp;&amp; <span class="hljs-title function_">helper</span>(root.<span class="hljs-property">right</span>, root.<span class="hljs-property">val</span>, max);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>inorder</tag>
      
      <tag>bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>938. Range Sum of BST</title>
    <link href="/posts/1065583272.html"/>
    <url>/posts/1065583272.html</url>
    
    <content type="html"><![CDATA[<p>Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="Example 1"><br>Input: root &#x3D; [10,5,15,3,7,null,18], low &#x3D; 7, high &#x3D; 15<br>Output: 32<br>Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 &#x3D; 32.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt="Example 2"><br>Input: root &#x3D; [10,5,15,3,7,13,18,1,null,6], low &#x3D; 6, high &#x3D; 10<br>Output: 23<br>Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 &#x3D; 23.</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 2 * 104].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>1 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 105<br>All Node.val are unique.</p><p>二叉搜索树的范围和。</p><blockquote><p>给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题用迭代或者用递归做都可以，我直接给出代码。两种做法时间空间复杂度一样，均为O(n)。其中因为是一棵二叉搜索树的关系，我们可以利用BST的性质进行合理剪枝。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>迭代&#x2F;BFS代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rangeSumBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.offer(root);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-keyword">if</span> (cur.val &gt;= low &amp;&amp; cur.val &lt;= high) &#123;<br>sum += cur.val;<br>&#125;<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.right);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rangeSumBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &gt; high) &#123;<br>            <span class="hljs-keyword">return</span> rangeSumBST(root.left, low, high);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &lt; low) &#123;<br>            <span class="hljs-keyword">return</span> rangeSumBST(root.right, low, high);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 169. Majority Element</title>
    <link href="/posts/1131179443.html"/>
    <url>/posts/1131179443.html</url>
    
    <content type="html"><![CDATA[<p>Given an array nums of size n, return the majority element.</p><p>The majority element is the element that appears more than ⌊n &#x2F; 2⌋ times. You may assume that the majority element always exists in the array.</p><p>Example 1:<br>Input: nums &#x3D; [3,2,3]<br>Output: 3</p><p>Example 2:<br>Input: nums &#x3D; [2,2,1,1,1,2,2]<br>Output: 2</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5 * 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>Follow-up: Could you solve the problem in linear time and in O(1) space?</p><p>多数元素。</p><blockquote><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/majority-element">https://leetcode-cn.com/problems/majority-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>题意是给一个数组，有一个数字出现次数超过了数组长度的一半，请求出这个数字。<br>我给出几个不同解法，其中最优解投票法。</p><h2 id="思路一-排序"><a href="#思路一-排序" class="headerlink" title="思路一 - 排序"></a>思路一 - 排序</h2><p>排序，然后直接找数组中间那个数字。<br>时间O(nlogn)<br>空间O(1)</p><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    nums.<span class="hljs-title function_">sort</span>();<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-hashmap计算每个不同元素出现的次数，返回次数超过数组长度一半的那个数字"><a href="#思路二-hashmap计算每个不同元素出现的次数，返回次数超过数组长度一半的那个数字" class="headerlink" title="思路二 - hashmap计算每个不同元素出现的次数，返回次数超过数组长度一半的那个数字"></a>思路二 - hashmap计算每个不同元素出现的次数，返回次数超过数组长度一半的那个数字</h2><p>时间O(n)<br>空间O(n)</p><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> dict = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> breakpoint = nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        dict[nums[i]] = dict[nums[i]] || <span class="hljs-number">0</span>;<br>        dict[nums[i]]++;<br>        <span class="hljs-keyword">if</span> (dict[nums[i]] &gt; breakpoint) &#123;<br>            <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> nums.length / <span class="hljs-number">2</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!map.containsKey(nums[i])) &#123;<br>                map.put(nums[i], <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(nums[i], map.get(nums[i]) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.get(nums[i]) &gt; half) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路三-投票法"><a href="#思路三-投票法" class="headerlink" title="思路三 - 投票法"></a>思路三 - 投票法</h2><p>意思是先假设数组的第一个元素是要找的元素，设为 candidate，再记录一个变量 count。遍历数组，如果遍历到跟 candidate 不同的数字的时候，count–，当 count &#x3D;&#x3D; 0 的时候，同时需要换一个 candidate；如果跟 X 一样，就 count++。最后剩下的那个 candidate 就是要找的元素，因为他的出现次数超过了数组的一半所以一定不会被替换掉。</p><p>时间O(n)<br>空间O(1)</p><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num != candidate) &#123;<br>                count--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> candidate = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (num === candidate) &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>            candidate = num;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> candidate;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">169. Majority Element<br>229. Majority Element II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 49. Group Anagrams</title>
    <link href="/posts/2499032381.html"/>
    <url>/posts/2499032381.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Example 1:<br>Input: strs &#x3D; [“eat”,”tea”,”tan”,”ate”,”nat”,”bat”]<br>Output: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p><p>Example 2:<br>Input: strs &#x3D; [“”]<br>Output: [[“”]]</p><p>Example 3:<br>Input: strs &#x3D; [“a”]<br>Output: [[“a”]]</p><p>Constraints:<br>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] consists of lowercase English letters.</p><p>字母异位词分组。</p><blockquote><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/group-anagrams">https://leetcode.cn/problems/group-anagrams</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="暴力解思路"><a href="#暴力解思路" class="headerlink" title="暴力解思路"></a>暴力解思路</h2><p>给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。字母异位词指字母相同，但排列不同的字符串。</p><p>做这个题之前，需要做如下几个题，对anagram的概念有所了解。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">242. Valid Anagram<br>383. Ransom Note<br>387. First Unique Character in a String<br></code></pre></td></tr></table></figure><p>此题比较粗暴的解法是把 input 里面所有的单词都按照字母排序，形成一个新的单词。比如”eat”排序后会成为”aet”，然后以”aet”为key，”eat”为 value 加入 hashmap。遍历完 input 之后，输出 hashmap 所有的 value 即可。</p><p>时间O(nlogn) - sort<br>空间O(n) - hashmap</p><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">char</span>[] letters = str.toCharArray();<br>            Arrays.sort(letters);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(letters);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>                map.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            &#125;<br>            map.get(key).add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">strs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> strs) &#123;<br>        <span class="hljs-keyword">const</span> key = [...str].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (!map[key]) &#123;<br>            map[key] = [];<br>        &#125;<br>        map[key].<span class="hljs-title function_">push</span>(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(map);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最优解思路"><a href="#最优解思路" class="headerlink" title="最优解思路"></a>最优解思路</h2><p>但是如上不是最优解，最优解还是要通过counting sort的思路来做。对于每个单词，需要创建一个长度为26的数组（题目说了只有小写）来存这个单词里面每个字母都分别出现过几次。这样每个单词最后形成的数组会长类似这样</p><blockquote><p>[ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ]<br>[ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ]<br>[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ]</p></blockquote><p>然后把这个数组稍微变化一下，做成一个类似这样的string</p><blockquote><p>10001000000000000001000000</p></blockquote><p>把这样的 string 当做 hashmap 的 key。这样每个扫描过的单词都会变成这样，是异位词的单词们的 string 会长得一样，所以在 hashmap 中会被存到同一个 key 里面。最后以数组形式输出 hashmap 里面所有的 value 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(mn) - n 个单词，单词平均长度是 m<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> helper(str);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(letters)) &#123;<br>                map.put(letters, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            &#125;<br>            map.get(letters).add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">helper</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            map[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> String.valueOf(map);<br>        <span class="hljs-comment">// System.out.print(res);</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string[]</span>&#125; <span class="hljs-variable">strs</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> s <span class="hljs-keyword">of</span> strs) &#123;<br>        <span class="hljs-keyword">const</span> letters = <span class="hljs-title class_">Array</span>(<span class="hljs-number">26</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> c <span class="hljs-keyword">of</span> s) &#123;<br>            letters[c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>) - <span class="hljs-number">97</span>]++;<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(letters);<br>        <span class="hljs-keyword">const</span> key = letters.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;#&quot;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>        <span class="hljs-keyword">let</span> val = [];<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(key)) &#123;<br>            val = map.<span class="hljs-title function_">get</span>(key);<br>        &#125;<br>        val.<span class="hljs-title function_">push</span>(s);<br>        map.<span class="hljs-title function_">set</span>(key, val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map.<span class="hljs-title function_">values</span>());<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>counting sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 451. Sort Characters By Frequency</title>
    <link href="/posts/1410576140.html"/>
    <url>/posts/1410576140.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string.</p><p>Example 1:<br>Input: s &#x3D; “tree”<br>Output: “eert”<br>Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once.<br>So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.</p><p>Example 2:<br>Input: s &#x3D; “cccaaa”<br>Output: “aaaccc”<br>Explanation: Both ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer.<br>Note that “cacaca” is incorrect, as the same characters must be together.</p><p>Example 3:<br>Input: s &#x3D; “Aabb”<br>Output: “bbAa”<br>Explanation: “bbaA” is also a valid answer, but “Aabb” is incorrect.<br>Note that ‘A’ and ‘a’ are treated as two different characters.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 5 * 105<br>s consists of English letters and digits.</p><p>根据字符出现频率排序。</p><blockquote><p>给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。<br>返回 已排序的字符串 。如果有多个答案，返回其中任何一个。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sort-characters-by-frequency">https://leetcode.cn/problems/sort-characters-by-frequency</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给定一个字符串，请将字符串里的字符按照出现的频率降序排列。注意此题的第三个例子，要求区分大小写。最优解是用到类似桶排序 bucket sort 的思路，也可以用 priority queue 做但是复杂度高。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的思路用一个 hashmap 记录input里面所有出现过的字符和他们的频率，然后对hashmap（key, value）按照value大小对key重新排序。最后再按照各个字母出现的次数，拼接好最后的字符串。</p><h2 id="桶排序复杂度"><a href="#桶排序复杂度" class="headerlink" title="桶排序复杂度"></a>桶排序复杂度</h2><p>时间O(n) - no need to sort anything<br>空间O(n)</p><h2 id="桶排序代码"><a href="#桶排序代码" class="headerlink" title="桶排序代码"></a>桶排序代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">frequencySort</span><span class="hljs-params">(String s)</span> &#123;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        List&lt;Character&gt;[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[s.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> key : map.keySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> map.get(key);<br>            <span class="hljs-keyword">if</span> (bucket[freq] == <span class="hljs-literal">null</span>) &#123;<br>                bucket[freq] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            &#125;<br>            bucket[freq].add(key);<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bucket.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : bucket[i]) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; map.get(c); j++) &#123;<br>                        sb.append(c);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>一开始还是用 hashmap 统计每个不同字母的出现次数，并把整个 map.entry 放入一个以 priority queue 构建的最大堆。堆顶元素是出现次数最多的字母。将每个字母写回 StringBuilder 的时候，我们还是按照出现次数从多到少往回写。</p><h2 id="优先队列复杂度"><a href="#优先队列复杂度" class="headerlink" title="优先队列复杂度"></a>优先队列复杂度</h2><p>时间O(nlogk)<br>空间O(n) - priority queue</p><h2 id="优先队列代码"><a href="#优先队列代码" class="headerlink" title="优先队列代码"></a>优先队列代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">frequencySort</span><span class="hljs-params">(String s)</span> &#123;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b.getValue() - a.getValue());<br>        queue.addAll(map.entrySet());<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>) e.getValue(); i++) &#123;<br>                sb.append(e.getKey());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
      <tag>sort</tag>
      
      <tag>bucket sort</tag>
      
      <tag>string</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 138. Copy List with Random Pointer</title>
    <link href="/posts/2629173317.html"/>
    <url>/posts/2629173317.html</url>
    
    <content type="html"><![CDATA[<p>A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.</p><p>Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.</p><p>For example, if there are two nodes X and Y in the original list, where X.random –&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random –&gt; y.</p><p>Return the head of the copied linked list.</p><p>The linked list is represented in the input&#x2F;output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p><p>val: an integer representing Node.val<br>random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.<br>Your code will only be given the head of the original linked list.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="Example 1"><br>Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt="Example 2"><br>Input: head &#x3D; [[1,1],[2,1]]<br>Output: [[1,1],[2,1]]</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt="Example 3"><br>Input: head &#x3D; [[3,null],[3,0],[3,null]]<br>Output: [[3,null],[3,0],[3,null]]</p><p>Constraints:<br>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>Node.random is null or is pointing to some node in the linked list.</p><p>复制带随机指针的链表。</p><blockquote>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer">https://leetcode.cn/problems/copy-list-with-random-pointer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="什么叫做深度复制"><a href="#什么叫做深度复制" class="headerlink" title="什么叫做深度复制"></a>什么叫做深度复制</h2><p>明确一下什么叫做深度复制。<br>这样叫做 shallow copy 浅复制，a 和 b 在内存中是 share 一个地址。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ListNode a <span class="hljs-operator">=</span> new ListNode(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>ListNode b <span class="hljs-operator">=</span> a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这样叫做深度复制，a 和 b 在内存中各自有各自的地址。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ListNode a <span class="hljs-operator">=</span> new ListNode(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>ListNode b <span class="hljs-operator">=</span> new ListNode(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="思路一-hashmap"><a href="#思路一-hashmap" class="headerlink" title="思路一 - hashmap"></a>思路一 - hashmap</h2><p>用 hashmap，key 是每个 node，value 是存每个 node 的 copy。复制完毕之后再遍历一遍，做每个 node 的指针复制。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            map.put(cur, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val));<br>            cur = cur.next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            map.get(cur).next = map.get(cur.next);<br>            map.get(cur).random = map.get(cur.random);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Node</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> copyRandomList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> cur = head;<br>    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;<br>        map.<span class="hljs-title function_">set</span>(cur, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.<span class="hljs-property">val</span>, cur.<span class="hljs-property">next</span>, cur.<span class="hljs-property">random</span>));<br>        cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    cur = head;<br>    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;<br>        map.<span class="hljs-title function_">get</span>(cur).<span class="hljs-property">next</span> = map.<span class="hljs-title function_">get</span>(cur.<span class="hljs-property">next</span>) || <span class="hljs-literal">null</span>;<br>        map.<span class="hljs-title function_">get</span>(cur).<span class="hljs-property">random</span> = map.<span class="hljs-title function_">get</span>(cur.<span class="hljs-property">random</span>) || <span class="hljs-literal">null</span>;<br>        cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(head);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>另外一种思路是首先复制整个链表，将每一个复制的节点 copy 加到原节点后面。然后将每个 copy node 的 random node 也链接好，再断开原链表和复制的链表。这种做法无需额外空间。</p><p>注意因为 random node 其实也是来自于这个链表，跟 next 指针的区别在于 next 指针是指向每个 node 的下一个 node，random 指针是随机指向了整个链表中的某个 node，所以当第一遍复制好了 copy node 之后，也需要把 cur.next.random 指向 cur.random.next，因为</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">cur.<span class="hljs-keyword">next</span>.<span class="hljs-built_in">random</span> = copy.<span class="hljs-built_in">random</span><br>cur.<span class="hljs-built_in">random</span>.<span class="hljs-keyword">next</span> = 某一个copy node<br></code></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// copy all the cur nodes</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val);<br>            cur.next = copy;<br>            copy.next = next;<br>            cur = next;<br>        &#125;<br><br>        <span class="hljs-comment">// copy all the random nodes</span><br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.random != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// cur.random.next是某个random节点的copy</span><br>                <span class="hljs-comment">// cur.next.random是当前节点的copy的random指针</span><br>                cur.next.random = cur.random.next;<br>            &#125;<br>            cur = cur.next.next;<br>        &#125;<br><br>        <span class="hljs-comment">// separate two lists</span><br>        cur = head;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">copyHead</span> <span class="hljs-operator">=</span> dummy;<br>        Node copy;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next.next;<br>            copy = cur.next;<br>            copyHead.next = copy;<br>            copyHead = copy;<br>            cur.next = next;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">Node</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> copyRandomList = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// make copy of each node</span><br>    <span class="hljs-keyword">let</span> cur = head;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-keyword">let</span> next = cur.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">let</span> copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.<span class="hljs-property">val</span>);<br>        cur.<span class="hljs-property">next</span> = copy;<br>        copy.<span class="hljs-property">next</span> = next;<br>        cur = next;<br>    &#125;<br><br>    <span class="hljs-comment">// set random property</span><br>    cur = head;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">random</span> !== <span class="hljs-literal">null</span>) &#123;<br>            cur.<span class="hljs-property">next</span>.<span class="hljs-property">random</span> = cur.<span class="hljs-property">random</span>.<span class="hljs-property">next</span>;<br>        &#125;<br>        cur = cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// detach copied list</span><br>    cur = head;<br>    <span class="hljs-keyword">let</span> dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> newHead = dummyHead;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-keyword">let</span> next = cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-comment">// extract the copy</span><br>        <span class="hljs-keyword">let</span> copy = cur.<span class="hljs-property">next</span>;<br>        newHead.<span class="hljs-property">next</span> = copy;<br>        newHead = copy;<br>        <span class="hljs-comment">// restore the original list</span><br>        cur.<span class="hljs-property">next</span> = next;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后附上discussion里面一个非常好的<a href="https://www.cnblogs.com/cnoodle/p/leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)/42652">图解</a>。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">133. Clone Graph<br>138. Copy List with Random Pointer<br>1485. Clone Binary Tree With Random Pointer<br>1490. Clone N-ary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 9. Palindrome Number</title>
    <link href="/posts/3054235392.html"/>
    <url>/posts/3054235392.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer x, return true if x is a palindrome, and false otherwise.</p><p>Example 1:<br>Input: x &#x3D; 121<br>Output: true<br>Explanation: 121 reads as 121 from left to right and from right to left.</p><p>Example 2:<br>Input: x &#x3D; -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p><p>Example 3:<br>Input: x &#x3D; 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p><p>Constraints:<br>-231 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p><p>Follow up: Could you solve it without converting the integer to a string?</p><p>回文数。</p><blockquote><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>例如，121 是回文，而 123 不是。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/palindrome-number">https://leetcode.cn/problems/palindrome-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是判断一个数字是否是回文数。这个题跟第七题非常类似，有两种做法，一种跟第七题很类似，另一种是把 input 数字转换成字符串然后双指针逼近检测是否有不一样的字符。</p><p>无论什么做法，都有一些需要去掉的 corner case，首先负数一定不是回文数，能被 10 整除的数字也不是，其次回文数一定不会越界。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - input 数字的长度<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            res = res * <span class="hljs-number">10</span> + n % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (res &gt; Integer.MAX_VALUE) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x !== <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">10</span> === <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> palindrome = x;<br><span class="hljs-keyword">let</span> reverse = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>reverse = reverse * <span class="hljs-number">10</span> + (x % <span class="hljs-number">10</span>);<br>x = ~~(x / <span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-keyword">return</span> palindrome === reverse;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">7. Reverse Integer<br>9. Palindrome Number<br>2108. Find First Palindromic String in the Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>math</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 589. N-ary Tree Preorder Traversal</title>
    <link href="/posts/999659702.html"/>
    <url>/posts/999659702.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of an n-ary tree, return the preorder traversal of its nodes’ values.</p><p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="Example 1"><br>Input: root &#x3D; [1,null,3,2,4,null,5,6]<br>Output: [1,3,5,6,2,4]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="Example 2"><br>Input: root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 104].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>The height of the n-ary tree is less than or equal to 1000.</p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><p>N叉树的前序遍历。</p><blockquote><p>给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的 followup 问能不能用迭代的做法做。我这里给出迭代和递归的两种不同做法。其中迭代是 DFS 做的。</p><h2 id="迭代复杂度"><a href="#迭代复杂度" class="headerlink" title="迭代复杂度"></a>迭代复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cur.children.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                stack.push(cur.children.get(i));<br>            &#125;<br>            res.add(cur.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorder = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> stack = [root];<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> cur = stack.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">let</span> size = cur.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            stack.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">children</span>[i]);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归复杂度"><a href="#递归复杂度" class="headerlink" title="递归复杂度"></a>递归复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        helper(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(Node root, List&lt;Integer&gt; res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.add(root.val);<br>        <span class="hljs-keyword">for</span> (Node child : root.children) &#123;<br>            helper(child, res);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Node</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> preorder = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-title function_">helper</span>(res, root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span> (<span class="hljs-params">res, root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> child <span class="hljs-keyword">of</span> root.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-title function_">helper</span>(res, child);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
      <tag>n-ary tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 506. Relative Ranks</title>
    <link href="/posts/3961220199.html"/>
    <url>/posts/3961220199.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.</p><p>The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:<br>The 1st place athlete’s rank is “Gold Medal”.<br>The 2nd place athlete’s rank is “Silver Medal”.<br>The 3rd place athlete’s rank is “Bronze Medal”.<br>For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete’s rank is “x”).<br>Return an array answer of size n where answer[i] is the rank of the ith athlete.</p><p>Example 1:<br>Input: score &#x3D; [5,4,3,2,1]<br>Output: [“Gold Medal”,”Silver Medal”,”Bronze Medal”,”4”,”5”]<br>Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].</p><p>Example 2:<br>Input: score &#x3D; [10,3,8,9,4]<br>Output: [“Gold Medal”,”5”,”Bronze Medal”,”Silver Medal”,”4”]<br>Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].</p><p>Constraints:<br>n &#x3D;&#x3D; score.length<br>1 &lt;&#x3D; n &lt;&#x3D; 104<br>0 &lt;&#x3D; score[i] &lt;&#x3D; 106<br>All the values in score are unique.</p><p>相对名次。</p><blockquote>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。<p>运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p><p>名次第 1 的运动员获金牌 “Gold Medal” 。<br>名次第 2 的运动员获银牌 “Silver Medal” 。<br>名次第 3 的运动员获铜牌 “Bronze Medal” 。<br>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。<br>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/relative-ranks">https://leetcode-cn.com/problems/relative-ranks</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-bucket-sort"><a href="#思路一-bucket-sort" class="headerlink" title="思路一 - bucket sort"></a>思路一 - bucket sort</h2><p>首先找到 input 中最大的元素，这个最大的元素是最大的 score 分数，这样才能知道桶排序里面到底需要多少个桶。创建了桶之后，可以从右往左扫描桶，也就是从高分往低分扫，如果找到某个 index，他在原数组的相同 index 里面是有数字的，则给他 assign medal 或者数字。注意前三个人分配到奖牌之后，从第四高的分数开始，我们是分配一个相对的名次。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] findRelativeRanks(<span class="hljs-type">int</span>[] score) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s : score) &#123;<br>            max = Math.max(max, s);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> score.length;<br>        String[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n];<br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            bucket[score[i]] = i + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bucket.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (bucket[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">1</span>) &#123;<br>                    res[bucket[i] - <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Gold Medal&quot;</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">2</span>) &#123;<br>                    res[bucket[i] - <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Silver Medal&quot;</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">3</span>) &#123;<br>                    res[bucket[i] - <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Bronze Medal&quot;</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res[bucket[i] - <span class="hljs-number">1</span>] = String.valueOf(rank);<br>                &#125;<br>                rank++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-堆"><a href="#思路二-堆" class="headerlink" title="思路二 - 堆"></a>思路二 - 堆</h2><p>创建一个最大堆，把 input 数组里的每个 index 和 score 做成 [index, score] 放入最大堆，堆里的元素是按照 score 降序排列的。然后从堆中开始取出元素，取出的前三个元素就是得金银铜牌的运动员。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String[] findRelativeRanks(<span class="hljs-type">int</span>[] score) &#123;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> score.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; i, score[i] &#125;);<br>        &#125;<br><br>        String[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] cur = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> cur[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">1</span>) &#123;<br>                res[index] = <span class="hljs-string">&quot;Gold Medal&quot;</span>;<br>                rank++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">2</span>) &#123;<br>                res[index] = <span class="hljs-string">&quot;Silver Medal&quot;</span>;<br>                rank++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank == <span class="hljs-number">3</span>) &#123;<br>                res[index] = <span class="hljs-string">&quot;Bronze Medal&quot;</span>;<br>                rank++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[index] = String.valueOf(rank);<br>                rank++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>bucket sort</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 513. Find Bottom Left Tree Value</title>
    <link href="/posts/1856795069.html"/>
    <url>/posts/1856795069.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the leftmost value in the last row of the tree.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="Example 1"><br>Input: root &#x3D; [2,1,3]<br>Output: 1</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="Example 2"><br>Input: root &#x3D; [1,2,3,4,null,5,6,null,null,7]<br>Output: 7</p><p>Constraints:<br>The number of nodes in the tree is in the range [1, 104].<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><p>找树左下角的值。</p><blockquote><p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。<br>假设二叉树中至少有一个节点。</p></blockquote><h2 id="思路-BFS"><a href="#思路-BFS" class="headerlink" title="思路 - BFS"></a>思路 - BFS</h2><p>首先 BFS 比较直观，只要按层序遍历的做法一层层把 node 塞进 queue。当遍历到最底层的时候，输出第一个塞进去的节点值即可。注意每层节点在塞入 queue 的时候应该是先塞右孩子再塞左孩子，原因是BFS的解法不看当前遍历到了第几层，只能通过这种方式才能保证最底层最靠左的叶子节点是最后被塞入 queue 的。如果按照第一个例子跑一遍，结果就是2 - 3 - 1而不是2 - 1 - 3.</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>            res = cur.val;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findBottomLeftValue = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> queue = [root];<br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>        res = cur.<span class="hljs-property">val</span>;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span>) &#123;<br>            queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span>) &#123;<br>            queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 - DFS"></a>思路 - DFS</h2><p>用DFS做的思路就稍微复杂一些。DFS 的做法会用到先序遍历，同时我们需要两个变量，height 记录当前遍历到的节点的深度，depth 记录当前遍历到的最大深度。当我们遍历到某个节点的时候，如果当前这个节点的深度 height 小于 depth，则说明当前这个节点一定不在最深层；否则这个节点是在最深层。同时因为我们是先遍历左子树的关系，所以当我们往某个左子树上走的时候，会记录第一个 height 被更新的左子树，这样深度最大的左孩子就会被记录下来了。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node. public class TreeNode &#123; int val; TreeNode</span><br><span class="hljs-comment"> * left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        helper(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (height &lt; depth) &#123;<br>            res = root.val;<br>            height = dpeth;<br>        &#125;<br>        helper(root.left, depth + <span class="hljs-number">1</span>);<br>        helper(root.right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 113. Path Sum II</title>
    <link href="/posts/29721560.html"/>
    <url>/posts/29721560.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.</p><p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="Example 1"><br>Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>Output: [[5,4,11,2],[5,8,4,5]]<br>Explanation: There are two paths whose sum equals targetSum:<br>5 + 4 + 11 + 2 &#x3D; 22<br>5 + 8 + 4 + 5 &#x3D; 22</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="Example 2"><br>Input: root &#x3D; [1,2,3], targetSum &#x3D; 5<br>Output: []</p><p>Example 3:<br>Input: root &#x3D; [1,2], targetSum &#x3D; 0<br>Output: []</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 5000].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><p>路径总和 II。</p><blockquote><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/path-sum-ii">https://leetcode.cn/problems/path-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路-DFS"><a href="#思路-DFS" class="headerlink" title="思路 - DFS"></a>思路 - DFS</h2><p>这题我只会用 DFS 做。这个题也有那么点 backtracking 的味道在里面，因为要求你输出所有的情况，需要回溯。同类型题还有 1457。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        helper(res, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), root, sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root.val);<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sum == root.val) &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>            &#125;<br>        &#125;<br>        helper(res, list, root.left, sum - root.val);<br>        helper(res, list, root.right, sum - root.val);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">sum</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> pathSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, sum</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-title function_">helper</span>(res, [], root, sum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span>(<span class="hljs-params">res, list, root, sum</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root) &#123;<br>        list.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-keyword">if</span> (!root.<span class="hljs-property">left</span> &amp;&amp; !root.<span class="hljs-property">right</span> &amp;&amp; sum - root.<span class="hljs-property">val</span> === <span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-title function_">push</span>([...list]);<br>        &#125;<br>        <span class="hljs-title function_">helper</span>(res, list, root.<span class="hljs-property">left</span>, sum - root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">helper</span>(res, list, root.<span class="hljs-property">right</span>, sum - root.<span class="hljs-property">val</span>);<br>        list.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">112. Path Sum<br>113. Path Sum II<br>437. Path Sum III<br>1457. Pseudo-Palindromic Paths in a Binary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>preorder</tag>
      
      <tag>recursion</tag>
      
      <tag>backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 112. Path Sum</title>
    <link href="/posts/139367820.html"/>
    <url>/posts/139367820.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p><p>A leaf is a node with no children.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="Example 1"><br>Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>Output: true<br>Explanation: The root-to-leaf path with the target sum is shown.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="Example 2"><br>Input: root &#x3D; [1,2,3], targetSum &#x3D; 5<br>Output: false<br>Explanation: There are two root-to-leaf paths in the tree:<br>(1 –&gt; 2): The sum is 3.<br>(1 –&gt; 3): The sum is 4.<br>There is no root-to-leaf path with sum &#x3D; 5.</p><p>Example 3:<br>Input: root &#x3D; [], targetSum &#x3D; 0<br>Output: false<br>Explanation: Since the tree is empty, there are no root-to-leaf paths.</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 5000].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><p>路径总和。</p><blockquote><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p><p>叶子节点 是指没有子节点的节点。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum">https://leetcode-cn.com/problems/path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-DFS-recursive"><a href="#思路一-DFS-recursive" class="headerlink" title="思路一 - DFS&#x2F;recursive"></a>思路一 - DFS&#x2F;recursive</h2><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum == root.val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">sum</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, sum</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> sum === root.<span class="hljs-property">val</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="hljs-title function_">hasPathSum</span>(root.<span class="hljs-property">left</span>, sum - root.<span class="hljs-property">val</span>) ||<br>        <span class="hljs-title function_">hasPathSum</span>(root.<span class="hljs-property">right</span>, sum - root.<span class="hljs-property">val</span>)<br>    );<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-BFS-iterative"><a href="#思路二-BFS-iterative" class="headerlink" title="思路二 - BFS&#x2F;iterative"></a>思路二 - BFS&#x2F;iterative</h2><p>用一个 stack 存储遍历到的节点。当加入某个节点的时候，如果这个节点没有孩子节点，需要判断加入这个节点之后的值是否等于 sum；如果这个节点有孩子节点，接着遍历它的孩子节点，将cur.val + cur.left.val （cur.val + cur.right.val）加入 stack。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - n is the number of nodes</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cur.val == sum) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur.right);<br>                cur.right.val += cur.val;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur.left);<br>                cur.left.val += cur.val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">sum</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasPathSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, sum</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> stack = [root];<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> cur = stack.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">if</span> (!cur.<span class="hljs-property">left</span> &amp;&amp; !cur.<span class="hljs-property">right</span> &amp;&amp; cur.<span class="hljs-property">val</span> === sum) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span>) &#123;<br>            cur.<span class="hljs-property">right</span>.<span class="hljs-property">val</span> += cur.<span class="hljs-property">val</span>;<br>            stack.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span>) &#123;<br>            cur.<span class="hljs-property">left</span>.<span class="hljs-property">val</span> += cur.<span class="hljs-property">val</span>;<br>            stack.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">112. Path Sum<br>113. Path Sum II<br>437. Path Sum III<br>1457. Pseudo-Palindromic Paths in a Binary Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 102. Binary Tree Level Order Traversal</title>
    <link href="/posts/3757411780.html"/>
    <url>/posts/3757411780.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="Example 1"><br>Input: root &#x3D; [3,9,20,null,null,15,7]<br>Output: [[3],[9,20],[15,7]]</p><p>Example 2:<br>Input: root &#x3D; [1]<br>Output: [[1]]</p><p>Example 3:<br>Input: root &#x3D; []<br>Output: []</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 2000].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>二叉树的层序遍历。</p><blockquote><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题比较简单的做法是用层序遍历BFS，但是此题也可以用DFS深度遍历做，比较巧妙。两种思路的时间复杂度是O(n)，空间复杂度是O(n^2)，这个空间是返回二维 list 所需的空间。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n^2)</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// normal case</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(cur.val);<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                &#125;<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> queue = [root];<br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> list = [];<br>        <span class="hljs-keyword">let</span> size = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>            list.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span> !== <span class="hljs-literal">null</span>) queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span> !== <span class="hljs-literal">null</span>) queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS的思路的要点在于，需要在递归函数中多一个参数 level，记录当前递归到树的第几层了，同时这个level也决定了最后的结果集里面有几个 subarray。跑一下例子好了。当第一次把根节点3放进res之后，下面就开始遍历他的两个孩子，此时level是1。遍历到左孩子9的时候，level是1，大于等于res.length(1)，所以需要再加入一个subarray（15行）以便于加入9这个节点（17行）。当遍历右孩子20的时候，level依然是1，并不大于等于res.length(2)，所以此时并不需要再加入subarray了。但是20依然可以被放进最后的结果集。简而言之，DFS用了一个level参数来判断是否大于结果集此时的长度，以决定是否需要再添加新的subarray来存放下一层的节点值。</p><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-title function_">helper</span>(res, root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-keyword">var</span> helper = <span class="hljs-keyword">function</span>(<span class="hljs-params">res, root, level</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (level &gt;= res.<span class="hljs-property">length</span>) &#123;<br>        res.<span class="hljs-title function_">push</span>([]);<br>    &#125;<br>    res[level].<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-title function_">helper</span>(res, root.<span class="hljs-property">left</span>, level + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">helper</span>(res, root.<span class="hljs-property">right</span>, level + <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">102. Binary Tree Level Order Traversal<br>107. Binary Tree Level Order Traversal II<br>429. N-ary Tree Level Order Traversal<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 145. Binary Tree Postorder Traversal</title>
    <link href="/posts/1579637700.html"/>
    <url>/posts/1579637700.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the postorder traversal of its nodes’ values.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="Example 1"><br>Input: root &#x3D; [1,null,2,3]<br>Output: [3,2,1]</p><p>Example 2:<br>Input: root &#x3D; []<br>Output: []</p><p>Example 3:<br>Input: root &#x3D; [1]<br>Output: [1]</p><p>Constraints:<br>The number of the nodes in the tree is in the range [0, 100].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><blockquote><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>依然是迭代和递归两种做法，两种做法的时间复杂度均是O(n)，空间复杂度均是O(h)。<br>递归没什么好讲的，直接上代码。还是用这个<a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">更完整的例子</a>参考。</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal.png" alt="Tree Traversal"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            res.addFirst(cur.val);<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>stack.push(cur.left);<br>&#125;<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>stack.push(cur.right);<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>        helper(res, root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Integer&gt; res, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>        helper(res, root.left);<br>        helper(res, root.right);<br>        res.add(root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 94. Binary Tree Inorder Traversal</title>
    <link href="/posts/3761585457.html"/>
    <url>/posts/3761585457.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the inorder traversal of its nodes’ values.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg" alt="Example 1"><br>Input: root &#x3D; [1,null,2,3]<br>Output: [1,3,2]</p><p>Example 2:<br>Input: root &#x3D; []<br>Output: []</p><p>Example 3:<br>Input: root &#x3D; [1]<br>Output: [1]</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 100].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><p>二叉树的中序遍历。</p><blockquote><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>中序遍历我记为 左 - 根 - 右。<br>还是用<a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">GeeksforGeeks的例子</a>来描述如何做中序遍历吧。</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal.png" alt="Tree Traversal"></p><p>树的遍历大部分都是可以给出迭代和递归两种做法的，此题我也给出两种做法。两种做法的时间和空间复杂度一样，时间都是O(n)，空间都是O(h)。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h)</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代的做法需要用到一个栈。我们从根节点开始遍历，如果当前节点有左孩子，则把当前节点入栈的同时，一直往左子树走，这样我们能遍历到从根节点开始能走到的最深的左子树的叶子节点，这个节点也是中序遍历的结果的第一个。如果当前节点再没有左子树了，则把当前节点从栈弹出并记录到结果集的同时，往右子树走。这个遍历方式暗合了中序遍历的顺序，节点在从栈中被弹出的时候被加入结果集。</p><h2 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归代码，很直白"><a href="#递归代码，很直白" class="headerlink" title="递归代码，很直白"></a>递归代码，很直白</h3><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            res.add(cur.val);<br>            cur = cur.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于为什么很多树的题目的空间复杂度是O(h) - 树的高度，我这里给一个<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31213/Iterative-solution-in-Java-simple-and-readable/487633">discussion里面看到的截图</a>。我看到这个截图我彻底懂了为什么是跟树的高度有关了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>inorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 226. Invert Binary Tree</title>
    <link href="/posts/439678321.html"/>
    <url>/posts/439678321.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, invert the tree, and return its root.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="Example 1"><br>Input: root &#x3D; [4,2,7,1,3,6,9]<br>Output: [4,7,2,9,6,3,1]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="Example 2"><br>Input: root &#x3D; [2,1,3]<br>Output: [2,3,1]</p><p>Example 3:<br>Input: root &#x3D; []<br>Output: []</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 100].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>翻转二叉树。</p><blockquote><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>是一道不会做，会写 homebrew 也枉然的题。题干即是题意。例子如下，即层层遍历，把左右子树交换。<br>两种思路，分别是层序遍历（BFS）和深度遍历（DFS）。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br>Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.offer(root);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur.left;<br>cur.left = cur.right;<br>cur.right = temp;<br><span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>queue.offer(cur.right);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;<br><span class="hljs-keyword">let</span> queue = [root];<br><span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br><span class="hljs-keyword">let</span> current = queue.<span class="hljs-title function_">shift</span>();<br><span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-title function_">swap</span>(current);<br>queue.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">left</span>);<br>queue.<span class="hljs-title function_">push</span>(current.<span class="hljs-property">right</span>);<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">swap</span> = tree =&gt; &#123;<br><span class="hljs-keyword">let</span> temp = tree.<span class="hljs-property">left</span>;<br>tree.<span class="hljs-property">left</span> = tree.<span class="hljs-property">right</span>;<br>tree.<span class="hljs-property">right</span> = temp;<br><span class="hljs-keyword">return</span> tree;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        helper(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = temp;<br>        helper(root.left);<br>        helper(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">root</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">TreeNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br><span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br><span class="hljs-keyword">let</span> left = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);<br><span class="hljs-keyword">let</span> right = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);<br>root.<span class="hljs-property">left</span> = right;<br>root.<span class="hljs-property">right</span> = left;<br><span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 100. Same Tree</title>
    <link href="/posts/493219564.html"/>
    <url>/posts/493219564.html</url>
    
    <content type="html"><![CDATA[<p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="Example 1"><br>Input: p &#x3D; [1,2,3], q &#x3D; [1,2,3]<br>Output: true</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="Example 2"><br>Input: p &#x3D; [1,2], q &#x3D; [1,null,2]<br>Output: false</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="Example 3"><br>Input: p &#x3D; [1,2,1], q &#x3D; [1,1,2]<br>Output: false</p><p>Constraints:<br>The number of nodes in both trees is in the range [0, 100].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104</p><p>相同的树。</p><blockquote><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给两个树，判断他们是否相同。有两种思路，bfs和dfs。bfs是按层遍历tree，将每层的node塞进queue然后弹出比较，需要注意塞进queue的顺序。此处我只实现了dfs的做法。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (p.val == q.val) &#123;<br><span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">p</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">TreeNode</span>&#125; <span class="hljs-variable">q</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> isSameTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">p, q</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">if</span> (p.<span class="hljs-property">val</span> == q.<span class="hljs-property">val</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">isSameTree</span>(p.<span class="hljs-property">left</span>, q.<span class="hljs-property">left</span>) &amp;&amp; <span class="hljs-title function_">isSameTree</span>(p.<span class="hljs-property">right</span>, q.<span class="hljs-property">right</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">100. Same Tree<br>572. Subtree of Another Tree<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 104. Maximum Depth of Binary Tree</title>
    <link href="/posts/861348967.html"/>
    <url>/posts/861348967.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return its maximum depth.</p><p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="Example 1"><br>Input: root &#x3D; [3,9,20,null,null,15,7]<br>Output: 3</p><p>Example 2:<br>Input: root &#x3D; [1,null,2]<br>Output: 2</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 104].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>二叉树的最大深度。</p><blockquote><p>给定一个二叉树 root ，返回其最大深度。<br>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是后序遍历的基础题，直接上代码。影子题 543。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h) - 树的高度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(leftMax, rightMax) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">104. Maximum Depth of Binary Tree<br>110. Balanced Binary Tree<br>366. Find Leaves of Binary Tree<br>543. Diameter of Binary Tree<br>1522. Diameter of N-Ary Tree<br>1245. Tree Diameter<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>postorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 42. Trapping Rain Water</title>
    <link href="/posts/2315972221.html"/>
    <url>/posts/2315972221.html</url>
    
    <content type="html"><![CDATA[<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="Example 1"><br>Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6<br>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</p><p>Example 2:<br>Input: height &#x3D; [4,2,0,3,2,5]<br>Output: 9</p><p>Constraints:<br>n &#x3D;&#x3D; height.length<br>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 105</p><p>接雨水。</p><blockquote><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><h2 id="思路一-双指针"><a href="#思路一-双指针" class="headerlink" title="思路一 - 双指针"></a>思路一 - 双指针</h2><p>首先是双指针解法（two pointer）。思路是对于任意位置 i，在 i 位置上的积水，是由其左右两边较矮的 bar（可以想象为挡板）的高度和 i 位置的高度的差值决定的。即 volume[i] &#x3D; [Math.min(left[i], right[i]) - A[i]] * 1。这里的 1 是宽度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 意味着右边一定有一个挡板 height[right] 可以使当前位置存得住水</span><br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                leftMax = Math.max(leftMax, height[left]);<br>                res += leftMax - height[left];<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 左边一定有一个挡板 height[left] 可以使当前位置存得住水</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                rightMax = Math.max(rightMax, height[right]);<br>                res += rightMax - height[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">height</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> trap = <span class="hljs-keyword">function</span>(<span class="hljs-params">height</span>) &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> leftMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> rightMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>            leftMax = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(leftMax, height[left]);<br>            res += leftMax - height[left];<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rightMax = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(rightMax, height[right]);<br>            res += rightMax - height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-单调栈"><a href="#思路二-单调栈" class="headerlink" title="思路二 - 单调栈"></a>思路二 - 单调栈</h2><p>再来是单调栈的解法。单调栈的思想可以参见84题。动图可以参考<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/">这个帖子</a>。这道题为什么可以用单调栈做是因为如果我们能在某个位置上存水（假设 i 好了），那么在 i 左边的挡板必然是要比 i 高的（左边能挡住），当在 i 的右边突然有一个挡板高度比 i 要高的时候，i 的右边也能被挡住了，所以我们就可以结算在 i 位置到底能存多少水了。</p><p>对于本题来说，我们寻求的是一个单调递减栈。栈内存的是数组的下标。当遇到一个元素比栈顶元素大的时候，就开始往外 pop 元素。这样被 pop 的坐标对应的水量其实是最低点，左挡板是最低点左边的一个 index，右挡板是当前这个比栈顶元素大的高度。其他计算水量的步骤跟双指针没有区别。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (height == <span class="hljs-literal">null</span> || height.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-comment">// 如果栈顶元素一直相等，那么全都pop出去，只留第一个</span><br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] == height[index]) &#123;<br>                    stack.pop();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> stack.peek();<br>                    res += (Math.min(height[start], height[i]) - height[index]) * (i - start - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            stack.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">height</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> trap = <span class="hljs-keyword">function</span> (<span class="hljs-params">height</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (height === <span class="hljs-literal">null</span> || height.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &amp;&amp; height[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] &lt; height[i]) &#123;<br>            <span class="hljs-keyword">let</span> index = stack.<span class="hljs-title function_">pop</span>();<br>            <span class="hljs-keyword">while</span> (<br>                stack.<span class="hljs-property">length</span> &amp;&amp;<br>                height[stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]] == height[index]<br>            ) &#123;<br>                stack.<span class="hljs-title function_">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-keyword">let</span> start = stack[stack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>                res +=<br>                    (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[start], height[i]) - height[index]) *<br>                    (i - start - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>stack</tag>
      
      <tag>monotonic stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 144. Binary Tree Preorder Traversal</title>
    <link href="/posts/3110873426.html"/>
    <url>/posts/3110873426.html</url>
    
    <content type="html"><![CDATA[<p>Given the root of a binary tree, return the preorder traversal of its nodes’ values.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="Example 1"><br>Input: root &#x3D; [1,null,2,3]<br>Output: [1,2,3]</p><p>Example 2:<br>Input: root &#x3D; []<br>Output: []</p><p>Example 3:<br>Input: root &#x3D; [1]<br>Output: [1]</p><p>Constraints:<br>The number of nodes in the tree is in the range [0, 100].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p><p>二叉树的前序遍历。</p><blockquote><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>树的几种遍历，网上有一个不错的<a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">例子</a>，一个树给了多种遍历的结果。</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230623123129/traversal.png" alt="Tree Traversal"></p><p>二叉树的遍历有多种方式，此题是要求用先序遍历。先序遍历的特点是根 - 左 - 右。即如果只有一个根节点和两个子节点的情形下（比如[1, 2, 3]），输出结果应该也是[1, 2, 3]。这题迭代和递归都需要掌握。遍历的时候会用到栈，因为栈是先进后出，所以放进栈的时候记得要逆向，先放右孩子再放左孩子，这样弹出的时候就会先弹出左孩子，再弹出右孩子。两种做法的时间复杂度是O(n)，空间复杂度是O(h)。h是树的高度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(h)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            res.add(cur.val);<br>            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(cur.left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        helper(res, root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(List&lt;Integer&gt; res, TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        res.add(root.val);<br>        helper(res, root.left);<br>        helper(res, root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>tree</tag>
      
      <tag>dfs</tag>
      
      <tag>java</tag>
      
      <tag>preorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Leetcode] 58. Length of Last Word</title>
    <link href="/posts/2352395276.html"/>
    <url>/posts/2352395276.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s consisting of words and spaces, return the length of the last word in the string.</p><p>A word is a maximal substring consisting of non-space characters only.</p><p>Example 1:<br>Input: s &#x3D; “Hello World”<br>Output: 5<br>Explanation: The last word is “World” with length 5.</p><p>Example 2:<br>Input: s &#x3D; “   fly me   to   the moon  “<br>Output: 4<br>Explanation: The last word is “moon” with length 4.</p><p>Example 3:<br>Input: s &#x3D; “luffy is still joyboy”<br>Output: 6<br>Explanation: The last word is “joyboy” with length 6.</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s consists of only English letters and spaces ‘ ‘.<br>There will be at least one word in s.</p><p>最后一个单词的长度。</p><blockquote>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</blockquote><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>因为 input 字符串里有空格，所以可以将 string 根据空格分割成 string array。分割后直接看 string array 中最后一个单词的长度。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// O(n) space, O(n) time</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLastWord</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br>String[] words = s.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> words[n - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> last.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>不使用额外空间，从后往前扫描 input 字符串，遇到第一个空格就停下，此时停下的位置到字符串末尾的距离就是最后一个单词的长度。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// O(1) space, O(n) time</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLastWord</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        s = s.trim();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lengthOfLastWord = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (s === <span class="hljs-literal">null</span> || s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> input = s.<span class="hljs-title function_">trim</span>();<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = input.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (input[i] !== <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 16. 3Sum Closest</title>
    <link href="/posts/1495533668.html"/>
    <url>/posts/1495533668.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.</p><p>Return the sum of the three integers.</p><p>You may assume that each input would have exactly one solution.</p><p>Example 1:<br>Input: nums &#x3D; [-1,2,1,-4], target &#x3D; 1<br>Output: 2<br>Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2).</p><p>Example 2:<br>Input: nums &#x3D; [0,0,0], target &#x3D; 1<br>Output: 0<br>Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 &#x3D; 0).</p><p>Constraints:<br>3 &lt;&#x3D; nums.length &lt;&#x3D; 500<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p>最接近的三数之和。</p><blockquote><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/3sum-closest">https://leetcode.cn/problems/3sum-closest</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数组和一个 target 数字，返回一个三数之和使得 nums[A] + nums[B] + nums[C] &#x3D; target 或尽可能接近 target。</p><p>思路跟15题类似，也是需要先排序。排序之后，先固定第一个数字，然后后两个数字之间做 two pointer 逼近。逼近的方式是如果</p><ul><li>res &#x3D; nums[A] + nums[B] + nums[C] &#x3D; target，则直接返回这个res；</li><li>如果res大于target，C–</li><li>如果res小于target，B++</li></ul><p>注意在排序过后， res 的初始化是 res &#x3D; nums[0] + nums[1] + nums[nums.length - 1]。因为这个值是全局最小的三数之和。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n^2) - worst case<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threeSumClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[lo] + nums[hi];<br>                <span class="hljs-keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(res - target)) &#123;<br>                    res = sum;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                    hi--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    lo++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[len - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> low, high, sum;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">2</span>; i++) &#123;<br>        low = i + <span class="hljs-number">1</span>;<br>        high = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            sum = nums[i] + nums[low] + nums[high];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target - sum) &lt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target - res)) &#123;<br>                res = sum;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                high--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                low++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 234. Palindrome Linked List</title>
    <link href="/posts/209010631.html"/>
    <url>/posts/209010631.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a singly linked list, return true if it is a palindrome or false otherwise.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,2,1]<br>Output: true</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="Example 2"><br>Input: head &#x3D; [1,2]<br>Output: false</p><p>Constraints:<br>The number of nodes in the list is in the range [1, 105].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</p><p>Follow up: Could you do it in O(n) time and O(1) space?</p><p>回文链表。</p><blockquote><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个链表，判断是不是回文链表。思路是快慢指针找到链表中点，reverse 后半段，然后比较前半和后半。题目要求不能使用额外空间。</p><p>注意代码中找中点的部分，slow 指针需要停在前半部分的最后一个节点。这个细节容易错。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - 题目要求<br>空间O(1) - 题目要求</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        middle.next = reverse(middle.next);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> middle.next;<br>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span> &amp;&amp; p2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1.val != p2.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 注意这里找中点的写法，middle会停在左半边的最后一个节点</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> middle = <span class="hljs-title function_">findMiddle</span>(head);<br>    middle.<span class="hljs-property">next</span> = <span class="hljs-title function_">reverse</span>(middle.<span class="hljs-property">next</span>);<br><br>    <span class="hljs-keyword">let</span> p = head;<br>    <span class="hljs-keyword">let</span> q = middle.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">while</span> (p !== <span class="hljs-literal">null</span> &amp;&amp; q !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-property">val</span> !== q.<span class="hljs-property">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        p = p.<span class="hljs-property">next</span>;<br>        q = q.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> findMiddle = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = head;<br>    <span class="hljs-keyword">let</span> fast = head.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-keyword">var</span> reverse = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">let</span> next = head.<span class="hljs-property">next</span>;<br>        head.<span class="hljs-property">next</span> = pre;<br>        pre = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">125. Valid Palindrome<br>234. Palindrome Linked List<br>680. Valid Palindrome II<br>2130. Maximum Twin Sum of a Linked List<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
      <tag>palindrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 143. Reorder List</title>
    <link href="/posts/2054055723.html"/>
    <url>/posts/2054055723.html</url>
    
    <content type="html"><![CDATA[<p>You are given the head of a singly linked-list. The list can be represented as:<br>L0 → L1 → … → Ln - 1 → Ln</p><p>Reorder the list to be on the following form:<br>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>You may not modify the values in the list’s nodes. Only nodes themselves may be changed.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,3,4]<br>Output: [1,4,2,3]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg" alt="Example 2"><br>Input: head &#x3D; [1,2,3,4,5]<br>Output: [1,5,2,4,3]</p><p>Constraints:<br>The number of nodes in the list is in the range [1, 5 * 104].<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><p>重排链表。</p><blockquote>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/reorder-list">https://leetcode.cn/problems/reorder-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路也很直观，但是代码容易错，算是链表题里面的综合题吧，有链表的快慢指针fast-slow pointer，反转reverse，和merge两个链表三个技能点的考察。找快慢指针的时候记得设一个temp node，因为slow停下的地方会是second half的起点，这个temp指针会停在first half的尾部。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> middle.next;<br>        middle.next = <span class="hljs-literal">null</span>;<br>        second = reverse(second);<br>        merge(first, second);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode left, ListNode right)</span> &#123;<br>        ListNode leftTemp;<br>        ListNode rightTemp;<br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            leftTemp = left.next;<br>            rightTemp = right.next;<br>            left.next = right;<br>            right.next = leftTemp;<br>            left = leftTemp;<br>            right = rightTemp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify head in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reorderList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> fast = head;<br>    <span class="hljs-keyword">let</span> slow = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.<span class="hljs-property">next</span>) &#123;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        slow = slow.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-title function_">reverseList</span>(slow.<span class="hljs-property">next</span>);<br>    slow.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> first = head;<br>    <span class="hljs-keyword">while</span> (second) &#123;<br>        <span class="hljs-keyword">let</span> temp = second.<span class="hljs-property">next</span>;<br>        second.<span class="hljs-property">next</span> = first.<span class="hljs-property">next</span>;<br>        first.<span class="hljs-property">next</span> = second;<br>        first = first.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        second = temp;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">let</span> next = head.<span class="hljs-property">next</span>;<br>        head.<span class="hljs-property">next</span> = pre;<br>        pre = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 21. Merge Two Sorted Lists</title>
    <link href="/posts/1602189076.html"/>
    <url>/posts/1602189076.html</url>
    
    <content type="html"><![CDATA[<p>You are given the heads of two sorted linked lists list1 and list2.</p><p>Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.</p><p>Return the head of the merged linked list.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="Example 1"><br>Input: list1 &#x3D; [1,2,4], list2 &#x3D; [1,3,4]<br>Output: [1,1,2,3,4,4]</p><p>Example 2:<br>Input: list1 &#x3D; [], list2 &#x3D; []<br>Output: []</p><p>Example 3:<br>Input: list1 &#x3D; [], list2 &#x3D; [0]<br>Output: [0]</p><p>Constraints:<br>The number of nodes in both lists is in the range [0, 50].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>Both list1 and list2 are sorted in non-decreasing order.</p><p>合并两个有序链表。</p><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是用一个 dummy node 去遍历两个链表，对于来自两个链表上的 node，谁的 val 小谁就在前。直接上代码。</p><p>这题的 followup 会是 merge K 个链表，参见 23 题。影子题 148，做法几乎一模一样。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(m + n)，两个链表的长度<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> cur = dummy;<br>    <span class="hljs-keyword">while</span> (l1 !== <span class="hljs-literal">null</span> &amp;&amp; l2 !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (l1.<span class="hljs-property">val</span> &lt; l2.<span class="hljs-property">val</span>) &#123;<br>            cur.<span class="hljs-property">next</span> = l1;<br>            l1 = l1.<span class="hljs-property">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.<span class="hljs-property">next</span> = l2;<br>            l2 = l2.<span class="hljs-property">next</span>;<br>        &#125;<br>        cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 !== <span class="hljs-literal">null</span>) &#123;<br>        cur.<span class="hljs-property">next</span> = l1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l2 !== <span class="hljs-literal">null</span>) &#123;<br>        cur.<span class="hljs-property">next</span> = l2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">21. Merge Two Sorted Lists<br>23. Merge k Sorted Lists<br>148. Sort List<br>1634. Add Two Polynomials Represented as Linked Lists<br>1940. Longest Common Subsequence Between Sorted Arrays<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>sort</tag>
      
      <tag>linked list</tag>
      
      <tag>merge sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 142. Linked List Cycle II</title>
    <link href="/posts/1205473881.html"/>
    <url>/posts/1205473881.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p><p>Do not modify the linked list.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example 1"><br>Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>Output: tail connects to node index 1<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example 2"><br>Input: head &#x3D; [1,2], pos &#x3D; 0<br>Output: tail connects to node index 0<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example 3"><br>Input: head &#x3D; [1], pos &#x3D; -1<br>Output: no cycle<br>Explanation: There is no cycle in the linked list.</p><p>Constraints:<br>The number of the nodes in the list is in the range [0, 104].<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos is -1 or a valid index in the linked-list.</p><p>Follow up: Can you solve it using O(1) (i.e. constant) memory?</p><p>单链表中的环二。</p><blockquote>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii">https://leetcode.cn/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个链表，如果这个链表中有环，请 return 环的起点；若没有，return null。找是否有环可以参照 141 题的讲解。至于怎么找到环的起点，我这里引用一个<a href="https://www.cnblogs.com/hiddenfox/p/3408931.html">非常好的讲解</a>。</p><p>因为快慢指针的速度是一个 2 步一个 1 步，所以当两个指针相遇的时候，fast 走过的长度一定是 slow 的两倍。两者相遇的地方一定是环的起点。至于证明，直接参照引用贴。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow2</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-keyword">while</span> (slow != slow2) &#123;<br>                    slow = slow.next;<br>                    slow2 = slow2.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> slow = head;<br><span class="hljs-keyword">let</span> fast = head;<br><span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>slow = slow.<span class="hljs-property">next</span>;<br>fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br><span class="hljs-keyword">if</span> (fast === slow) &#123;<br><span class="hljs-keyword">let</span> slow2 = head;<br><span class="hljs-keyword">while</span> (slow !== slow2) &#123;<br>slow = slow.<span class="hljs-property">next</span>;<br>slow2 = slow2.<span class="hljs-property">next</span>;<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 141. Linked List Cycle</title>
    <link href="/posts/1713835924.html"/>
    <url>/posts/1713835924.html</url>
    
    <content type="html"><![CDATA[<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Return true if there is a cycle in the linked list. Otherwise, return false.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Example 1"><br>Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="Example 2"><br>Input: head &#x3D; [1,2], pos &#x3D; 0<br>Output: true<br>Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</p><p>Example 3:<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="Example 3"><br>Input: head &#x3D; [1], pos &#x3D; -1<br>Output: false<br>Explanation: There is no cycle in the linked list.</p><p>Constraints:<br>The number of the nodes in the list is in the range [0, 104].<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos is -1 or a valid index in the linked-list.</p><p>Follow up: Can you solve it using O(1) (i.e. constant) memory?</p><p>环形链表。</p><blockquote>给你一个链表的头节点 head ，判断链表中是否有环。<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/linked-list-cycle">https://leetcode.cn/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意很简单，思路是用快慢指针，慢指针每走一步，快指针走两步。如果快慢指针在某个地方相遇了，说明有环；否则快指针就会遍历到链表尾部从而会退出循环。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>slow = slow.next;<br>fast = fast.next.next;<br><span class="hljs-keyword">if</span> (slow == fast) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> slow = head;<br><span class="hljs-keyword">let</span> fast = head;<br><span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>slow = slow.<span class="hljs-property">next</span>;<br>fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br><span class="hljs-keyword">if</span> (slow === fast) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 82. Remove Duplicates from Sorted List II</title>
    <link href="/posts/3573206258.html"/>
    <url>/posts/3573206258.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,3,3,4,4,5]<br>Output: [1,2,5]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt="Example 2"><br>Input: head &#x3D; [1,1,1,2,3]<br>Output: [2,3]</p><p>Constraints:<br>The number of nodes in the list is in the range [0, 300].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>The list is guaranteed to be sorted in ascending order.</p><p>删除排序链表中的重复元素II。</p><blockquote>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟版本一很接近，唯一的区别是，版本一是请你删除重复元素，使得 output 里面每个元素只出现一次。版本二是请你删除所有出现超过一次的元素。思路是需要创建一个 dummy 节点，放在所有需要遍历的节点之前，遍历的时候，找是否有两个节点的 val 相同，找到后记下这个 val。再往后遍历的时候，只要遇到这个 val 就跳过。</p><p>比如第一个例子好了，当 cur 遍历到 2 的时候，cur.next &#x3D;&#x3D; 3, cur.next.next &#x3D;&#x3D; 3；此时记录 sameVal &#x3D; cur.next.val。接着从 cur.next 开始判断，只要 cur.next.val &#x3D;&#x3D; 3 的时候，就 cur.next &#x3D; cur.next.next。</p><p>如果是比如一开始遍历到 1 的时候好了，此时cur.next &#x3D;&#x3D; 2，cur.next.next &#x3D;&#x3D; 3，两者并不相等，所以直接就遍历下一个节点，cur &#x3D; cur.next。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-comment">// 注意这里cur是从dummy开始</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sameVal</span> <span class="hljs-operator">=</span> cur.next.val;<br>                <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == sameVal) &#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> deleteDuplicates = <span class="hljs-keyword">function</span> (<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> cur = dummy;<br>    <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span> &amp;&amp; cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">next</span>.<span class="hljs-property">val</span> === cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>.<span class="hljs-property">val</span>) &#123;<br>            <span class="hljs-keyword">let</span> sameVal = cur.<span class="hljs-property">next</span>.<span class="hljs-property">val</span>;<br>            <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span> &amp;&amp; cur.<span class="hljs-property">next</span>.<span class="hljs-property">val</span> === sameVal) &#123;<br>                cur.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">83. Remove Duplicates from Sorted List<br>82. Remove Duplicates from Sorted List II<br>1836. Remove Duplicates From an Unsorted Linked List<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 83. Remove Duplicates from Sorted List</title>
    <link href="/posts/3569698204.html"/>
    <url>/posts/3569698204.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="Example 1"><br>Input: head &#x3D; [1,1,2]<br>Output: [1,2]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="Example 2"><br>Input: head &#x3D; [1,1,2,3,3]<br>Output: [1,2,3]</p><p>Constraints:<br>The number of nodes in the list is in the range [0, 300].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>The list is guaranteed to be sorted in ascending order.</p><p>删除排序链表中的重复元素。</p><blockquote>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路很简单，每次去看一下当前节点和下一个节点的val是否相同，如是，则跳过下一个节点。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> deleteDuplicates = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> cur = head;<br>    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span> &amp;&amp; cur.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">val</span> === cur.<span class="hljs-property">next</span>.<span class="hljs-property">val</span>) &#123;<br>            cur.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.<span class="hljs-property">next</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">83. Remove Duplicates from Sorted List<br>82. Remove Duplicates from Sorted List II<br>1836. Remove Duplicates From an Unsorted Linked List<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 19. Remove Nth Node From End of List</title>
    <link href="/posts/2412012849.html"/>
    <url>/posts/2412012849.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="Exapmle 1"><br>Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>Output: [1,2,3,5]</p><p>Example 2:<br>Input: head &#x3D; [1], n &#x3D; 1<br>Output: []</p><p>Example 3:<br>Input: head &#x3D; [1,2], n &#x3D; 1<br>Output: [1]</p><p>Constraints:<br>The number of nodes in the list is sz.<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><p>Follow up: Could you do this in one pass?</p><p>移除链表倒数第N个节点。</p><blockquote>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是在头结点之前（一般我们创建dummy节点的位置）创建两个节点分别叫做 slow 和 fast。先让 fast 前移 N + 1 个节点，这样使得 slow 和 fast 之间有 N + 1 个节点的距离。然后同时让 slow 和 fast 前移，直到 fast 遍历到链表尾部。此刻 slow 停下来的位置就是需要移除的节点之前的那个节点。为什么需要使 slow 和 fast 之间有 N + 1 个节点的距离是因为我们移除的是 slow.next 这个节点。可以参考<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/dong-hua-tu-jie-leetcode-di-19-hao-wen-ti-shan-chu/">这个动图</a>帮助理解。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>        dummy.next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            fast = fast.next;<br>            <span class="hljs-comment">// System.out.println(fast.val);</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> slow = dummy;<br>    <span class="hljs-keyword">let</span> fast = dummy;<br>    dummy.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        fast = fast.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        fast = fast.<span class="hljs-property">next</span>;<br>    &#125;<br>    slow.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 189. Rotate Array</title>
    <link href="/posts/2374147229.html"/>
    <url>/posts/2374147229.html</url>
    
    <content type="html"><![CDATA[<p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p><p>Example 1:<br>Input: [1,2,3,4,5,6,7] and k &#x3D; 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]</p><p>Example 2:<br>Input: [-1,-100,3,99] and k &#x3D; 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p><p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p><p>轮转数组。</p><blockquote><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意跟61题几乎一样，唯一不同的是这题的 input 是数组，所以代码上没什么参考性。这个题目的思路很巧妙，叫做三步反转法。我就拿第一个例子遍历好了。数组长度为7，要往右 rotate 三步。三步反转法的思路是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">start, [1, 2, 3, 4, 5, 6, 7]<br>整个rotate，[7, 6, 5, 4, 3, 2, 1]<br>rotate前k个， [5, 6, 7, 4, 3, 2, 1]<br>rotate后n - k个，[5, 6, 7, 1, 2, 3, 4]<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        k = k % nums.length;<br>        reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        reverse(nums, k, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start] = nums[end];<br>            nums[end] = temp;<br>            start++;<br>            end--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotate = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    k = k % nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-title function_">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">reverse</span>(nums, k, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> reverse = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, start, end</span>) &#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-keyword">let</span> temp = nums[start];<br>        nums[start] = nums[end];<br>        nums[end] = temp;<br>        start++;<br>        end--;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有一种JS的思路是 pop 再 shift，利用的是 JS 对 array 的各项操作。<br>时间O(k)<br>空间O(n)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotate = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    k = k % nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        nums.<span class="hljs-title function_">unshift</span>(nums.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">61. Rotate List<br>189. Rotate Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 61. Rotate List</title>
    <link href="/posts/493219566.html"/>
    <url>/posts/493219566.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a linked list, rotate the list to the right by k places.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>Output: [4,5,1,2,3]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="Example 2"><br>Input: head &#x3D; [0,1,2], k &#x3D; 4<br>Output: [2,0,1]</p><p>Constraints:<br>The number of nodes in the list is in the range [0, 500].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p><p>旋转链表。</p><blockquote>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意很简单，给一个 linked list 和一个数字 k，请你对 linked list 向右 rotate <code>k</code> 次，输出 rotate 后的结果。因为是单链表所以没法从右往左遍历链表。思路是将 input 先连成一个环，然后在新的 head 节点和其之前一个节点处断开即可。</p><p>代码里面注意几个细节。</p><ol><li>k 是有可能大于链表长度的，所以需要计算链表的长度 n，并用 n % k 计算出实际需要 rotate 的次数。</li><li>需要遍历链表两次，第一遍遍历是为了计算链表的长度，记为 n，同时记得把最后一个节点再连回 head 节点。</li><li>第二遍遍历链表的时候，cur 指针要停在新的 head 节点之前的那个节点。这个节点怎么计算呢？cur 需要从 1 开始，遍历到 n &#x3D; k % n 处，然后他的下一个节点才是新的 head 节点。</li></ol><p>跑一个例子</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">1 -<span class="hljs-number"> 2 </span>-<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>- 5, k = 2<br><br>先移动到链表末端，得到长度 len = 5<br><br>1 -<span class="hljs-number"> 2 </span>-<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>- 5<br><br>|______________|<br><br>h<br><br>               h<br><br>将链表末端再连到 head 节点，形成一个环<br><br>因为需要往右 rotate<span class="hljs-number"> 2 </span>次，所以实际上是要将 head 指针往后移动 len - k 次，这样 head 指针会在新的 head 之前的一个节点上（4）。此时新的 head 节点是 head.next<br><br>最后将<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 5 </span>之间的连接断开即可<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-comment">// 计算list长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span>) &#123;<br>            n++;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = head;<br>        <br>        cur = head;<br>        k %= n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - k % n; i++) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> rotateRight = <span class="hljs-keyword">function</span> (<span class="hljs-params">head, k</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> len = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> cur = head;<br><span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>cur = cur.<span class="hljs-property">next</span>;<br>len++;<br>&#125;<br>cur.<span class="hljs-property">next</span> = head;<br><br><span class="hljs-comment">// loop again</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len - (k % len); i++) &#123;<br>head = head.<span class="hljs-property">next</span>;<br>&#125;<br><span class="hljs-keyword">let</span> res = head.<span class="hljs-property">next</span>;<br>head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">61. Rotate List<br>189. Rotate Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>two pointer</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 34. Find First and Last Position of Element in Sorted Array</title>
    <link href="/posts/3185299605.html"/>
    <url>/posts/3185299605.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p><p>If target is not found in the array, return [-1, -1].</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1:<br>Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>Output: [3,4]</p><p>Example 2:<br>Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>Output: [-1,-1]</p><p>Example 3:<br>Input: nums &#x3D; [], target &#x3D; 0<br>Output: [-1,-1]</p><p>Constraints:<br>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums is a non-decreasing array.<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><p>在有序数组中查找元素的第一个和最后一个位置。</p><blockquote><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的最优解是二分法。思路是通过二分法分别找到第一个插入的位置和第二个插入的位置。注意找第一个位置和第二个位置的不同，两者都是正常的二分法，但是找第一个位置的时候要先顾到 start pointer，同时要优先动 start 指针；找第二个位置的时候要先顾到 end pointer，也优先动 end 指针。这道题很考察对二分法模板的运用。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> findFirst(nums, target);<br>        <span class="hljs-keyword">if</span> (start == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> findLast(nums, target);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; start, end &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFirst</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                start = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                end = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[start] == target) &#123;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[end] == target) &#123;<br>            <span class="hljs-keyword">return</span> end;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLast</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                end = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[end] == target) &#123;<br>            <span class="hljs-keyword">return</span> end;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[start] == target) &#123;<br>            <span class="hljs-keyword">return</span> start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> searchRange = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (nums === <span class="hljs-literal">null</span> || nums.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> start = <span class="hljs-title function_">findFirst</span>(nums, target);<br>    <span class="hljs-keyword">if</span> (start === -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">let</span> end = <span class="hljs-title function_">findLast</span>(nums, target);<br>    <span class="hljs-keyword">return</span> [start, end];<br>&#125;;<br><br><span class="hljs-keyword">var</span> findFirst = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> end = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(start + (end - start) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            start = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            end = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[start] === target) <span class="hljs-keyword">return</span> start;<br>    <span class="hljs-keyword">if</span> (nums[end] === target) <span class="hljs-keyword">return</span> end;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> findLast = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> end = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(start + (end - start) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            end = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            start = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nums[end] === target) <span class="hljs-keyword">return</span> end;<br>    <span class="hljs-keyword">if</span> (nums[start] === target) <span class="hljs-keyword">return</span> start;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">34. Find First and Last Position of Element in Sorted Array<br>658. Find K Closest Elements<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 162. Find Peak Element</title>
    <link href="/posts/2917377662.html"/>
    <url>/posts/2917377662.html</url>
    
    <content type="html"><![CDATA[<p>A peak element is an element that is strictly greater than its neighbors.</p><p>Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.</p><p>You may imagine that nums[-1] &#x3D; nums[n] &#x3D; -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p><p>You must write an algorithm that runs in O(log n) time.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.</p><p>Example 2:<br>Input: nums &#x3D; [1,2,1,3,5,6,4]<br>Output: 5<br>Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>nums[i] !&#x3D; nums[i + 1] for all valid i.</p><p>寻找峰值。</p><blockquote><p>峰值元素是指其值大于左右相邻值的元素。<br>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-peak-element">https://leetcode-cn.com/problems/find-peak-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给一个数组，数组满足条件nums[i] ≠ nums[i+1]，求数组峰值的下标。这个题的👎多于👍，估计是因为峰值不止一个吧，我做的时候也踩了坑。<br>思路是用二分法，因为题目要求时间复杂度是 log 级别。根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r &#x3D; m，如果 m + 1 较大，则右侧存在峰值，l &#x3D; m + 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findPeakElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 峰值可能在mid左侧</span><br><span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>end = mid;<br>&#125;<br><span class="hljs-comment">// 峰值在mid右侧</span><br><span class="hljs-keyword">else</span> &#123;<br>start = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[start] &gt; nums[end]) &#123;<br><span class="hljs-keyword">return</span> start;<br>&#125;<br><span class="hljs-keyword">return</span> end;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findPeakElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> end = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (start + <span class="hljs-number">1</span> &lt; end) &#123;<br><span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(start + (end - start) / <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>end = mid;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>start = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[start] &gt; nums[end]) &#123;<br><span class="hljs-keyword">return</span> start;<br>&#125;<br><span class="hljs-keyword">return</span> end;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">162. Find Peak Element<br>852. Peak Index in a Mountain Array<br>1095. Find in Mountain Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 11. Container With Most Water</title>
    <link href="/posts/308930466.html"/>
    <url>/posts/308930466.html</url>
    
    <content type="html"><![CDATA[<p>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p><p>Return the maximum amount of water a container can store.</p><p>Notice that you may not slant the container.</p><p>Example 1:<br><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="Image"><br>Input: height &#x3D; [1,8,6,2,5,4,8,3,7]<br>Output: 49<br>Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p>Example 2:<br>Input: height &#x3D; [1,1]<br>Output: 1</p><p>Constraints:<br>n &#x3D;&#x3D; height.length<br>2 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 104</p><p>盛最多水的容器。</p><blockquote><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/container-with-most-water">https://leetcode.cn/problems/container-with-most-water</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针，两边往中间逼近。逼近的条件是哪边的高度比较矮，就移动哪个指针。<br>存储水量 &#x3D; 宽度 * 高度 &#x3D; (right - left) * Math.min(height[left], height[right])</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>res = Math.max(res, Math.min(height[left], height[right]) * (right - left));<br><span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>left++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">height</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxArea = <span class="hljs-keyword">function</span>(<span class="hljs-params">height</span>) &#123;<br><span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> right = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[left], height[right]) * (right - left));<br><span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>left++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. Maximum Subarray</title>
    <link href="/posts/1981257283.html"/>
    <url>/posts/1981257283.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>A subarray is a contiguous part of an array.</p><p>Example 1:<br>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</p><p>Example 2:<br>Input: nums &#x3D; [1]<br>Output: 1</p><p>Example 3:<br>Input: nums &#x3D; [5,4,-1,7,8]<br>Output: 23</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><p>最大子数组。</p><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-subarray">https://leetcode.cn/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是动态规划，我参考了<a href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">这个帖子</a>，写的非常好，解释了 DP 的定义是怎么来的。设 dp[i] 是以 nums[i] 结尾的子数组的和。扫描数组，当遇到某个数 nums[i] 的时候，需要判断 dp[i - 1] 是否小于 0。如果小于 0，nums[i] + dp[i - 1] 的结果只会拖累当前的 dp[i]；如果大于 0，可以将 dp[i] &#x3D; dp[i - 1] + nums[i] 。最后返回过程中找到的最大的 dp[i] 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = nums[i] + (dp[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[i - <span class="hljs-number">1</span>]);<br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这种 DP 的思路也有节省空间的做法，其实我们并不一定需要知道每个 dp[i] 值的大小，我们只需要在遍历过程中记录一下最大的 dp 值即可。思路也是很类似，如果之前的值 prev 小于 0，一定会拖累 cur 的，所以 cur &#x3D; nums[i]；反之如果 prev 大于 0，cur就变为 nums[i] + prev。每次用 res 记录一下当前的子数组的最大值之后，就可以把 cur 赋给 prev 以达到节省空间的目的了。</p><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prev &lt; <span class="hljs-number">0</span>) &#123;<br>                cur = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = prev + nums[i];<br>            &#125;<br>            res = Math.max(res, cur);<br>            prev = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><p>还有另外一种思路，类似 DP 的做法，是去求局部最大和整体最大。设两个变量 sum 和 res，sum 记录当遍历到 nums[i] 的时候，sum + nums[i] 是否对值的扩大有帮助；res 记录最大的 sum 值。</p><p>时间O(n)<br>空间O(1)</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            sum = Math.max(nums[i], sum + nums[i]);<br>            res = Math.max(res, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">53. Maximum Subarray<br>152. Maximum Product Subarray<br>918. Maximum Sum Circular Subarray<br>978. Longest Turbulent Subarray<br>1186. Maximum Subarray Sum with One Deletion<br>2272. Substring With Largest Variance<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>array</tag>
      
      <tag>dynamic programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 253. Meeting Rooms II</title>
    <link href="/posts/1415034902.html"/>
    <url>/posts/1415034902.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of meeting time intervals intervals where intervals[i] &#x3D; [starti, endi], return the minimum number of conference rooms required.</p><p>Example 1:<br>Input: intervals &#x3D; [[0,30],[5,10],[15,20]]<br>Output: 2</p><p>Example 2:<br>Input: intervals &#x3D; [[7,10],[2,4]]<br>Output: 1</p><p>Constraints:<br>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>0 &lt;&#x3D; starti &lt; endi &lt;&#x3D; 106</p><p>会议室 II。</p><blockquote>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/meeting-rooms-ii">https://leetcode.cn/problems/meeting-rooms-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-排序-双指针"><a href="#思路一-排序-双指针" class="headerlink" title="思路一 - 排序 + 双指针"></a>思路一 - 排序 + 双指针</h2><p>第一种是排序 + 双指针。具体做法是把每个会议的开始时间和结束时间拎出来分别排序，再遍历 intervals。遍历的时候，设置一个 pointer &#x3D; 0，判断当前 interval[i] 的开始时间是否大于前一个会议的结束时间 interval[pointer][end]。如果大于，就说明不需要新开一个会议室；如果小于，就需要新开一个会议室。因为题目只在意需要同时开几个会议室，所以 start 和 end 可以分别排序。end 只要结束一个，就意味着同时需要的会议室就少一个。</p><p>如果扫描线的题目做多了，一开始的本能反应可能是对 start 或者对 end 排序，看看是否存在 interval 之间的 overlap，但是其实是行不通的，因为可能存在比如某个会议 start 时间没有跟其他任何一个会议的 end 时间有冲突，但是有可能这个会议一直持续到最后，他的 end 时间跟别的会议也没有 overlap，但是他其实一直是占用一个房间的。</p><p>同时，为什么排序 + 双指针这个做法是正确的呢？对 start 和对 end 分别排序之后，因为 start 和 end 是有序的，在用双指针分别指向当前的 start 和当前的 end 的时候，只要当前 start 小于当前的 end，就一定要再开一个房间，因为当前确实是有一个会议没有结束。我们将 start 和 end 分别排序之后，其实是可以把数据抽象成如下这幅图的。</p><p>一开始，会议时间线是这样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">|_____|<br>      |______|<br>|________|<br>        |_______|<br></code></pre></td></tr></table></figure><p>如果把开始时间和结束时间分别排序，会变成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">||    ||<br>     |   |   |  |<br></code></pre></td></tr></table></figure><p>所以只要碰到 start，就一定要增加一个房间，碰到 end 就可以减少一个房间。我们在遍历的过程中找到同时使用的会议室的峰值即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - 因为有对 input 排序<br>空间O(n) - 有用额外数组对 start 和 end 排序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">intervals</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minMeetingRooms = <span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) &#123;<br>    <span class="hljs-keyword">let</span> start = [];<br>    <span class="hljs-keyword">let</span> end = [];<br>    <span class="hljs-keyword">let</span> len = intervals.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> cur = intervals[i];<br>        start.<span class="hljs-title function_">push</span>(cur[<span class="hljs-number">0</span>]);<br>        end.<span class="hljs-title function_">push</span>(cur[<span class="hljs-number">1</span>]);<br>    &#125;<br>    start = start.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    end = end.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> pointer = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (start[i] &lt; end[pointer]) &#123;<br>            res++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pointer++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (intervals == <span class="hljs-literal">null</span> || intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-type">int</span>[] start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">int</span>[] end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            start[i] = intervals[i][<span class="hljs-number">0</span>];<br>            end[i] = intervals[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        Arrays.sort(start);<br>        Arrays.sort(end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pointer</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (start[i] &lt; end[pointer]) &#123;<br>                res++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pointer++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-最小堆"><a href="#思路二-最小堆" class="headerlink" title="思路二 - 最小堆"></a>思路二 - 最小堆</h2><p>先对 intervals 按开始时间排序，再用一个最小堆存放每个 interval 的结束时间，并加入第一个 interval，此时堆顶是第一个 interval 的结束时间。遍历 intervals，判断当前 interval 的开始时间（A）跟堆顶 interval 的结束时间（B），若 A &gt;&#x3D; B 则说明两个 interval 没有 overlap，B 可以被弹出，A 放入堆中；若 A &lt; B，说明 B 那场会议还未结束，B 不能弹出，A 还是要放入堆中。最后堆的 size 就是所需的会议室数量。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)，其中排序O(nlogn)，heap的各项操作O(logn)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br><span class="hljs-comment">// 按开始时间排序</span><br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 堆顶是结束时间最小的会议</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a - b);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span>[] cur = intervals[i];<br>            <span class="hljs-keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peek() &lt;= cur[<span class="hljs-number">0</span>]) &#123;<br>                queue.poll();<br>            &#125;<br>            queue.offer(cur[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">252. Meeting Rooms<br>253. Meeting Rooms II<br>2406. Divide Intervals Into Minimum Number of Groups<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>heap</tag>
      
      <tag>line sweep</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 252. Meeting Rooms</title>
    <link href="/posts/3842132459.html"/>
    <url>/posts/3842132459.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of meeting time intervals where intervals[i] &#x3D; [start, end], determine if a person could attend all meetings.</p><p>Example 1:<br>Input: intervals &#x3D; [[0,30],[5,10],[15,20]]<br>Output: false</p><p>Example 2:<br>Input: intervals &#x3D; [[7,10],[2,4]]<br>Output: true</p><p>Constraints:<br>0 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; start &lt; end &lt;&#x3D; 106</p><p>会议室 I。</p><blockquote>给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/meeting-rooms">https://leetcode.cn/problems/meeting-rooms</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-按会议开始时间排序"><a href="#思路一-按会议开始时间排序" class="headerlink" title="思路一 - 按会议开始时间排序"></a>思路一 - 按会议开始时间排序</h2><p>给的 input 是一个二维数组，二维数组里面的每一个元素记录了每个会议的开始时间和结束时间。问同一个人是否有可能参加所有的会议。思路很简单，这是LC上算是一种比较特别的题型 - 扫描线。这题的思路是按照会议开始时间给 input 排序，如果有任何一个会议的结束时间 &gt; 下一个会议的开始时间，就 return false。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canAttendMeetings</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[][]</span>&#125; <span class="hljs-variable">intervals</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canAttendMeetings = <span class="hljs-keyword">function</span> (<span class="hljs-params">intervals</span>) &#123;<br><span class="hljs-keyword">let</span> sorted = intervals.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; sorted.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (sorted[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &gt; sorted[i][<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-按结束时间排序"><a href="#思路二-按结束时间排序" class="headerlink" title="思路二 - 按结束时间排序"></a>思路二 - 按结束时间排序</h2><p>这道题也可以按照会议结束时间排序，然后从第二个会议开始看，如果有任何一个会议的开始时间早于前一个会议的结束时间，则 return false。思路跟 JS 的版本其实都是类似的，无非是实现方式稍有差异。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canAttendMeetings</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">252. Meeting Rooms<br>253. Meeting Rooms II<br>2406. Divide Intervals Into Minimum Number of Groups<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>line sweep</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 35. Search Insert Position</title>
    <link href="/posts/2095984774.html"/>
    <url>/posts/2095984774.html</url>
    
    <content type="html"><![CDATA[<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>Output: 2</p><p>Example 2:<br>Input: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>Output: 1</p><p>Example 3:<br>Input: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>Output: 4</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums contains distinct values sorted in ascending order.<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p>搜索插入位置。</p><blockquote>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分法基础题。给一个数字和一个有序数组，如果这个数字在数组中存在，返回其坐标；否则返回它应该被插入的位置。</p><p>二分法不难想到，但是面试的重点是你如何能把二分法写对。我个人比较喜欢第一种实现方法。注意 while 循环的条件，比如我下面的代码，left &lt;&#x3D; right，你可以这样想，最后 while 跳出循环的时候，一定是 left &gt; right（与 while 里的条件相反），在 while 循环的最后一步的时候，left &#x3D;&#x3D; right，再走一步就跳出了 while 循环的条件了。同时，当我们找到任何一个 mid 但是 mid 上的元素不满足条件的时候，为什么 right &#x3D; mid - 1（left &#x3D; mid + 1）？那是因为 mid 位置上的元素一定不满足条件了，所以在确定新的边界的时候可以将 mid 去掉。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(logn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Java实现一"><a href="#Java实现一" class="headerlink" title="Java实现一"></a>Java实现一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number[]&#125; nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">var</span> <span class="hljs-variable">searchInsert</span> <span class="hljs-operator">=</span> function(nums, target) &#123;<br>    <span class="hljs-type">let</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">let</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">let</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> Math.floor(left + (right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Java实现二"><a href="#Java实现二" class="headerlink" title="Java实现二"></a>Java实现二</h3><p>因为右边界 right &#x3D; nums.length 在定义的时候就事实上已经越界了，下标最多是到 nums.length - 1 的。所以当 mid &gt; target 的时候，right &#x3D; mid，是为了确保 mid 也在被扫描的范围内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> searchInsert = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(left + (right - left) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] === target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">35. Search Insert Position<br>704. Binary Search<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 274. H-Index</title>
    <link href="/posts/1857571443.html"/>
    <url>/posts/1857571443.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his&#x2F;her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p><p>Example:</p><p>Input: citations &#x3D; [3,0,6,1,5]<br>Output: 3<br>Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had<br> received 3, 0, 6, 1, 5 citations respectively.<br> Since the researcher has 3 papers with at least 3 citations each and the remaining<br> two with no more than 3 citations each, her h-index is 3.<br>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p><p>H 指数。</p><blockquote>给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。<p>根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最大的那个。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/h-index">https://leetcode-cn.com/problems/h-index</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-二分查找"><a href="#思路一-二分查找" class="headerlink" title="思路一 - 二分查找"></a>思路一 - 二分查找</h2><p>根据题目的描述我们可以知道，h 应该是有一点“单调性”的。意思是如果我们返回 h &#x3D; 1，那一定对，因为肯定至少有 1 篇论文被引用的次数 &gt;&#x3D; 1。如果返回 h &#x3D; 100，就不一定对了，因为不可能有 100 篇论文被引用的次数 &gt;&#x3D; 100。所以这里我们可以用二分查找，找的就是最大的 h 的值。查找的下界是 1，这个很好理解；而上界是 citations.length，这个也很好理解，因为最多也就这么多篇论文。h 的定义是跟作者发的论文数量挂钩的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (helper(citations, mid)) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations, <span class="hljs-type">int</span> h)</span> &#123;<br>        <span class="hljs-comment">// count是引用数量大于等于h的文章数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> citation : citations) &#123;<br>            <span class="hljs-keyword">if</span> (citation &gt;= h) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count &gt;= h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路二-计数排序"><a href="#思路二-计数排序" class="headerlink" title="思路二 - 计数排序"></a>思路二 - 计数排序</h2><p>建立一个 [citations.length + 1] 长度的数组 buckets，表示被引用的次数。遍历 citations，根据每篇文章的引用次数，将文章累加到每一个 bucket 里面。按照上面的例子，数组本身的长度为 5，如果遇到被引用次数大于 5 的，也一律放在下标为 5 的位置上，因为引用次数大于 5 的文章再多，都不会影响这个作者的 H 指数。解释参见<a href="https://leetcode-cn.com/problems/h-index/solution/hzhi-shu-by-leetcode/">这个帖子</a>的方法二。从右往左再次遍历这个 buckets 并开始累加（注意这里累加的是文章的数量）。如果累加和大于或等于当前的 i - 也就是当前的被引用次数，我们就找到了这个 H 指数。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] citations)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> citations.length;<br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : citations) &#123;<br>            <span class="hljs-keyword">if</span> (c &gt;= n) &#123;<br>                bucket[n]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                bucket[c]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            count += bucket[i];<br>            <span class="hljs-keyword">if</span> (count &gt;= i) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">citations</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hIndex = <span class="hljs-keyword">function</span>(<span class="hljs-params">citations</span>) &#123;<br>    <span class="hljs-keyword">const</span> buckets = <span class="hljs-title class_">Array</span>(citations.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    citations.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">citation</span> =&gt;</span> &#123;<br>        buckets[citation &gt;= citations.<span class="hljs-property">length</span> ? citations.<span class="hljs-property">length</span> : citation]++;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = citations.<span class="hljs-property">length</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        count += buckets[i];<br>        <span class="hljs-keyword">if</span> (count &gt;= i) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>counting sort</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 287. Find the Duplicate Number</title>
    <link href="/posts/2603711760.html"/>
    <url>/posts/2603711760.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.</p><p>There is only one repeated number in nums, return this repeated number.</p><p>You must solve the problem without modifying the array nums and using only constant extra space.</p><p>Example 1:<br>Input: nums &#x3D; [1,3,4,2,2]<br>Output: 2</p><p>Example 2:<br>Input: nums &#x3D; [3,1,3,4,2]<br>Output: 3</p><p>Example 3:<br>Input: nums &#x3D; [3,3,3,3,3]<br>Output: 3</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n + 1<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>All the integers in nums appear only once except for precisely one integer which appears two or more times.</p><p>Follow up:<br>How can we prove that at least one duplicate number must exist in nums?<br>Can you solve the problem in linear runtime complexity?</p><p>寻找重复数。</p><blockquote><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/find-the-duplicate-number">https://leetcode.cn/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路一-二分法"><a href="#思路一-二分法" class="headerlink" title="思路一 - 二分法"></a>思路一 - 二分法</h2><p>注意数组是无序的。当得到数组长度 len 和数组长度的一半 mid 之后，用 count 记录有多少个数小于等于中间数 mid。举个例子，如果数组长度是 10，mid 则是 5，这里 mid 指的是数组长度的一半。如果小于 mid 的个数大于数组的一半，说明重复的数字一定是小于 mid 的；反之如果大于 mid 的个数过半，重复的数字一定是大于 mid 的。用二分法逐渐逼近这个值，注意 return 的是 left。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(nlogn) - 二分 logn * 每次找到 mid 之后要再把所有元素看一遍<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 因为数字的范围就是从1开始的，所以这里不是0，是1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 在 Java 里可以这么用，当 left + right 溢出的时候，无符号右移保证结果依然正确</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (num &lt;= mid) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个</span><br>            <span class="hljs-comment">// 此时重复元素一定出现在 [1, 4] 区间里</span><br>            <span class="hljs-keyword">if</span> (count &gt; mid) &#123;<br>                <span class="hljs-comment">// 重复元素位于区间 [left, mid]</span><br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// if 分析正确了以后，else 搜索的区间就是 if 的反面</span><br>                <span class="hljs-comment">// [mid + 1, right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> end = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-keyword">let</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start + end) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算总数组中有多少个数小于等于中间数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= middle) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (count &lt;= middle) &#123;<br>            start = middle + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            end = middle;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路二-快慢指针"><a href="#思路二-快慢指针" class="headerlink" title="思路二 - 快慢指针"></a>思路二 - 快慢指针</h2><p>这个思路很难想到，参考 142 题。因为数组一定是有重复数字出现而且数字的范围不大于数组的长度，所以可以用快慢指针的思路做。当快慢指针相遇之后，再走第二遍，再次相遇的地方就是环的起点，也就是重复的数字。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> nums[nums[<span class="hljs-number">0</span>]];<br>            <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>                slow = nums[slow];<br>                fast = nums[nums[fast]];<br>            &#125;<br>            slow = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>                slow = nums[slow];<br>                fast = nums[fast];<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findDuplicate = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> slow = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">let</span> fast = nums[nums[<span class="hljs-number">0</span>]];<br>        <span class="hljs-keyword">while</span> (slow !== fast) &#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        &#125;<br>        slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (slow !== fast) &#123;<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>binary search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 283. Move Zeroes</title>
    <link href="/posts/1531534607.html"/>
    <url>/posts/1531534607.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>Note that you must do this in-place without making a copy of the array.</p><p>Example 1:<br>Input: nums &#x3D; [0,1,0,3,12]<br>Output: [1,3,12,0,0]</p><p>Example 2:<br>Input: nums &#x3D; [0]<br>Output: [0]</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>Follow up: Could you minimize the total number of operations done?</p><p>移动零。</p><blockquote><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意很直观，将数组中所有 0 移动到数组的末端。要求不能使用额外空间。<br>思路是给一个 cur 指针和一个 i 指针，用 i 去遍历数组。当数组遇到非 0 的数字的时候，就放到 cur 的位置，cur++。如果扫描完整个数组 cur 的位置没有到达数组末尾，后面的位置用 0 补齐。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>nums[cur] = nums[i];<br>cur++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (cur &lt; nums.length) &#123;<br>nums[cur] = <span class="hljs-number">0</span>;<br>cur++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>JavaScript实现<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (nums[i] !== <span class="hljs-number">0</span>) &#123;<br>nums[cur] = nums[i];<br>cur++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (cur &lt; nums.<span class="hljs-property">length</span>) &#123;<br>nums[cur] = <span class="hljs-number">0</span>;<br>cur++;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">283. Move Zeroes<br>2460. Apply Operations to an Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 187. Repeated DNA Sequences</title>
    <link href="/posts/2461659226.html"/>
    <url>/posts/2461659226.html</url>
    
    <content type="html"><![CDATA[<p>The DNA sequence is composed of a series of nucleotides abbreviated as ‘A’, ‘C’, ‘G’, and ‘T’.</p><p>For example, “ACGAATTCCG” is a DNA sequence.</p><p>When studying DNA, it is useful to identify repeated sequences within the DNA.</p><p>Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.</p><p>Example 1:<br>Input: s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>Output: [“AAAAACCCCC”,”CCCCCAAAAA”]</p><p>Example 2:<br>Input: s &#x3D; “AAAAAAAAAAAAA”<br>Output: [“AAAAAAAAAA”]</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i] is either ‘A’, ‘C’, ‘G’, or ‘T’.</p><p>重复的DNA序列。</p><blockquote><p>DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。<br>例如，”ACGAATTCCG” 是一个 DNA序列 。在研究 DNA 时，识别 DNA 中的重复序列非常有用。<br>给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。<br>来源：力扣（LeetCode）链接：<a href="https://leetcode.cn/problems/repeated-dna-sequences">https://leetcode.cn/problems/repeated-dna-sequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给的 input 是一个 DNA 序列，请输出所有出现多次的 DNA 子序列。这题有位运算的做法但是感觉用 hashset 的做法更方便。注意 DNA 的定义是一个长度为 10 的子字符串。<br>思路是用两个 hashset，第一个存子序列是否出现过（seen），第二个存最后的输出（res）。当某个子序列在 seen 中已经有了，就存入 res；最后输出 res 里面所有的子序列。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - n 是 input 字符串长度<br>空间O(n) - 用了两个 hashset</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> &#123;<br>        HashSet&lt;String&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        HashSet&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(i, i + <span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">if</span> (!seen.add(str)) &#123;<br>                res.add(str);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findRepeatedDnaSequences = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br><span class="hljs-keyword">let</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span> - <span class="hljs-number">9</span>; i++) &#123;<br><span class="hljs-keyword">const</span> str = s.<span class="hljs-title function_">substring</span>(i, i + <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (seen.<span class="hljs-title function_">has</span>(str)) &#123;<br>res.<span class="hljs-title function_">add</span>(str);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>seen.<span class="hljs-title function_">add</span>(str);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(res);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 75. Sort Colors</title>
    <link href="/posts/2799717116.html"/>
    <url>/posts/2799717116.html</url>
    
    <content type="html"><![CDATA[<p>Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library’s sort function.</p><p>Example 1:<br>Input: nums &#x3D; [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]</p><p>Example 2:<br>Input: nums &#x3D; [2,0,1]<br>Output: [0,1,2]</p><p>Constraints:<br>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] is either 0, 1, or 2.</p><p>Follow up: Could you come up with a one-pass algorithm using only constant extra space?</p><p>颜色分类。</p><blockquote>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个数组，里面只有 0,1,2 三个数字，把数组排序成 [0, 0, 0, 1, 1, 1, ….1, 2, 2, 2, 2, 2] 的样子。</p><p>思路是 two pointer 夹逼扫描。这是一个有点类似快速排序里 partition 部分的做法。我们需要三个指针，cur，left 和 right。其中 left 和 right 分别指向数组最左边和最右边的位置，cur 指向的是当前需要处理的位置，表示当前这个位置要放什么元素。同时 cur 与 left 一样，也是从 0 开始。大体思路是我们尽量把 0 放到数组的左边，把 2 放到数组的右边，这样 1 也就尽可能被留在数组的中间部分了。最后附上官方的一个<a href="https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/">视频题解</a>帮助理解。</p><p>开始遍历的时候，我们关注 cur 指针指向的元素</p><ul><li>如果遇到 0，则放到左指针当前的位置（因为 0 都需要靠左嘛），left++，cur++。left++ 是因为 left 指针左边都是 0 了，所以要++，左边都处理完了；cur++ 是因为从 left 指针位置换过来的元素只有可能是 0 或 1，不可能是2，因为如果是2，他在之前就应该被移动到数组最右边了</li><li>如果遇到 1，不需要 swap 操作，只需要 cur++</li><li>如果遇到 2，则放到右指针的位置，同时 right–；因为 right 指针右边的部分处理完了，但是从 right 指针换过来的元素可能是 0 或者 1，所以 cur 不能++</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">0</span>) &#123;<br>                swap(nums, cur, left);<br>                cur++;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">1</span>) &#123;<br>                cur++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                swap(nums, cur, right);<br>                right--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125; Do not return anything, modify nums in-place instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> sortColors = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> == <span class="hljs-number">0</span> || nums == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cur &lt;= right) &#123;<br><span class="hljs-keyword">if</span> (nums[cur] === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-title function_">swap</span>(nums, cur, left);<br>cur++;<br>left++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] === <span class="hljs-number">1</span>) &#123;<br>cur++;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] === <span class="hljs-number">2</span>) &#123;<br><span class="hljs-title function_">swap</span>(nums, cur, right);<br>right--;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> swap = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, i, j</span>) &#123;<br><span class="hljs-keyword">let</span> temp = nums[i];<br>nums[i] = nums[j];<br>nums[j] = temp;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>two pointer</tag>
      
      <tag>quick sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 191. Number of 1 Bits</title>
    <link href="/posts/2691339022.html"/>
    <url>/posts/2691339022.html</url>
    
    <content type="html"><![CDATA[<p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight).</p><p>Note:<br>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.<br>In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3.</p><p>Example 1:<br>Input: n &#x3D; 00000000000000000000000000001011<br>Output: 3<br>Explanation: The input binary string 00000000000000000000000000001011 has a total of three ‘1’ bits.</p><p>Example 2:<br>Input: n &#x3D; 00000000000000000000000010000000<br>Output: 1<br>Explanation: The input binary string 00000000000000000000000010000000 has a total of one ‘1’ bit.</p><p>Example 3:<br>Input: n &#x3D; 11111111111111111111111111111101<br>Output: 31<br>Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one ‘1’ bits.</p><p>Constraints:<br>The input must be a binary string of length 32.<br>Follow up: If this function is called many times, how would you optimize it?</p><p>位1的个数。</p><blockquote><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。<br>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/number-of-1-bits">https://leetcode-cn.com/problems/number-of-1-bits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是给一个二进制的数字，求出其中1的个数。这题需要用到一个位运算的特性，建议背下来，就是 n &amp; (n-1) 会让 n 最右边的 1 变为 0。所以只要记一个 count，然后看看这个 &amp; 的操作做几次，数字整个变为 0，就说明过程中有几个 1 被变为 0 了。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - 因为是位运算，再怎么样都只有32位<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// you need to treat n as an unsigned value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span> - a positive integer</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> hammingWeight = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n !== <span class="hljs-number">0</span>) &#123;<br>        n &amp;= n - <span class="hljs-number">1</span>;<br>        res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">191. Number of 1 Bits<br>2859. Sum of Values at Indices With K Set Bits<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>bit manipulation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 206. Reverse Linked List</title>
    <link href="/posts/2655630186.html"/>
    <url>/posts/2655630186.html</url>
    
    <content type="html"><![CDATA[<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="Example 1"><br>Input: head &#x3D; [1,2,3,4,5]<br>Output: [5,4,3,2,1]</p><p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="Example 2"><br>Input: head &#x3D; [1,2]<br>Output: [2,1]</p><p>Example 3:<br>Input: head &#x3D; []<br>Output: []</p><p>Constraints:<br>The number of nodes in the list is the range [0, 5000].<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</p><p>Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?</p><p>反转链表。<br>这类reverse的题不会写，会写homebrew也枉然。</p><h2 id="思路-迭代"><a href="#思路-迭代" class="headerlink" title="思路 - 迭代"></a>思路 - 迭代</h2><p>首先是 iterative 的思路，创建一个空的指针 pre。当 head 不为空的时候，先存住 head.next，然后 head.next 指向 pre，最后 pre，head，next 三个指针整体往后移动一位。</p><p>也分享一个注释写的比较好的<a href="https://leetcode.com/problems/reverse-linked-list/discuss/375450/Javascript-Iterative-with-explanationcomments">discussion</a>和<a href="https://leetcode.cn/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">一个动图</a>帮助理解。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">let</span> next = head.<span class="hljs-property">next</span>;<br>        head.<span class="hljs-property">next</span> = pre;<br>        pre = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="思路-递归"><a href="#思路-递归" class="headerlink" title="思路 - 递归"></a>思路 - 递归</h2><p>这道题还有递归的做法。递归的思想是把大的问题拆解成足够小的问题，小的问题解决了，大的问题也就能解决。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n) - 递归栈空间</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">// 存住next节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-comment">// 递归函数处理next以及之后的部分</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseList(next);<br>        <span class="hljs-comment">// 处理当前节点和next之间的指针</span><br>        <span class="hljs-comment">// 本来head的next指针是指向next的，现在要反过来</span><br>        next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">206. Reverse Linked List<br>92. Reverse Linked List II<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>recursion</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 202. Happy Number</title>
    <link href="/posts/2038292781.html"/>
    <url>/posts/2038292781.html</url>
    
    <content type="html"><![CDATA[<p>Write an algorithm to determine if a number n is happy.</p><p>A happy number is a number defined by the following process:</p><p>Starting with any positive integer, replace the number by the sum of the squares of its digits.<br>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.<br>Those numbers for which this process ends in 1 are happy.<br>Return true if n is a happy number, and false if not.</p><p>Example 1:<br>Input: n &#x3D; 19<br>Output: true<br>Explanation:<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</p><p>Example 2:<br>Input: n &#x3D; 2<br>Output: false</p><p>Constraints:<br>1 &lt;&#x3D; n &lt;&#x3D; 2^31 - 1</p><p>快乐数。</p><blockquote>编写一个算法来判断一个数 n 是不是快乐数。<p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路就是按照其规则做运算，如果最后是 false，中间一定是有死循环，此处可以用 hashset 记录出现过的和。如果最后能算成 1，就是 true。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(1) - 因为稍微算几次就会出来，不会因着input变大而变大<br>空间O(n) - hashset</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>                sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>                n /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (set.contains(sum)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            set.add(sum);<br>            n = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">n</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isHappy = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    <span class="hljs-keyword">while</span> (n !== <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n = <span class="hljs-built_in">parseInt</span>(n / <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (set.<span class="hljs-title function_">has</span>(sum)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            set.<span class="hljs-title function_">add</span>(sum);<br>            n = sum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>hashmap</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 8. String to Integer (atoi)</title>
    <link href="/posts/2456288737.html"/>
    <url>/posts/2456288737.html</url>
    
    <content type="html"><![CDATA[<p>Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.</p><p>The algorithm for myAtoi(string s) is as follows:</p><p>Whitespace: Ignore any leading whitespace (“ “).<br>Signedness: Determine the sign by checking if the next character is ‘-‘ or ‘+’, assuming positivity if neither present.<br>Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.<br>Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.<br>Return the integer as the final result.</p><p>Example 1:<br>Input: s &#x3D; “42”<br>Output: 42</p><p>Explanation:<br>The underlined characters are what is read in and the caret is the current reader position.<br>Step 1: “42” (no characters read because there is no leading whitespace)<br> ^<br>Step 2: “42” (no characters read because there is neither a ‘-‘ nor ‘+’)<br> ^<br>Step 3: “42” (“42” is read in)<br> ^</p><p>Example 2:<br>Input: s &#x3D; “ -042”<br>Output: -42</p><p>Explanation:<br>Step 1: “ -042” (leading whitespace is read and ignored)<br> ^<br>Step 2: “ -042” (‘-‘ is read, so the result should be negative)<br> ^<br>Step 3: “ -042” (“042” is read in, leading zeros ignored in the result)<br> ^</p><p>Example 3:<br>Input: s &#x3D; “1337c0d3”<br>Output: 1337</p><p>Explanation:<br>Step 1: “1337c0d3” (no characters read because there is no leading whitespace)<br> ^<br>Step 2: “1337c0d3” (no characters read because there is neither a ‘-‘ nor ‘+’)<br> ^<br>Step 3: “1337c0d3” (“1337” is read in; reading stops because the next character is a non-digit)<br> ^</p><p>Example 4:<br>Input: s &#x3D; “0-1”<br>Output: 0</p><p>Explanation:<br>Step 1: “0-1” (no characters read because there is no leading whitespace)<br> ^<br>Step 2: “0-1” (no characters read because there is neither a ‘-‘ nor ‘+’)<br> ^<br>Step 3: “0-1” (“0” is read in; reading stops because the next character is a non-digit)<br> ^</p><p>Example 5:<br>Input: s &#x3D; “words and 987”<br>Output: 0</p><p>Explanation:<br>Reading stops at the first non-digit character ‘w’.</p><p>Constraints:<br>0 &lt;&#x3D; s.length &lt;&#x3D; 200<br>s consists of English letters (lower-case and upper-case), digits (0-9), ‘ ‘, ‘+’, ‘-‘, and ‘.’.</p><p>字符串转换整数 (atoi)。</p><blockquote>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。<p>函数 myAtoi(string s) 的算法如下：</p><p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。  </p><p>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。  </p><p>如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。  </p><p>注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/string-to-integer-atoi">https://leetcode.cn/problems/string-to-integer-atoi</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题考察的是字符串转数字。需要注意的几个点是</p><ol><li>trim掉字符串中间，前后出现过的所有的空格。例子，” 111 23 4 4 “需要处理成”1112344”，跳过所有的空格。</li><li>先判断第一个char是不是一个正负号，若是负号记得最后乘以-1。</li><li>对于之后的字符串，判断每个char是不是介于0-9之间，若不是，立马退出循环。若是，就正常计算。因为是从左往右扫描，所以计算方式参见20行。</li><li>计算过程中如果有任何时候发现res大于Integer.MAX_VALUE也立马退出循环，并根据sign的正负返回Integer.MAX_VALUE或者Integer.MIN_VALUE</li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String s)</span> &#123;<br>        s = s.trim();<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> s.charAt(start);<br>        <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            sign = <span class="hljs-number">1</span>;<br>            start++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            sign = -<span class="hljs-number">1</span>;<br>            start++;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i))) &#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res * sign;<br>            &#125;<br>            res = res * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (sign == <span class="hljs-number">1</span> &amp;&amp; res &gt; Integer.MAX_VALUE) &#123;<br>                <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sign == -<span class="hljs-number">1</span> &amp;&amp; res &gt; Integer.MAX_VALUE) &#123;<br>                <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res * sign;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">str</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> myAtoi = <span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-comment">// corner case</span><br>    str = str.<span class="hljs-title function_">trim</span>();<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || str.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// normal case</span><br>    <span class="hljs-keyword">let</span> firstChar = str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>        sign = <span class="hljs-number">1</span>;<br>        i++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>        sign = -<span class="hljs-number">1</span>;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (str.<span class="hljs-title function_">charAt</span>(i) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str.<span class="hljs-title function_">charAt</span>(i) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        res = res * <span class="hljs-number">10</span> + (str.<span class="hljs-title function_">charAt</span>(i) - <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (res * sign &gt;= <span class="hljs-number">2147483647</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res * sign &lt;= -<span class="hljs-number">2147483648</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">2147483648</span>;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res * sign;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>math</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 2. Add Two Numbers</title>
    <link href="/posts/2931343195.html"/>
    <url>/posts/2931343195.html</url>
    
    <content type="html"><![CDATA[<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" alt="Example 1"><br>Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>Output: [7,0,8]<br>Explanation: 342 + 465 &#x3D; 807.</p><p>Example 2:<br>Input: l1 &#x3D; [0], l2 &#x3D; [0]<br>Output: [0]</p><p>Example 3:<br>Input: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>Output: [8,9,9,9,0,0,0,1]</p><p>Constraints:<br>The number of nodes in each linked list is in the range [1, 100].<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>It is guaranteed that the list represents a number that does not have leading zeros.</p><p>两数相加。</p><blockquote>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/add-two-numbers">https://leetcode.cn/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题不难，思路是直接做加法，因为linked list给你的时候头结点是数字的最低位，不需要做reverse之类的操作，记得最后判断是不是还有额外的一个进位。</p><p>一般链表的题目只涉及操作，不涉及特别复杂的算法，所以具体做法和思路可以参见代码注释。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br><span class="hljs-comment">// 一般链表的题目都需要dummy node</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 为两个链表分别设置一个节点以供遍历</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> l2;<br>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span> || p2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1 != <span class="hljs-literal">null</span>) &#123;<br>                sum += p1.val;<br>                p1 = p1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p2 != <span class="hljs-literal">null</span>) &#123;<br>                sum += p2.val;<br>                p2 = p2.next;<br>            &#125;<br><span class="hljs-comment">// 为下一个节点做准备，这个节点记录的是当前计算结果的个位数</span><br><span class="hljs-comment">// e.g. 9 + 5 = 14, cur.next = 14</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 这里若有进位，sum可以把进位带到下一个节点</span><br>            sum /= <span class="hljs-number">10</span>;<br><span class="hljs-comment">// traverse到下一个节点</span><br>            cur = cur.next;<br>        &#125;<br><span class="hljs-comment">// 如果遍历完毕还有进位，说明还需要加一个节点，节点值为1</span><br>        <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-keyword">function</span> (<span class="hljs-params">l1, l2</span>) &#123;<br><span class="hljs-comment">// 一般链表的题目都需要dummy node</span><br><span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> cur = dummy;<br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 为两个链表分别设置一个节点以供遍历</span><br><span class="hljs-keyword">let</span> p1 = l1;<br><span class="hljs-keyword">let</span> p2 = l2;<br><span class="hljs-keyword">while</span> (p1 !== <span class="hljs-literal">null</span> || p2 !== <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (p1 !== <span class="hljs-literal">null</span>) &#123;<br>sum += p1.<span class="hljs-property">val</span>;<br>p1 = p1.<span class="hljs-property">next</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (p2 !== <span class="hljs-literal">null</span>) &#123;<br>sum += p2.<span class="hljs-property">val</span>;<br>p2 = p2.<span class="hljs-property">next</span>;<br>&#125;<br><span class="hljs-comment">// 为下一个节点做准备，这个节点记录的是当前计算结果的个位数</span><br><span class="hljs-comment">// e.g. 9 + 5 = 14, cur.next = 14</span><br>cur.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 这里若有进位，sum可以把进位带到下一个节点</span><br><span class="hljs-comment">// sum = parseInt(sum / 10);</span><br>sum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(sum / <span class="hljs-number">10</span>);<br>sum %= <span class="hljs-number">10</span>;<br><span class="hljs-comment">// traverse到下一个节点</span><br>cur = cur.<span class="hljs-property">next</span>;<br>&#125;<br><span class="hljs-comment">// 如果遍历完毕还有进位，说明还需要加一个节点，节点值为1</span><br><span class="hljs-keyword">if</span> (sum === <span class="hljs-number">1</span>) &#123;<br>cur.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">2. Add Two Numbers<br>445. Add Two Numbers II<br>21. Merge Two Sorted Lists<br>1634. Add Two Polynomials Represented as Linked Lists<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>linked list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 20. Valid Parentheses</title>
    <link href="/posts/869519969.html"/>
    <url>/posts/869519969.html</url>
    
    <content type="html"><![CDATA[<p>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:<br>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Every close bracket has a corresponding open bracket of the same type.</p><p>Example 1:<br>Input: s &#x3D; “()”<br>Output: true</p><p>Example 2:<br>Input: s &#x3D; “()[]{}”<br>Output: true</p><p>Example 3:<br>Input: s &#x3D; “(]”<br>Output: false</p><p>Constraints:<br>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s consists of parentheses only ‘()[]{}’.</p><p>有效的括号。</p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/valid-parentheses">https://leetcode.cn/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是用 stack 做。如果看到左半边括号就无条件压入栈；如果看到右半边括号，判断栈是不是为空，为空就报错；栈不为空再判断目前栈顶元素是不是相对应的左半边，若不是也报错。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                stack.push(c);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;(&#x27;</span> || s[i] === <span class="hljs-string">&#x27;[&#x27;</span> || s[i] === <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>            stack.<span class="hljs-title function_">push</span>(s[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || stack.<span class="hljs-title function_">pop</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || stack.<span class="hljs-title function_">pop</span>() != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] === <span class="hljs-string">&#x27;&#125;&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || stack.<span class="hljs-title function_">pop</span>() != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">20. Valid Parentheses<br>678. Valid Parenthesis String<br>1111. Maximum Nesting Depth of Two Valid Parentheses Strings<br>921. Minimum Add to Make Parentheses Valid<br>1541. Minimum Insertions to Balance a Parentheses String<br>1003. Check If Word Is Valid After Substitutions<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 242. Valid Anagram</title>
    <link href="/posts/2926013620.html"/>
    <url>/posts/2926013620.html</url>
    
    <content type="html"><![CDATA[<p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Example 1:<br>Input: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>Output: true</p><p>Example 2:<br>Input: s &#x3D; “rat”, t &#x3D; “car”<br>Output: false</p><p>Constraints:<br>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104<br>s and t consist of lowercase English letters.</p><p>Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p><p>有效的字母异位词。</p><blockquote>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/valid-anagram">https://leetcode.cn/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题用 counting sort 做，会用到 hashmap。思路是建立一个 hashmap，先扫描 s，记录 s 里面每个字母出现的次数；然后遍历 t 的时候，减去 t 里面每个字符出现的次数，如果这个过程中发现 t 中有任何字符在 hashmap 里不存在，就 return false。若没有，则再次遍历 hashmap，如果有任何一个 key 的 value 不是 0，也 return false。</p><p>这道题我们注意题目问的 followup，如果字符串里也有其他字符怎么办？这里我们的处理办法是把 count 数组变成256位，然后对于每个遇到的字符 char，我们直接就对 count[s.charAt(i)] 做加或减的操作。再要不然就直接用 hashmap 即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// count[s.charAt(i) - &#x27;a&#x27;]++;</span><br>            count[s.charAt(i)]++;<br>            count[t.charAt(i)]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; count.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (count[j] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">s</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">t</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isAnagram = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!map[s[i]]) &#123;<br>            map[s[i]] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map[s[i]]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!map[t[i]] || map[t[i]] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map[t[i]]--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> map) &#123;<br>        <span class="hljs-keyword">if</span> (map[key] !== <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>counting sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 128. Longest Consecutive Sequence</title>
    <link href="/posts/2698082129.html"/>
    <url>/posts/2698082129.html</url>
    
    <content type="html"><![CDATA[<p>Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.</p><p>You must write an algorithm that runs in O(n) time.</p><p>Example 1:<br>Input: nums &#x3D; [100,4,200,1,3,2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p><p>Example 2:<br>Input: nums &#x3D; [0,3,7,2,5,8,4,6,0,1]<br>Output: 9</p><p>Example 3:<br>Input: nums &#x3D; [1,0,1,2]<br>Output: 3</p><p>Constraints:<br>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>最长连续序列。</p><blockquote>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-consecutive-sequence">https://leetcode.cn/problems/longest-consecutive-sequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是在遍历数组的时候，第一次遍历先用 hashset 存住所有的元素。再遍历第二次，第二次遍历的时候，找每一个元素的 left (num - 1) 和 right (num + 1)，若找到，就在 hashset 中移除，同时移动 left 和 right 的位置。最终最长的子序列长度为 right - left - 1。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// corner case</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// normal case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> nums[i] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (set.contains(down)) &#123;<br>                set.remove(down);<br>                down--;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> nums[i] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (set.contains(up)) &#123;<br>                set.remove(up);<br>                up++;<br>            &#125;<br>            res = Math.max(res, up - down - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestConsecutive = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> num = nums[i];<br>        set.<span class="hljs-title function_">add</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> cur = nums[i];<br>        <span class="hljs-keyword">let</span> down = cur - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (set.<span class="hljs-title function_">has</span>(down)) &#123;<br>            set.<span class="hljs-title function_">delete</span>(down);<br>            down--;<br>        &#125;<br>        <span class="hljs-keyword">let</span> up = cur + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (set.<span class="hljs-title function_">has</span>(up)) &#123;<br>            set.<span class="hljs-title function_">delete</span>(up);<br>            up++;<br>        &#125;<br>        res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, up - down - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>LIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 334. Increasing Triplet Subsequence</title>
    <link href="/posts/1448283896.html"/>
    <url>/posts/1448283896.html</url>
    
    <content type="html"><![CDATA[<p>Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false.</p><p>Example 1:<br>Input: nums &#x3D; [1,2,3,4,5]<br>Output: true<br>Explanation: Any triplet where i &lt; j &lt; k is valid.</p><p>Example 2:<br>Input: nums &#x3D; [5,4,3,2,1]<br>Output: false<br>Explanation: No triplet exists.</p><p>Example 3:<br>Input: nums &#x3D; [2,1,5,0,4,6]<br>Output: true<br>Explanation: The triplet (3, 4, 5) is valid because nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6.</p><p>Constraints:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p><p>Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity?</p><p>递增的三元子序列。</p><blockquote><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。<br>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/increasing-triplet-subsequence">https://leetcode.cn/problems/increasing-triplet-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路是我们把遍历过程中遇到的可能组成上升子序列的三个数字分别记为 <code>first</code>, <code>second</code> 和 <code>third</code>，并把 <code>first</code> 和 <code>second</code> 设为 <code>Integer.MAX_VALUE</code>。开始遍历 input 数组，按照判断条件，我们会先遇到 <code>first</code>，然后如果有另一个数字大于 <code>first</code> 的话，就把他记为 <code>second</code>，如果再有一个数字大于 <code>second</code> 的话，则我们找到一个合法的解了。但是还有一种情况是如果我们找到 <code>second</code> 之后再遇到一个数字能小于 <code>first</code> 的话，我们就更新 <code>first</code>。这里的逻辑是尽量让 <code>first</code> 和 <code>second</code> 变得更小，这样能给第三个数字留充足的空间。</p><p>这里如果我们能找到一个数字比 <code>first</code> 更小的话（记为<code>first*</code>），此时三元组也是合法的。虽然 <code>first*</code> 出现在<code>second</code> 之后，但是他的出现并没有影响 <code>second</code> 的值，所以只要我们能找到一个数字大于 <code>second</code> 的话，那么还是能找到合法的解。</p><p>注意这道题是属于 <code>LIS</code> 最长上升子序列的题，只不过这个子序列的长度是固定的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">increasingTriplet</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br><span class="hljs-keyword">if</span> (num &lt;= first) &#123;<br>first = num;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt;= second) &#123;<br>second = num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> increasingTriplet = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br><span class="hljs-keyword">let</span> first = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>;<br><span class="hljs-keyword">let</span> second = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>;<br><span class="hljs-keyword">for</span> (num <span class="hljs-keyword">of</span> nums) &#123;<br><span class="hljs-keyword">if</span> (num &lt;= first) &#123;<br>first = num;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt;= second) &#123;<br>second = num;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>LIS</tag>
      
      <tag>selection sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 7. Reverse Integer</title>
    <link href="/posts/565450511.html"/>
    <url>/posts/565450511.html</url>
    
    <content type="html"><![CDATA[<p>Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.</p><p>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</p><p>Example 1:<br>Input: x &#x3D; 123<br>Output: 321</p><p>Example 2:<br>Input: x &#x3D; -123<br>Output: -321</p><p>Example 3:<br>Input: x &#x3D; 120<br>Output: 21 </p><p>Constraints:<br>-231 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p><p>整数反转。</p><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/reverse-integer">https://leetcode.cn/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题可以配合跟第九题一起做，思路是一样的。</p><p>跑一个例子吧，比如把 123 反转成 321。我们需要不断拿到 input 数字的最低位，加到结果 res 中，然后把 res 乘以 10，并将 input 除以 10，直到把 input 遍历成 0 为止。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n) - input 数字的长度<br>空间O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            res = res * <span class="hljs-number">10</span> + n % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (res &gt;= Integer.MAX_VALUE || res &lt;= Integer.MIN_VALUE) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverse = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>);<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x !== <span class="hljs-number">0</span>) &#123;<br>        res = res * <span class="hljs-number">10</span> + (x % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (res &gt; max || res &lt; -max) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>        x = <span class="hljs-built_in">parseInt</span>(x / <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">7. Reverse Integer<br>9. Palindrome Number<br>2108. Find First Palindromic String in the Array<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode] 1. Two Sum</title>
    <link href="/posts/4117090286.html"/>
    <url>/posts/4117090286.html</url>
    
    <content type="html"><![CDATA[<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>You can return the answer in any order.<br>Example 1:Input: nums &#x3D; [2,7,11,15], target &#x3D; 9Output: [0,1]Explanation: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].<br>Example 2:Input: nums &#x3D; [3,2,4], target &#x3D; 6Output: [1,2]<br>Example 3:Input: nums &#x3D; [3,3], target &#x3D; 6Output: [0,1]<br>Constraints:<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>Only one valid answer exists.<br>Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?</p><p>两数之和。</p><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>你可以按任意顺序返回答案。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力解是O(n^2)级别的复杂度，一定会超时。为了不超时，我们使用 hashmap 记录每个元素和他的下标。找的时候是在找 hashmap 里是否存在能组成 target 的另一个数字 target - nums[i]。<br>LC里面有一部分题目也是需要通过 hashmap 或者 two pointer 来加快运行速度的。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间O(n)<br>空间O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><span class="hljs-comment">// corner case</span><br><span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>&#125;<br><br><span class="hljs-comment">// normal case</span><br><span class="hljs-comment">// &lt;element, index&gt;</span><br>HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">complement</span> <span class="hljs-operator">=</span> target - nums[i];<br><span class="hljs-keyword">if</span> (map.containsKey(complement)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; map.get(complement), i &#125;;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>map.put(nums[i], i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> &#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br><span class="hljs-keyword">let</span> map = &#123;&#125;;<br><span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-keyword">let</span> cur = nums[i];<br><span class="hljs-keyword">let</span> complement = target - cur;<br><span class="hljs-keyword">if</span> (map[complement] !== <span class="hljs-literal">undefined</span>) &#123;<br><span class="hljs-keyword">return</span> [map[complement], i];<br>&#125;<br>map[cur] = i;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>javascript</tag>
      
      <tag>array</tag>
      
      <tag>hashmap</tag>
      
      <tag>two pointer</tag>
      
      <tag>two sum</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
